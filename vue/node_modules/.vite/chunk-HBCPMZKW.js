import {
  require_minimal as require_minimal2
} from "./chunk-AIGMFZXJ.js";
import {
  require_axios
} from "./chunk-IPASDQIS.js";
import {
  require_any,
  require_bank,
  require_build as require_build2,
  require_build2 as require_build3,
  require_build3 as require_build4,
  require_build4 as require_build5,
  require_build5 as require_build6,
  require_coin,
  require_minimal,
  require_multisig,
  require_signing,
  require_tx,
  require_tx2
} from "./chunk-77YZKLOI.js";
import {
  require_build
} from "./chunk-2INCKEC4.js";
import {
  require_long
} from "./chunk-V2MD6W3N.js";
import {
  __commonJS,
  define_global_default,
  init_define_global
} from "./chunk-LLTQ3AVL.js";

// node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js
var require_auth = __commonJS({
  "node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.ModuleAccount = exports.BaseAccount = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    exports.protobufPackage = "cosmos.auth.v1beta1";
    var baseBaseAccount = { address: "", accountNumber: long_1.default.UZERO, sequence: long_1.default.UZERO };
    exports.BaseAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pubKey !== void 0) {
          any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (!message.accountNumber.isZero()) {
          writer.uint32(24).uint64(message.accountNumber);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(32).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBaseAccount);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pubKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.accountNumber = reader.uint64();
              break;
            case 4:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseBaseAccount);
        message.address = object.address !== void 0 && object.address !== null ? String(object.address) : "";
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? any_1.Any.fromJSON(object.pubKey) : void 0;
        message.accountNumber = object.accountNumber !== void 0 && object.accountNumber !== null ? long_1.default.fromString(object.accountNumber) : long_1.default.UZERO;
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : void 0);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || long_1.default.UZERO).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseBaseAccount);
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? any_1.Any.fromPartial(object.pubKey) : void 0;
        message.accountNumber = object.accountNumber !== void 0 && object.accountNumber !== null ? long_1.default.fromValue(object.accountNumber) : long_1.default.UZERO;
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    var baseModuleAccount = { name: "", permissions: "" };
    exports.ModuleAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseAccount !== void 0) {
          exports.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        for (const v of message.permissions) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseModuleAccount);
        message.permissions = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = exports.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.permissions.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseModuleAccount);
        message.baseAccount = object.baseAccount !== void 0 && object.baseAccount !== null ? exports.BaseAccount.fromJSON(object.baseAccount) : void 0;
        message.name = object.name !== void 0 && object.name !== null ? String(object.name) : "";
        message.permissions = ((_a = object.permissions) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? exports.BaseAccount.toJSON(message.baseAccount) : void 0);
        message.name !== void 0 && (obj.name = message.name);
        if (message.permissions) {
          obj.permissions = message.permissions.map((e) => e);
        } else {
          obj.permissions = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseModuleAccount);
        message.baseAccount = object.baseAccount !== void 0 && object.baseAccount !== null ? exports.BaseAccount.fromPartial(object.baseAccount) : void 0;
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.permissions = ((_b = object.permissions) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    var baseParams = {
      maxMemoCharacters: long_1.default.UZERO,
      txSigLimit: long_1.default.UZERO,
      txSizeCostPerByte: long_1.default.UZERO,
      sigVerifyCostEd25519: long_1.default.UZERO,
      sigVerifyCostSecp256k1: long_1.default.UZERO
    };
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxMemoCharacters.isZero()) {
          writer.uint32(8).uint64(message.maxMemoCharacters);
        }
        if (!message.txSigLimit.isZero()) {
          writer.uint32(16).uint64(message.txSigLimit);
        }
        if (!message.txSizeCostPerByte.isZero()) {
          writer.uint32(24).uint64(message.txSizeCostPerByte);
        }
        if (!message.sigVerifyCostEd25519.isZero()) {
          writer.uint32(32).uint64(message.sigVerifyCostEd25519);
        }
        if (!message.sigVerifyCostSecp256k1.isZero()) {
          writer.uint32(40).uint64(message.sigVerifyCostSecp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxMemoCharacters = reader.uint64();
              break;
            case 2:
              message.txSigLimit = reader.uint64();
              break;
            case 3:
              message.txSizeCostPerByte = reader.uint64();
              break;
            case 4:
              message.sigVerifyCostEd25519 = reader.uint64();
              break;
            case 5:
              message.sigVerifyCostSecp256k1 = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseParams);
        message.maxMemoCharacters = object.maxMemoCharacters !== void 0 && object.maxMemoCharacters !== null ? long_1.default.fromString(object.maxMemoCharacters) : long_1.default.UZERO;
        message.txSigLimit = object.txSigLimit !== void 0 && object.txSigLimit !== null ? long_1.default.fromString(object.txSigLimit) : long_1.default.UZERO;
        message.txSizeCostPerByte = object.txSizeCostPerByte !== void 0 && object.txSizeCostPerByte !== null ? long_1.default.fromString(object.txSizeCostPerByte) : long_1.default.UZERO;
        message.sigVerifyCostEd25519 = object.sigVerifyCostEd25519 !== void 0 && object.sigVerifyCostEd25519 !== null ? long_1.default.fromString(object.sigVerifyCostEd25519) : long_1.default.UZERO;
        message.sigVerifyCostSecp256k1 = object.sigVerifyCostSecp256k1 !== void 0 && object.sigVerifyCostSecp256k1 !== null ? long_1.default.fromString(object.sigVerifyCostSecp256k1) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.maxMemoCharacters !== void 0 && (obj.maxMemoCharacters = (message.maxMemoCharacters || long_1.default.UZERO).toString());
        message.txSigLimit !== void 0 && (obj.txSigLimit = (message.txSigLimit || long_1.default.UZERO).toString());
        message.txSizeCostPerByte !== void 0 && (obj.txSizeCostPerByte = (message.txSizeCostPerByte || long_1.default.UZERO).toString());
        message.sigVerifyCostEd25519 !== void 0 && (obj.sigVerifyCostEd25519 = (message.sigVerifyCostEd25519 || long_1.default.UZERO).toString());
        message.sigVerifyCostSecp256k1 !== void 0 && (obj.sigVerifyCostSecp256k1 = (message.sigVerifyCostSecp256k1 || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseParams);
        message.maxMemoCharacters = object.maxMemoCharacters !== void 0 && object.maxMemoCharacters !== null ? long_1.default.fromValue(object.maxMemoCharacters) : long_1.default.UZERO;
        message.txSigLimit = object.txSigLimit !== void 0 && object.txSigLimit !== null ? long_1.default.fromValue(object.txSigLimit) : long_1.default.UZERO;
        message.txSizeCostPerByte = object.txSizeCostPerByte !== void 0 && object.txSizeCostPerByte !== null ? long_1.default.fromValue(object.txSizeCostPerByte) : long_1.default.UZERO;
        message.sigVerifyCostEd25519 = object.sigVerifyCostEd25519 !== void 0 && object.sigVerifyCostEd25519 !== null ? long_1.default.fromValue(object.sigVerifyCostEd25519) : long_1.default.UZERO;
        message.sigVerifyCostSecp256k1 = object.sigVerifyCostSecp256k1 !== void 0 && object.sigVerifyCostSecp256k1 !== null ? long_1.default.fromValue(object.sigVerifyCostSecp256k1) : long_1.default.UZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js
var require_vesting = __commonJS({
  "node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PermanentLockedAccount = exports.PeriodicVestingAccount = exports.Period = exports.DelayedVestingAccount = exports.ContinuousVestingAccount = exports.BaseVestingAccount = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var auth_1 = require_auth();
    var coin_1 = require_coin();
    exports.protobufPackage = "cosmos.vesting.v1beta1";
    var baseBaseVestingAccount = { endTime: long_1.default.ZERO };
    exports.BaseVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseAccount !== void 0) {
          auth_1.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.originalVesting) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.delegatedFree) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.delegatedVesting) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (!message.endTime.isZero()) {
          writer.uint32(40).int64(message.endTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBaseVestingAccount);
        message.originalVesting = [];
        message.delegatedFree = [];
        message.delegatedVesting = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.originalVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.delegatedFree.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.delegatedVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.endTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseBaseVestingAccount);
        message.baseAccount = object.baseAccount !== void 0 && object.baseAccount !== null ? auth_1.BaseAccount.fromJSON(object.baseAccount) : void 0;
        message.originalVesting = ((_a = object.originalVesting) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        message.delegatedFree = ((_b = object.delegatedFree) !== null && _b !== void 0 ? _b : []).map((e) => coin_1.Coin.fromJSON(e));
        message.delegatedVesting = ((_c = object.delegatedVesting) !== null && _c !== void 0 ? _c : []).map((e) => coin_1.Coin.fromJSON(e));
        message.endTime = object.endTime !== void 0 && object.endTime !== null ? long_1.default.fromString(object.endTime) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? auth_1.BaseAccount.toJSON(message.baseAccount) : void 0);
        if (message.originalVesting) {
          obj.originalVesting = message.originalVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.originalVesting = [];
        }
        if (message.delegatedFree) {
          obj.delegatedFree = message.delegatedFree.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedFree = [];
        }
        if (message.delegatedVesting) {
          obj.delegatedVesting = message.delegatedVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedVesting = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseBaseVestingAccount);
        message.baseAccount = object.baseAccount !== void 0 && object.baseAccount !== null ? auth_1.BaseAccount.fromPartial(object.baseAccount) : void 0;
        message.originalVesting = ((_a = object.originalVesting) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.delegatedFree = ((_b = object.delegatedFree) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.delegatedVesting = ((_c = object.delegatedVesting) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.endTime = object.endTime !== void 0 && object.endTime !== null ? long_1.default.fromValue(object.endTime) : long_1.default.ZERO;
        return message;
      }
    };
    var baseContinuousVestingAccount = { startTime: long_1.default.ZERO };
    exports.ContinuousVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (!message.startTime.isZero()) {
          writer.uint32(16).int64(message.startTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseContinuousVestingAccount);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseContinuousVestingAccount);
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports.BaseVestingAccount.fromJSON(object.baseVestingAccount) : void 0;
        message.startTime = object.startTime !== void 0 && object.startTime !== null ? long_1.default.fromString(object.startTime) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseContinuousVestingAccount);
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports.BaseVestingAccount.fromPartial(object.baseVestingAccount) : void 0;
        message.startTime = object.startTime !== void 0 && object.startTime !== null ? long_1.default.fromValue(object.startTime) : long_1.default.ZERO;
        return message;
      }
    };
    var baseDelayedVestingAccount = {};
    exports.DelayedVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDelayedVestingAccount);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDelayedVestingAccount);
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports.BaseVestingAccount.fromJSON(object.baseVestingAccount) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseDelayedVestingAccount);
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports.BaseVestingAccount.fromPartial(object.baseVestingAccount) : void 0;
        return message;
      }
    };
    var basePeriod = { length: long_1.default.ZERO };
    exports.Period = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.length.isZero()) {
          writer.uint32(8).int64(message.length);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePeriod);
        message.amount = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.length = reader.int64();
              break;
            case 2:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, basePeriod);
        message.length = object.length !== void 0 && object.length !== null ? long_1.default.fromString(object.length) : long_1.default.ZERO;
        message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.length !== void 0 && (obj.length = (message.length || long_1.default.ZERO).toString());
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, basePeriod);
        message.length = object.length !== void 0 && object.length !== null ? long_1.default.fromValue(object.length) : long_1.default.ZERO;
        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    var basePeriodicVestingAccount = { startTime: long_1.default.ZERO };
    exports.PeriodicVestingAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (!message.startTime.isZero()) {
          writer.uint32(16).int64(message.startTime);
        }
        for (const v of message.vestingPeriods) {
          exports.Period.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePeriodicVestingAccount);
        message.vestingPeriods = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            case 3:
              message.vestingPeriods.push(exports.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, basePeriodicVestingAccount);
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports.BaseVestingAccount.fromJSON(object.baseVestingAccount) : void 0;
        message.startTime = object.startTime !== void 0 && object.startTime !== null ? long_1.default.fromString(object.startTime) : long_1.default.ZERO;
        message.vestingPeriods = ((_a = object.vestingPeriods) !== null && _a !== void 0 ? _a : []).map((e) => exports.Period.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || long_1.default.ZERO).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? exports.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, basePeriodicVestingAccount);
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports.BaseVestingAccount.fromPartial(object.baseVestingAccount) : void 0;
        message.startTime = object.startTime !== void 0 && object.startTime !== null ? long_1.default.fromValue(object.startTime) : long_1.default.ZERO;
        message.vestingPeriods = ((_a = object.vestingPeriods) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Period.fromPartial(e))) || [];
        return message;
      }
    };
    var basePermanentLockedAccount = {};
    exports.PermanentLockedAccount = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePermanentLockedAccount);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePermanentLockedAccount);
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports.BaseVestingAccount.fromJSON(object.baseVestingAccount) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, basePermanentLockedAccount);
        message.baseVestingAccount = object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null ? exports.BaseVestingAccount.fromPartial(object.baseVestingAccount) : void 0;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/accounts.js
var require_accounts = __commonJS({
  "node_modules/@cosmjs/stargate/build/accounts.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountFromAny = void 0;
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build2();
    var auth_1 = require_auth();
    var vesting_1 = require_vesting();
    function uint64FromProto(input) {
      return math_1.Uint64.fromString(input.toString());
    }
    function accountFromBaseAccount(input) {
      const { address, pubKey, accountNumber, sequence } = input;
      const pubkey = (0, proto_signing_1.decodePubkey)(pubKey);
      return {
        address,
        pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
      };
    }
    function accountFromAny(input) {
      var _a, _b, _c, _d, _e, _f, _g;
      const { typeUrl, value } = input;
      switch (typeUrl) {
        case "/cosmos.auth.v1beta1.BaseAccount":
          return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount": {
          const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
          const baseAccount = (_a = vesting_1.BaseVestingAccount.decode(value)) === null || _a === void 0 ? void 0 : _a.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
          const baseAccount = (_c = (_b = vesting_1.ContinuousVestingAccount.decode(value)) === null || _b === void 0 ? void 0 : _b.baseVestingAccount) === null || _c === void 0 ? void 0 : _c.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
          const baseAccount = (_e = (_d = vesting_1.DelayedVestingAccount.decode(value)) === null || _d === void 0 ? void 0 : _d.baseVestingAccount) === null || _e === void 0 ? void 0 : _e.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
          const baseAccount = (_g = (_f = vesting_1.PeriodicVestingAccount.decode(value)) === null || _f === void 0 ? void 0 : _f.baseVestingAccount) === null || _g === void 0 ? void 0 : _g.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        default:
          throw new Error(`Unsupported type: '${typeUrl}'`);
      }
    }
    exports.accountFromAny = accountFromAny;
  }
});

// node_modules/@cosmjs/stargate/build/aminomsgs.js
var require_aminomsgs = __commonJS({
  "node_modules/@cosmjs/stargate/build/aminomsgs.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgTransfer = exports.isAminoMsgUndelegate = exports.isAminoMsgBeginRedelegate = exports.isAminoMsgDelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgCreateValidator = exports.isAminoMsgUnjail = exports.isAminoMsgDeposit = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = exports.isAminoMsgSubmitEvidence = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgVerifyInvariant = exports.isAminoMsgMultiSend = exports.isAminoMsgSend = void 0;
    function isAminoMsgSend(msg) {
      return msg.type === "cosmos-sdk/MsgSend";
    }
    exports.isAminoMsgSend = isAminoMsgSend;
    function isAminoMsgMultiSend(msg) {
      return msg.type === "cosmos-sdk/MsgMultiSend";
    }
    exports.isAminoMsgMultiSend = isAminoMsgMultiSend;
    function isAminoMsgVerifyInvariant(msg) {
      return msg.type === "cosmos-sdk/MsgVerifyInvariant";
    }
    exports.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
    function isAminoMsgSetWithdrawAddress(msg) {
      return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
    }
    exports.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
    function isAminoMsgWithdrawDelegatorReward(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
    }
    exports.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
    function isAminoMsgWithdrawValidatorCommission(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
    }
    exports.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
    function isAminoMsgFundCommunityPool(msg) {
      return msg.type === "cosmos-sdk/MsgFundCommunityPool";
    }
    exports.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
    function isAminoMsgSubmitEvidence(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitEvidence";
    }
    exports.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
    function isAminoMsgSubmitProposal(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitProposal";
    }
    exports.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
    function isAminoMsgVote(msg) {
      return msg.type === "cosmos-sdk/MsgVote";
    }
    exports.isAminoMsgVote = isAminoMsgVote;
    function isAminoMsgDeposit(msg) {
      return msg.type === "cosmos-sdk/MsgDeposit";
    }
    exports.isAminoMsgDeposit = isAminoMsgDeposit;
    function isAminoMsgUnjail(msg) {
      return msg.type === "cosmos-sdk/MsgUnjail";
    }
    exports.isAminoMsgUnjail = isAminoMsgUnjail;
    function isAminoMsgCreateValidator(msg) {
      return msg.type === "cosmos-sdk/MsgCreateValidator";
    }
    exports.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
    function isAminoMsgEditValidator(msg) {
      return msg.type === "cosmos-sdk/MsgEditValidator";
    }
    exports.isAminoMsgEditValidator = isAminoMsgEditValidator;
    function isAminoMsgDelegate(msg) {
      return msg.type === "cosmos-sdk/MsgDelegate";
    }
    exports.isAminoMsgDelegate = isAminoMsgDelegate;
    function isAminoMsgBeginRedelegate(msg) {
      return msg.type === "cosmos-sdk/MsgBeginRedelegate";
    }
    exports.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
    function isAminoMsgUndelegate(msg) {
      return msg.type === "cosmos-sdk/MsgUndelegate";
    }
    exports.isAminoMsgUndelegate = isAminoMsgUndelegate;
    function isAminoMsgTransfer(msg) {
      return msg.type === "cosmos-sdk/MsgTransfer";
    }
    exports.isAminoMsgTransfer = isAminoMsgTransfer;
  }
});

// node_modules/cosmjs-types/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/cosmjs-types/google/protobuf/timestamp.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Timestamp = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "google.protobuf";
    var baseTimestamp = { seconds: long_1.default.ZERO, nanos: 0 };
    exports.Timestamp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.seconds.isZero()) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTimestamp);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseTimestamp);
        message.seconds = object.seconds !== void 0 && object.seconds !== null ? long_1.default.fromString(object.seconds) : long_1.default.ZERO;
        message.nanos = object.nanos !== void 0 && object.nanos !== null ? Number(object.nanos) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || long_1.default.ZERO).toString());
        message.nanos !== void 0 && (obj.nanos = message.nanos);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseTimestamp);
        message.seconds = object.seconds !== void 0 && object.seconds !== null ? long_1.default.fromValue(object.seconds) : long_1.default.ZERO;
        message.nanos = (_a = object.nanos) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/google/protobuf/duration.js
var require_duration = __commonJS({
  "node_modules/cosmjs-types/google/protobuf/duration.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Duration = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "google.protobuf";
    var baseDuration = { seconds: long_1.default.ZERO, nanos: 0 };
    exports.Duration = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.seconds.isZero()) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDuration);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDuration);
        message.seconds = object.seconds !== void 0 && object.seconds !== null ? long_1.default.fromString(object.seconds) : long_1.default.ZERO;
        message.nanos = object.nanos !== void 0 && object.nanos !== null ? Number(object.nanos) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || long_1.default.ZERO).toString());
        message.nanos !== void 0 && (obj.nanos = message.nanos);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseDuration);
        message.seconds = object.seconds !== void 0 && object.seconds !== null ? long_1.default.fromValue(object.seconds) : long_1.default.ZERO;
        message.nanos = (_a = object.nanos) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js
var require_gov = __commonJS({
  "node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.TextProposal = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var coin_1 = require_coin();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption = exports.VoteOption || (exports.VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        default:
          return "UNKNOWN";
      }
    }
    exports.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus = exports.ProposalStatus || (exports.ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        default:
          return "UNKNOWN";
      }
    }
    exports.proposalStatusToJSON = proposalStatusToJSON;
    var baseWeightedVoteOption = { option: 0, weight: "" };
    exports.WeightedVoteOption = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWeightedVoteOption);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseWeightedVoteOption);
        message.option = object.option !== void 0 && object.option !== null ? voteOptionFromJSON(object.option) : 0;
        message.weight = object.weight !== void 0 && object.weight !== null ? String(object.weight) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseWeightedVoteOption);
        message.option = (_a = object.option) !== null && _a !== void 0 ? _a : 0;
        message.weight = (_b = object.weight) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseTextProposal = { title: "", description: "" };
    exports.TextProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTextProposal);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseTextProposal);
        message.title = object.title !== void 0 && object.title !== null ? String(object.title) : "";
        message.description = object.description !== void 0 && object.description !== null ? String(object.description) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseTextProposal);
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseDeposit = { proposalId: long_1.default.UZERO, depositor: "" };
    exports.Deposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDeposit);
        message.amount = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseDeposit);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.depositor = object.depositor !== void 0 && object.depositor !== null ? String(object.depositor) : "";
        message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseDeposit);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.depositor = (_a = object.depositor) !== null && _a !== void 0 ? _a : "";
        message.amount = ((_b = object.amount) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseProposal = { proposalId: long_1.default.UZERO, status: 0 };
    exports.Proposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
          coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseProposal);
        message.totalDeposit = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseProposal);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.content = object.content !== void 0 && object.content !== null ? any_1.Any.fromJSON(object.content) : void 0;
        message.status = object.status !== void 0 && object.status !== null ? proposalStatusFromJSON(object.status) : 0;
        message.finalTallyResult = object.finalTallyResult !== void 0 && object.finalTallyResult !== null ? exports.TallyResult.fromJSON(object.finalTallyResult) : void 0;
        message.submitTime = object.submitTime !== void 0 && object.submitTime !== null ? fromJsonTimestamp(object.submitTime) : void 0;
        message.depositEndTime = object.depositEndTime !== void 0 && object.depositEndTime !== null ? fromJsonTimestamp(object.depositEndTime) : void 0;
        message.totalDeposit = ((_a = object.totalDeposit) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        message.votingStartTime = object.votingStartTime !== void 0 && object.votingStartTime !== null ? fromJsonTimestamp(object.votingStartTime) : void 0;
        message.votingEndTime = object.votingEndTime !== void 0 && object.votingEndTime !== null ? fromJsonTimestamp(object.votingEndTime) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = fromTimestamp(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = fromTimestamp(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = fromTimestamp(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = fromTimestamp(message.votingEndTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseProposal);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.content = object.content !== void 0 && object.content !== null ? any_1.Any.fromPartial(object.content) : void 0;
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : 0;
        message.finalTallyResult = object.finalTallyResult !== void 0 && object.finalTallyResult !== null ? exports.TallyResult.fromPartial(object.finalTallyResult) : void 0;
        message.submitTime = object.submitTime !== void 0 && object.submitTime !== null ? timestamp_1.Timestamp.fromPartial(object.submitTime) : void 0;
        message.depositEndTime = object.depositEndTime !== void 0 && object.depositEndTime !== null ? timestamp_1.Timestamp.fromPartial(object.depositEndTime) : void 0;
        message.totalDeposit = ((_b = object.totalDeposit) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.votingStartTime = object.votingStartTime !== void 0 && object.votingStartTime !== null ? timestamp_1.Timestamp.fromPartial(object.votingStartTime) : void 0;
        message.votingEndTime = object.votingEndTime !== void 0 && object.votingEndTime !== null ? timestamp_1.Timestamp.fromPartial(object.votingEndTime) : void 0;
        return message;
      }
    };
    var baseTallyResult = { yes: "", abstain: "", no: "", noWithVeto: "" };
    exports.TallyResult = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.yes !== "") {
          writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
          writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
          writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
          writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTallyResult);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yes = reader.string();
              break;
            case 2:
              message.abstain = reader.string();
              break;
            case 3:
              message.no = reader.string();
              break;
            case 4:
              message.noWithVeto = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseTallyResult);
        message.yes = object.yes !== void 0 && object.yes !== null ? String(object.yes) : "";
        message.abstain = object.abstain !== void 0 && object.abstain !== null ? String(object.abstain) : "";
        message.no = object.no !== void 0 && object.no !== null ? String(object.no) : "";
        message.noWithVeto = object.noWithVeto !== void 0 && object.noWithVeto !== null ? String(object.noWithVeto) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.yes !== void 0 && (obj.yes = message.yes);
        message.abstain !== void 0 && (obj.abstain = message.abstain);
        message.no !== void 0 && (obj.no = message.no);
        message.noWithVeto !== void 0 && (obj.noWithVeto = message.noWithVeto);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseTallyResult);
        message.yes = (_a = object.yes) !== null && _a !== void 0 ? _a : "";
        message.abstain = (_b = object.abstain) !== null && _b !== void 0 ? _b : "";
        message.no = (_c = object.no) !== null && _c !== void 0 ? _c : "";
        message.noWithVeto = (_d = object.noWithVeto) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    var baseVote = { proposalId: long_1.default.UZERO, voter: "", option: 0 };
    exports.Vote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        for (const v of message.options) {
          exports.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVote);
        message.options = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseVote);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.voter = object.voter !== void 0 && object.voter !== null ? String(object.voter) : "";
        message.option = object.option !== void 0 && object.option !== null ? voteOptionFromJSON(object.option) : 0;
        message.options = ((_a = object.options) !== null && _a !== void 0 ? _a : []).map((e) => exports.WeightedVoteOption.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseVote);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.voter = (_a = object.voter) !== null && _a !== void 0 ? _a : "";
        message.option = (_b = object.option) !== null && _b !== void 0 ? _b : 0;
        message.options = ((_c = object.options) === null || _c === void 0 ? void 0 : _c.map((e) => exports.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    var baseDepositParams = {};
    exports.DepositParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.minDeposit) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDepositParams);
        message.minDeposit = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseDepositParams);
        message.minDeposit = ((_a = object.minDeposit) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        message.maxDepositPeriod = object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null ? duration_1.Duration.fromJSON(object.maxDepositPeriod) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseDepositParams);
        message.minDeposit = ((_a = object.minDeposit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.maxDepositPeriod = object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null ? duration_1.Duration.fromPartial(object.maxDepositPeriod) : void 0;
        return message;
      }
    };
    var baseVotingParams = {};
    exports.VotingParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVotingParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseVotingParams);
        message.votingPeriod = object.votingPeriod !== void 0 && object.votingPeriod !== null ? duration_1.Duration.fromJSON(object.votingPeriod) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseVotingParams);
        message.votingPeriod = object.votingPeriod !== void 0 && object.votingPeriod !== null ? duration_1.Duration.fromPartial(object.votingPeriod) : void 0;
        return message;
      }
    };
    var baseTallyParams = {};
    exports.TallyParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.quorum.length !== 0) {
          writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
          writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
          writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTallyParams);
        message.quorum = new Uint8Array();
        message.threshold = new Uint8Array();
        message.vetoThreshold = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.bytes();
              break;
            case 2:
              message.threshold = reader.bytes();
              break;
            case 3:
              message.vetoThreshold = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseTallyParams);
        message.quorum = object.quorum !== void 0 && object.quorum !== null ? bytesFromBase64(object.quorum) : new Uint8Array();
        message.threshold = object.threshold !== void 0 && object.threshold !== null ? bytesFromBase64(object.threshold) : new Uint8Array();
        message.vetoThreshold = object.vetoThreshold !== void 0 && object.vetoThreshold !== null ? bytesFromBase64(object.vetoThreshold) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = base64FromBytes(message.quorum !== void 0 ? message.quorum : new Uint8Array()));
        message.threshold !== void 0 && (obj.threshold = base64FromBytes(message.threshold !== void 0 ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = base64FromBytes(message.vetoThreshold !== void 0 ? message.vetoThreshold : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseTallyParams);
        message.quorum = (_a = object.quorum) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.threshold = (_b = object.threshold) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.vetoThreshold = (_c = object.vetoThreshold) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/aminotypes.js
var require_aminotypes = __commonJS({
  "node_modules/@cosmjs/stargate/build/aminotypes.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AminoTypes = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var utils_1 = require_build2();
    var gov_1 = require_gov();
    var any_1 = require_any();
    var long_1 = __importDefault(require_long());
    function omitDefault(input) {
      if (typeof input === "string") {
        return input === "" ? void 0 : input;
      }
      if (typeof input === "number") {
        return input === 0 ? void 0 : input;
      }
      if (long_1.default.isLong(input)) {
        return input.isZero() ? void 0 : input;
      }
      throw new Error(`Got unsupported type '${typeof input}'`);
    }
    function createDefaultTypes(prefix) {
      return {
        "/cosmos.bank.v1beta1.MsgSend": {
          aminoType: "cosmos-sdk/MsgSend",
          toAmino: ({ fromAddress, toAddress, amount }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount]
          }),
          fromAmino: ({ from_address, to_address, amount }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount]
          })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
          aminoType: "cosmos-sdk/MsgMultiSend",
          toAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          }),
          fromAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          })
        },
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
          aminoType: "cosmos-sdk/MsgFundCommunityPool",
          toAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          }),
          fromAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
          aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
          toAmino: ({ delegatorAddress, withdrawAddress }) => ({
            delegator_address: delegatorAddress,
            withdraw_address: withdrawAddress
          }),
          fromAmino: ({ delegator_address, withdraw_address }) => ({
            delegatorAddress: delegator_address,
            withdrawAddress: withdraw_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
          aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
          toAmino: ({ delegatorAddress, validatorAddress }) => ({
            delegator_address: delegatorAddress,
            validator_address: validatorAddress
          }),
          fromAmino: ({ delegator_address, validator_address }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
          aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
          toAmino: ({ validatorAddress }) => ({
            validator_address: validatorAddress
          }),
          fromAmino: ({ validator_address }) => ({
            validatorAddress: validator_address
          })
        },
        "/cosmos.gov.v1beta1.MsgDeposit": {
          aminoType: "cosmos-sdk/MsgDeposit",
          toAmino: ({ amount, depositor, proposalId }) => {
            return {
              amount,
              depositor,
              proposal_id: proposalId.toString()
            };
          },
          fromAmino: ({ amount, depositor, proposal_id }) => {
            return {
              amount: Array.from(amount),
              depositor,
              proposalId: long_1.default.fromString(proposal_id)
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
          aminoType: "cosmos-sdk/MsgVote",
          toAmino: ({ option, proposalId, voter }) => {
            return {
              option,
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ option, proposal_id, voter }) => {
            return {
              option: (0, gov_1.voteOptionFromJSON)(option),
              proposalId: long_1.default.fromString(proposal_id),
              voter
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
          aminoType: "cosmos-sdk/MsgSubmitProposal",
          toAmino: ({ initialDeposit, proposer, content }) => {
            (0, utils_1.assertDefinedAndNotNull)(content);
            let proposal;
            switch (content.typeUrl) {
              case "/cosmos.gov.v1beta1.TextProposal": {
                const textProposal = gov_1.TextProposal.decode(content.value);
                proposal = {
                  type: "cosmos-sdk/TextProposal",
                  value: {
                    description: textProposal.description,
                    title: textProposal.title
                  }
                };
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
            }
            return {
              initial_deposit: initialDeposit,
              proposer,
              content: proposal
            };
          },
          fromAmino: ({ initial_deposit, proposer, content }) => {
            let any_content;
            switch (content.type) {
              case "cosmos-sdk/TextProposal": {
                const { value } = content;
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                const { title, description } = value;
                (0, utils_1.assert)(typeof title === "string");
                (0, utils_1.assert)(typeof description === "string");
                any_content = any_1.Any.fromPartial({
                  typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                  value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                    title,
                    description
                  })).finish()
                });
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.type}'`);
            }
            return {
              initialDeposit: Array.from(initial_deposit),
              proposer,
              content: any_content
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
          aminoType: "cosmos-sdk/MsgBeginRedelegate",
          toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_src_address: validatorSrcAddress,
              validator_dst_address: validatorDstAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorSrcAddress: validator_src_address,
            validatorDstAddress: validator_dst_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
          aminoType: "cosmos-sdk/MsgCreateValidator",
          toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
            (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
            (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission: {
                rate: commission.rate,
                max_rate: commission.maxRate,
                max_change_rate: commission.maxChangeRate
              },
              min_self_delegation: minSelfDelegation,
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              pubkey: (0, amino_1.encodeBech32Pubkey)({
                type: "tendermint/PubKeySecp256k1",
                value: (0, encoding_1.toBase64)(pubkey.value)
              }, prefix),
              value
            };
          },
          fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value }) => {
            const decodedPubkey = (0, amino_1.decodeBech32Pubkey)(pubkey);
            if (decodedPubkey.type !== "tendermint/PubKeySecp256k1") {
              throw new Error("Only Secp256k1 public keys are supported");
            }
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                securityContact: description.security_contact,
                details: description.details
              },
              commission: {
                rate: commission.rate,
                maxRate: commission.max_rate,
                maxChangeRate: commission.max_change_rate
              },
              minSelfDelegation: min_self_delegation,
              delegatorAddress: delegator_address,
              validatorAddress: validator_address,
              pubkey: {
                typeUrl: "/cosmos.crypto.secp256k1.PubKey",
                value: (0, encoding_1.fromBase64)(decodedPubkey.value)
              },
              value
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
          aminoType: "cosmos-sdk/MsgDelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
          aminoType: "cosmos-sdk/MsgEditValidator",
          toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission_rate: commissionRate,
              min_self_delegation: minSelfDelegation,
              validator_address: validatorAddress
            };
          },
          fromAmino: ({ description, commission_rate, min_self_delegation, validator_address }) => ({
            description: {
              moniker: description.moniker,
              identity: description.identity,
              website: description.website,
              securityContact: description.security_contact,
              details: description.details
            },
            commissionRate: commission_rate,
            minSelfDelegation: min_self_delegation,
            validatorAddress: validator_address
          })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
          aminoType: "cosmos-sdk/MsgUndelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/ibc.applications.transfer.v1.MsgTransfer": {
          aminoType: "cosmos-sdk/MsgTransfer",
          toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp }) => {
            var _a, _b, _c;
            return {
              source_port: sourcePort,
              source_channel: sourceChannel,
              token,
              sender,
              receiver,
              timeout_height: timeoutHeight ? {
                revision_height: (_a = omitDefault(timeoutHeight.revisionHeight)) === null || _a === void 0 ? void 0 : _a.toString(),
                revision_number: (_b = omitDefault(timeoutHeight.revisionNumber)) === null || _b === void 0 ? void 0 : _b.toString()
              } : {},
              timeout_timestamp: (_c = omitDefault(timeoutTimestamp)) === null || _c === void 0 ? void 0 : _c.toString()
            };
          },
          fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp }) => ({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token,
            sender,
            receiver,
            timeoutHeight: timeout_height ? {
              revisionHeight: long_1.default.fromString(timeout_height.revision_height || "0", true),
              revisionNumber: long_1.default.fromString(timeout_height.revision_number || "0", true)
            } : void 0,
            timeoutTimestamp: long_1.default.fromString(timeout_timestamp || "0", true)
          })
        }
      };
    }
    var AminoTypes = class {
      constructor({ additions = {}, prefix = "cosmos" } = {}) {
        const additionalAminoTypes = Object.values(additions);
        const filteredDefaultTypes = Object.entries(createDefaultTypes(prefix)).reduce((acc, [key, value]) => additionalAminoTypes.find(({ aminoType }) => value.aminoType === aminoType) ? acc : Object.assign(Object.assign({}, acc), { [key]: value }), {});
        this.register = Object.assign(Object.assign({}, filteredDefaultTypes), additions);
      }
      toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) {
          throw new Error("Type URL does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.");
        }
        return {
          type: converter.aminoType,
          value: converter.toAmino(value)
        };
      }
      fromAmino({ type, value }) {
        const result = Object.entries(this.register).find(([_typeUrl, { aminoType }]) => aminoType === type);
        if (!result) {
          throw new Error("Type does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.");
        }
        const [typeUrl, converter] = result;
        return {
          typeUrl,
          value: converter.fromAmino(value)
        };
      }
    };
    exports.AminoTypes = AminoTypes;
  }
});

// node_modules/@cosmjs/stargate/build/encodeobjects.js
var require_encodeobjects = __commonJS({
  "node_modules/@cosmjs/stargate/build/encodeobjects.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.isMsgTransferEncodeObject = exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgSendEncodeObject = void 0;
    function isMsgSendEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
    }
    exports.isMsgSendEncodeObject = isMsgSendEncodeObject;
    function isMsgDelegateEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
    }
    exports.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
    function isMsgUndelegateEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
    }
    exports.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
    function isMsgWithdrawDelegatorRewardEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
    }
    exports.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
    function isMsgTransferEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
    }
    exports.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
    function isMsgDepositEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
    }
    exports.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
    function isMsgSubmitProposalEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
    }
    exports.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
    function isMsgVoteEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
    }
    exports.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
  }
});

// node_modules/@cosmjs/stargate/build/fee.js
var require_fee = __commonJS({
  "node_modules/@cosmjs/stargate/build/fee.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calculateFee = exports.GasPrice = void 0;
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    function checkDenom(denom) {
      if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
      }
    }
    var GasPrice = class {
      constructor(amount, denom) {
        this.amount = amount;
        this.denom = denom;
      }
      static fromString(gasPrice) {
        const matchResult = gasPrice.match(/^([0-9.]+)([a-z][a-z0-9]*)$/i);
        if (!matchResult) {
          throw new Error("Invalid gas price string");
        }
        const [_, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new GasPrice(decimalAmount, denom);
      }
      toString() {
        return this.amount.toString() + this.denom;
      }
    };
    exports.GasPrice = GasPrice;
    function calculateFee(gasLimit, gasPrice) {
      const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
      const { denom, amount: gasPriceAmount } = processedGasPrice;
      const amount = Math.ceil(gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).toFloatApproximation());
      return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
      };
    }
    exports.calculateFee = calculateFee;
  }
});

// node_modules/@cosmjs/stargate/build/logs.js
var require_logs = __commonJS({
  "node_modules/@cosmjs/stargate/build/logs.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAttribute = exports.parseRawLog = exports.parseLogs = exports.parseLog = exports.parseEvent = exports.parseAttribute = void 0;
    var utils_1 = require_build2();
    function parseAttribute(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Attribute must be a non-null object");
      const { key, value } = input;
      if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
      if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
      }
      return {
        key,
        value: value || ""
      };
    }
    exports.parseAttribute = parseAttribute;
    function parseEvent(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Event must be a non-null object");
      const { type, attributes } = input;
      if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
      }
      if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
      return {
        type,
        attributes: attributes.map(parseAttribute)
      };
    }
    exports.parseEvent = parseEvent;
    function parseLog(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Log must be a non-null object");
      const { msg_index, log, events } = input;
      if (typeof msg_index !== "number")
        throw new Error("Log's msg_index must be a number");
      if (typeof log !== "string")
        throw new Error("Log's log must be a string");
      if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
      return {
        msg_index,
        log,
        events: events.map(parseEvent)
      };
    }
    exports.parseLog = parseLog;
    function parseLogs(input) {
      if (!Array.isArray(input))
        throw new Error("Logs must be an array");
      return input.map(parseLog);
    }
    exports.parseLogs = parseLogs;
    function parseRawLog(input = "[]") {
      const logsToParse = JSON.parse(input).map(({ events }, i) => ({
        msg_index: i,
        events,
        log: ""
      }));
      return parseLogs(logsToParse);
    }
    exports.parseRawLog = parseRawLog;
    function findAttribute(logs, eventType, attrKey) {
      var _a;
      const firstLogs = logs.find(() => true);
      const out = (_a = firstLogs === null || firstLogs === void 0 ? void 0 : firstLogs.events.find((event) => event.type === eventType)) === null || _a === void 0 ? void 0 : _a.attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
    exports.findAttribute = findAttribute;
  }
});

// node_modules/@cosmjs/stargate/build/multisignature.js
var require_multisignature = __commonJS({
  "node_modules/@cosmjs/stargate/build/multisignature.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeMultisignedTx = exports.makeCompactBitArray = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var proto_signing_1 = require_build6();
    var multisig_1 = require_multisig();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    var tx_2 = require_tx();
    var long_1 = __importDefault(require_long());
    function makeCompactBitArray(bits) {
      const byteCount = Math.ceil(bits.length / 8);
      const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
      const bytes = new Uint8Array(byteCount);
      bits.forEach((value, index) => {
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        if (value)
          bytes[bytePos] |= 1 << 8 - 1 - bitPos;
      });
      return multisig_1.CompactBitArray.fromPartial({ elems: bytes, extraBitsStored: extraBits });
    }
    exports.makeCompactBitArray = makeCompactBitArray;
    function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const addresses = Array.from(signatures.keys());
      const prefix = encoding_1.Bech32.decode(addresses[0]).prefix;
      const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
      const signaturesList = new Array();
      for (let i = 0; i < multisigPubkey.value.pubkeys.length; i++) {
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
          signers[i] = true;
          signaturesList.push(signature);
        }
      }
      const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
          multi: {
            bitarray: makeCompactBitArray(signers),
            modeInfos: signaturesList.map((_) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
          }
        },
        sequence: long_1.default.fromNumber(sequence)
      };
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [signerInfo],
        fee: {
          amount: [...fee.amount],
          gasLimit: long_1.default.fromString(fee.gas)
        }
      });
      const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
      const signedTx = tx_2.TxRaw.fromPartial({
        bodyBytes,
        authInfoBytes,
        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()]
      });
      return signedTx;
    }
    exports.makeMultisignedTx = makeMultisignedTx;
  }
});

// node_modules/@confio/ics23/build/generated/codecimpl.js
var require_codecimpl = __commonJS({
  "node_modules/@confio/ics23/build/generated/codecimpl.js"(exports, module) {
    init_define_global();
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.ics23 = function() {
      var ics23 = {};
      ics23.HashOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_HASH"] = 0;
        values[valuesById[1] = "SHA256"] = 1;
        values[valuesById[2] = "SHA512"] = 2;
        values[valuesById[3] = "KECCAK"] = 3;
        values[valuesById[4] = "RIPEMD160"] = 4;
        values[valuesById[5] = "BITCOIN"] = 5;
        values[valuesById[6] = "SHA512_256"] = 6;
        return values;
      }();
      ics23.LengthOp = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NO_PREFIX"] = 0;
        values[valuesById[1] = "VAR_PROTO"] = 1;
        values[valuesById[2] = "VAR_RLP"] = 2;
        values[valuesById[3] = "FIXED32_BIG"] = 3;
        values[valuesById[4] = "FIXED32_LITTLE"] = 4;
        values[valuesById[5] = "FIXED64_BIG"] = 5;
        values[valuesById[6] = "FIXED64_LITTLE"] = 6;
        values[valuesById[7] = "REQUIRE_32_BYTES"] = 7;
        values[valuesById[8] = "REQUIRE_64_BYTES"] = 8;
        return values;
      }();
      ics23.ExistenceProof = function() {
        function ExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ExistenceProof.prototype.key = $util.newBuffer([]);
        ExistenceProof.prototype.value = $util.newBuffer([]);
        ExistenceProof.prototype.leaf = null;
        ExistenceProof.prototype.path = $util.emptyArray;
        ExistenceProof.create = function create(properties) {
          return new ExistenceProof(properties);
        };
        ExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(10).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(18).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
          if (message.path != null && message.path.length)
            for (var i = 0; i < message.path.length; ++i)
              $root.ics23.InnerOp.encode(message.path[i], writer.uint32(34).fork()).ldelim();
          return writer;
        };
        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.path[i]);
              if (error)
                return "path." + error;
            }
          }
          return null;
        };
        ExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ExistenceProof)
            return object;
          var message = new $root.ics23.ExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.ExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.ExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i) {
              if (typeof object.path[i] !== "object")
                throw TypeError(".ics23.ExistenceProof.path: object expected");
              message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);
            }
          }
          return message;
        };
        ExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);
          }
          return object;
        };
        ExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ExistenceProof;
      }();
      ics23.NonExistenceProof = function() {
        function NonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        NonExistenceProof.prototype.key = $util.newBuffer([]);
        NonExistenceProof.prototype.left = null;
        NonExistenceProof.prototype.right = null;
        NonExistenceProof.create = function create(properties) {
          return new NonExistenceProof(properties);
        };
        NonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(10).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
          return writer;
        };
        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        NonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        NonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.ExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.ExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        NonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.NonExistenceProof)
            return object;
          var message = new $root.ics23.NonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.NonExistenceProof.left: object expected");
            message.left = $root.ics23.ExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.NonExistenceProof.right: object expected");
            message.right = $root.ics23.ExistenceProof.fromObject(object.right);
          }
          return message;
        };
        NonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.ExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.ExistenceProof.toObject(message.right, options);
          return object;
        };
        NonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return NonExistenceProof;
      }();
      ics23.CommitmentProof = function() {
        function CommitmentProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CommitmentProof.prototype.exist = null;
        CommitmentProof.prototype.nonexist = null;
        CommitmentProof.prototype.batch = null;
        CommitmentProof.prototype.compressed = null;
        var $oneOfFields;
        Object.defineProperty(CommitmentProof.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist", "batch", "compressed"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CommitmentProof.create = function create(properties) {
          return new CommitmentProof(properties);
        };
        CommitmentProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
          if (message.batch != null && message.hasOwnProperty("batch"))
            $root.ics23.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();
          if (message.compressed != null && message.hasOwnProperty("compressed"))
            $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();
          return writer;
        };
        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CommitmentProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());
                break;
              case 4:
                message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CommitmentProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.BatchProof.verify(message.batch);
              if (error)
                return "batch." + error;
            }
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedBatchProof.verify(message.compressed);
              if (error)
                return "compressed." + error;
            }
          }
          return null;
        };
        CommitmentProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CommitmentProof)
            return object;
          var message = new $root.ics23.CommitmentProof();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CommitmentProof.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CommitmentProof.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          if (object.batch != null) {
            if (typeof object.batch !== "object")
              throw TypeError(".ics23.CommitmentProof.batch: object expected");
            message.batch = $root.ics23.BatchProof.fromObject(object.batch);
          }
          if (object.compressed != null) {
            if (typeof object.compressed !== "object")
              throw TypeError(".ics23.CommitmentProof.compressed: object expected");
            message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);
          }
          return message;
        };
        CommitmentProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          if (message.batch != null && message.hasOwnProperty("batch")) {
            object.batch = $root.ics23.BatchProof.toObject(message.batch, options);
            if (options.oneofs)
              object.proof = "batch";
          }
          if (message.compressed != null && message.hasOwnProperty("compressed")) {
            object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);
            if (options.oneofs)
              object.proof = "compressed";
          }
          return object;
        };
        CommitmentProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CommitmentProof;
      }();
      ics23.LeafOp = function() {
        function LeafOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        LeafOp.prototype.hash = 0;
        LeafOp.prototype.prehashKey = 0;
        LeafOp.prototype.prehashValue = 0;
        LeafOp.prototype.length = 0;
        LeafOp.prototype.prefix = $util.newBuffer([]);
        LeafOp.create = function create(properties) {
          return new LeafOp(properties);
        };
        LeafOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(8).int32(message.hash);
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            writer.uint32(16).int32(message.prehashKey);
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            writer.uint32(24).int32(message.prehashValue);
          if (message.length != null && message.hasOwnProperty("length"))
            writer.uint32(32).int32(message.length);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(42).bytes(message.prefix);
          return writer;
        };
        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        LeafOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prehashKey = reader.int32();
                break;
              case 3:
                message.prehashValue = reader.int32();
                break;
              case 4:
                message.length = reader.int32();
                break;
              case 5:
                message.prefix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        LeafOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        LeafOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            switch (message.prehashKey) {
              default:
                return "prehashKey: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            switch (message.prehashValue) {
              default:
                return "prehashValue: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.length != null && message.hasOwnProperty("length"))
            switch (message.length) {
              default:
                return "length: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          return null;
        };
        LeafOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.LeafOp)
            return object;
          var message = new $root.ics23.LeafOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          switch (object.prehashKey) {
            case "NO_HASH":
            case 0:
              message.prehashKey = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashKey = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashKey = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashKey = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashKey = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashKey = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashKey = 6;
              break;
          }
          switch (object.prehashValue) {
            case "NO_HASH":
            case 0:
              message.prehashValue = 0;
              break;
            case "SHA256":
            case 1:
              message.prehashValue = 1;
              break;
            case "SHA512":
            case 2:
              message.prehashValue = 2;
              break;
            case "KECCAK":
            case 3:
              message.prehashValue = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.prehashValue = 4;
              break;
            case "BITCOIN":
            case 5:
              message.prehashValue = 5;
              break;
            case "SHA512_256":
            case 6:
              message.prehashValue = 6;
              break;
          }
          switch (object.length) {
            case "NO_PREFIX":
            case 0:
              message.length = 0;
              break;
            case "VAR_PROTO":
            case 1:
              message.length = 1;
              break;
            case "VAR_RLP":
            case 2:
              message.length = 2;
              break;
            case "FIXED32_BIG":
            case 3:
              message.length = 3;
              break;
            case "FIXED32_LITTLE":
            case 4:
              message.length = 4;
              break;
            case "FIXED64_BIG":
            case 5:
              message.length = 5;
              break;
            case "FIXED64_LITTLE":
            case 6:
              message.length = 6;
              break;
            case "REQUIRE_32_BYTES":
            case 7:
              message.length = 7;
              break;
            case "REQUIRE_64_BYTES":
            case 8:
              message.length = 8;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          return message;
        };
        LeafOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            object.prehashKey = options.enums === String ? "NO_HASH" : 0;
            object.prehashValue = options.enums === String ? "NO_HASH" : 0;
            object.length = options.enums === String ? "NO_PREFIX" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prehashKey != null && message.hasOwnProperty("prehashKey"))
            object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;
          if (message.prehashValue != null && message.hasOwnProperty("prehashValue"))
            object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;
          if (message.length != null && message.hasOwnProperty("length"))
            object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          return object;
        };
        LeafOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return LeafOp;
      }();
      ics23.InnerOp = function() {
        function InnerOp(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerOp.prototype.hash = 0;
        InnerOp.prototype.prefix = $util.newBuffer([]);
        InnerOp.prototype.suffix = $util.newBuffer([]);
        InnerOp.create = function create(properties) {
          return new InnerOp(properties);
        };
        InnerOp.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(8).int32(message.hash);
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            writer.uint32(18).bytes(message.prefix);
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            writer.uint32(26).bytes(message.suffix);
          return writer;
        };
        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerOp.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.hash = reader.int32();
                break;
              case 2:
                message.prefix = reader.bytes();
                break;
              case 3:
                message.suffix = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerOp.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerOp.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          if (message.prefix != null && message.hasOwnProperty("prefix")) {
            if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
              return "prefix: buffer expected";
          }
          if (message.suffix != null && message.hasOwnProperty("suffix")) {
            if (!(message.suffix && typeof message.suffix.length === "number" || $util.isString(message.suffix)))
              return "suffix: buffer expected";
          }
          return null;
        };
        InnerOp.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerOp)
            return object;
          var message = new $root.ics23.InnerOp();
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          if (object.prefix != null) {
            if (typeof object.prefix === "string")
              $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
            else if (object.prefix.length)
              message.prefix = object.prefix;
          }
          if (object.suffix != null) {
            if (typeof object.suffix === "string")
              $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);
            else if (object.suffix.length)
              message.suffix = object.suffix;
          }
          return message;
        };
        InnerOp.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.hash = options.enums === String ? "NO_HASH" : 0;
            if (options.bytes === String)
              object.prefix = "";
            else {
              object.prefix = [];
              if (options.bytes !== Array)
                object.prefix = $util.newBuffer(object.prefix);
            }
            if (options.bytes === String)
              object.suffix = "";
            else {
              object.suffix = [];
              if (options.bytes !== Array)
                object.suffix = $util.newBuffer(object.suffix);
            }
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          if (message.prefix != null && message.hasOwnProperty("prefix"))
            object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
          if (message.suffix != null && message.hasOwnProperty("suffix"))
            object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;
          return object;
        };
        InnerOp.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerOp;
      }();
      ics23.ProofSpec = function() {
        function ProofSpec(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ProofSpec.prototype.leafSpec = null;
        ProofSpec.prototype.innerSpec = null;
        ProofSpec.prototype.maxDepth = 0;
        ProofSpec.prototype.minDepth = 0;
        ProofSpec.create = function create(properties) {
          return new ProofSpec(properties);
        };
        ProofSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            writer.uint32(24).int32(message.maxDepth);
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            writer.uint32(32).int32(message.minDepth);
          return writer;
        };
        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ProofSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 2:
                message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());
                break;
              case 3:
                message.maxDepth = reader.int32();
                break;
              case 4:
                message.minDepth = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ProofSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ProofSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec")) {
            var error = $root.ics23.LeafOp.verify(message.leafSpec);
            if (error)
              return "leafSpec." + error;
          }
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec")) {
            var error = $root.ics23.InnerSpec.verify(message.innerSpec);
            if (error)
              return "innerSpec." + error;
          }
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth")) {
            if (!$util.isInteger(message.maxDepth))
              return "maxDepth: integer expected";
          }
          if (message.minDepth != null && message.hasOwnProperty("minDepth")) {
            if (!$util.isInteger(message.minDepth))
              return "minDepth: integer expected";
          }
          return null;
        };
        ProofSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.ProofSpec)
            return object;
          var message = new $root.ics23.ProofSpec();
          if (object.leafSpec != null) {
            if (typeof object.leafSpec !== "object")
              throw TypeError(".ics23.ProofSpec.leafSpec: object expected");
            message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);
          }
          if (object.innerSpec != null) {
            if (typeof object.innerSpec !== "object")
              throw TypeError(".ics23.ProofSpec.innerSpec: object expected");
            message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);
          }
          if (object.maxDepth != null)
            message.maxDepth = object.maxDepth | 0;
          if (object.minDepth != null)
            message.minDepth = object.minDepth | 0;
          return message;
        };
        ProofSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.leafSpec = null;
            object.innerSpec = null;
            object.maxDepth = 0;
            object.minDepth = 0;
          }
          if (message.leafSpec != null && message.hasOwnProperty("leafSpec"))
            object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);
          if (message.innerSpec != null && message.hasOwnProperty("innerSpec"))
            object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);
          if (message.maxDepth != null && message.hasOwnProperty("maxDepth"))
            object.maxDepth = message.maxDepth;
          if (message.minDepth != null && message.hasOwnProperty("minDepth"))
            object.minDepth = message.minDepth;
          return object;
        };
        ProofSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return ProofSpec;
      }();
      ics23.InnerSpec = function() {
        function InnerSpec(properties) {
          this.childOrder = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        InnerSpec.prototype.childOrder = $util.emptyArray;
        InnerSpec.prototype.childSize = 0;
        InnerSpec.prototype.minPrefixLength = 0;
        InnerSpec.prototype.maxPrefixLength = 0;
        InnerSpec.prototype.emptyChild = $util.newBuffer([]);
        InnerSpec.prototype.hash = 0;
        InnerSpec.create = function create(properties) {
          return new InnerSpec(properties);
        };
        InnerSpec.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.childOrder != null && message.childOrder.length) {
            writer.uint32(10).fork();
            for (var i = 0; i < message.childOrder.length; ++i)
              writer.int32(message.childOrder[i]);
            writer.ldelim();
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            writer.uint32(16).int32(message.childSize);
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            writer.uint32(24).int32(message.minPrefixLength);
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            writer.uint32(32).int32(message.maxPrefixLength);
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            writer.uint32(42).bytes(message.emptyChild);
          if (message.hash != null && message.hasOwnProperty("hash"))
            writer.uint32(48).int32(message.hash);
          return writer;
        };
        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        InnerSpec.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.childOrder && message.childOrder.length))
                  message.childOrder = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.childOrder.push(reader.int32());
                } else
                  message.childOrder.push(reader.int32());
                break;
              case 2:
                message.childSize = reader.int32();
                break;
              case 3:
                message.minPrefixLength = reader.int32();
                break;
              case 4:
                message.maxPrefixLength = reader.int32();
                break;
              case 5:
                message.emptyChild = reader.bytes();
                break;
              case 6:
                message.hash = reader.int32();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        InnerSpec.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        InnerSpec.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.childOrder != null && message.hasOwnProperty("childOrder")) {
            if (!Array.isArray(message.childOrder))
              return "childOrder: array expected";
            for (var i = 0; i < message.childOrder.length; ++i)
              if (!$util.isInteger(message.childOrder[i]))
                return "childOrder: integer[] expected";
          }
          if (message.childSize != null && message.hasOwnProperty("childSize")) {
            if (!$util.isInteger(message.childSize))
              return "childSize: integer expected";
          }
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength")) {
            if (!$util.isInteger(message.minPrefixLength))
              return "minPrefixLength: integer expected";
          }
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength")) {
            if (!$util.isInteger(message.maxPrefixLength))
              return "maxPrefixLength: integer expected";
          }
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild")) {
            if (!(message.emptyChild && typeof message.emptyChild.length === "number" || $util.isString(message.emptyChild)))
              return "emptyChild: buffer expected";
          }
          if (message.hash != null && message.hasOwnProperty("hash"))
            switch (message.hash) {
              default:
                return "hash: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
                break;
            }
          return null;
        };
        InnerSpec.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.InnerSpec)
            return object;
          var message = new $root.ics23.InnerSpec();
          if (object.childOrder) {
            if (!Array.isArray(object.childOrder))
              throw TypeError(".ics23.InnerSpec.childOrder: array expected");
            message.childOrder = [];
            for (var i = 0; i < object.childOrder.length; ++i)
              message.childOrder[i] = object.childOrder[i] | 0;
          }
          if (object.childSize != null)
            message.childSize = object.childSize | 0;
          if (object.minPrefixLength != null)
            message.minPrefixLength = object.minPrefixLength | 0;
          if (object.maxPrefixLength != null)
            message.maxPrefixLength = object.maxPrefixLength | 0;
          if (object.emptyChild != null) {
            if (typeof object.emptyChild === "string")
              $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);
            else if (object.emptyChild.length)
              message.emptyChild = object.emptyChild;
          }
          switch (object.hash) {
            case "NO_HASH":
            case 0:
              message.hash = 0;
              break;
            case "SHA256":
            case 1:
              message.hash = 1;
              break;
            case "SHA512":
            case 2:
              message.hash = 2;
              break;
            case "KECCAK":
            case 3:
              message.hash = 3;
              break;
            case "RIPEMD160":
            case 4:
              message.hash = 4;
              break;
            case "BITCOIN":
            case 5:
              message.hash = 5;
              break;
            case "SHA512_256":
            case 6:
              message.hash = 6;
              break;
          }
          return message;
        };
        InnerSpec.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.childOrder = [];
          if (options.defaults) {
            object.childSize = 0;
            object.minPrefixLength = 0;
            object.maxPrefixLength = 0;
            if (options.bytes === String)
              object.emptyChild = "";
            else {
              object.emptyChild = [];
              if (options.bytes !== Array)
                object.emptyChild = $util.newBuffer(object.emptyChild);
            }
            object.hash = options.enums === String ? "NO_HASH" : 0;
          }
          if (message.childOrder && message.childOrder.length) {
            object.childOrder = [];
            for (var j = 0; j < message.childOrder.length; ++j)
              object.childOrder[j] = message.childOrder[j];
          }
          if (message.childSize != null && message.hasOwnProperty("childSize"))
            object.childSize = message.childSize;
          if (message.minPrefixLength != null && message.hasOwnProperty("minPrefixLength"))
            object.minPrefixLength = message.minPrefixLength;
          if (message.maxPrefixLength != null && message.hasOwnProperty("maxPrefixLength"))
            object.maxPrefixLength = message.maxPrefixLength;
          if (message.emptyChild != null && message.hasOwnProperty("emptyChild"))
            object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;
          if (message.hash != null && message.hasOwnProperty("hash"))
            object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;
          return object;
        };
        InnerSpec.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return InnerSpec;
      }();
      ics23.BatchProof = function() {
        function BatchProof(properties) {
          this.entries = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchProof.prototype.entries = $util.emptyArray;
        BatchProof.create = function create(properties) {
          return new BatchProof(properties);
        };
        BatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(10).fork()).ldelim();
          return writer;
        };
        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.BatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          return null;
        };
        BatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchProof)
            return object;
          var message = new $root.ics23.BatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.BatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.BatchProof.entries: object expected");
              message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);
            }
          }
          return message;
        };
        BatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.entries = [];
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);
          }
          return object;
        };
        BatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchProof;
      }();
      ics23.BatchEntry = function() {
        function BatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        BatchEntry.prototype.exist = null;
        BatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(BatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        BatchEntry.create = function create(properties) {
          return new BatchEntry(properties);
        };
        BatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
          return writer;
        };
        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        BatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        BatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        BatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.ExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.NonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        BatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.BatchEntry)
            return object;
          var message = new $root.ics23.BatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.BatchEntry.exist: object expected");
            message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.BatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        BatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        BatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return BatchEntry;
      }();
      ics23.CompressedBatchProof = function() {
        function CompressedBatchProof(properties) {
          this.entries = [];
          this.lookupInners = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchProof.prototype.entries = $util.emptyArray;
        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;
        CompressedBatchProof.create = function create(properties) {
          return new CompressedBatchProof(properties);
        };
        CompressedBatchProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.entries != null && message.entries.length)
            for (var i = 0; i < message.entries.length; ++i)
              $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(10).fork()).ldelim();
          if (message.lookupInners != null && message.lookupInners.length)
            for (var i = 0; i < message.lookupInners.length; ++i)
              $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(18).fork()).ldelim();
          return writer;
        };
        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                if (!(message.entries && message.entries.length))
                  message.entries = [];
                message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));
                break;
              case 2:
                if (!(message.lookupInners && message.lookupInners.length))
                  message.lookupInners = [];
                message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.entries != null && message.hasOwnProperty("entries")) {
            if (!Array.isArray(message.entries))
              return "entries: array expected";
            for (var i = 0; i < message.entries.length; ++i) {
              var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);
              if (error)
                return "entries." + error;
            }
          }
          if (message.lookupInners != null && message.hasOwnProperty("lookupInners")) {
            if (!Array.isArray(message.lookupInners))
              return "lookupInners: array expected";
            for (var i = 0; i < message.lookupInners.length; ++i) {
              var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);
              if (error)
                return "lookupInners." + error;
            }
          }
          return null;
        };
        CompressedBatchProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchProof)
            return object;
          var message = new $root.ics23.CompressedBatchProof();
          if (object.entries) {
            if (!Array.isArray(object.entries))
              throw TypeError(".ics23.CompressedBatchProof.entries: array expected");
            message.entries = [];
            for (var i = 0; i < object.entries.length; ++i) {
              if (typeof object.entries[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.entries: object expected");
              message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);
            }
          }
          if (object.lookupInners) {
            if (!Array.isArray(object.lookupInners))
              throw TypeError(".ics23.CompressedBatchProof.lookupInners: array expected");
            message.lookupInners = [];
            for (var i = 0; i < object.lookupInners.length; ++i) {
              if (typeof object.lookupInners[i] !== "object")
                throw TypeError(".ics23.CompressedBatchProof.lookupInners: object expected");
              message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);
            }
          }
          return message;
        };
        CompressedBatchProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.entries = [];
            object.lookupInners = [];
          }
          if (message.entries && message.entries.length) {
            object.entries = [];
            for (var j = 0; j < message.entries.length; ++j)
              object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);
          }
          if (message.lookupInners && message.lookupInners.length) {
            object.lookupInners = [];
            for (var j = 0; j < message.lookupInners.length; ++j)
              object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);
          }
          return object;
        };
        CompressedBatchProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchProof;
      }();
      ics23.CompressedBatchEntry = function() {
        function CompressedBatchEntry(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedBatchEntry.prototype.exist = null;
        CompressedBatchEntry.prototype.nonexist = null;
        var $oneOfFields;
        Object.defineProperty(CompressedBatchEntry.prototype, "proof", {
          get: $util.oneOfGetter($oneOfFields = ["exist", "nonexist"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        CompressedBatchEntry.create = function create(properties) {
          return new CompressedBatchEntry(properties);
        };
        CompressedBatchEntry.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.exist != null && message.hasOwnProperty("exist"))
            $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
          if (message.nonexist != null && message.hasOwnProperty("nonexist"))
            $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
          return writer;
        };
        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedBatchEntry.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 2:
                message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedBatchEntry.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedExistenceProof.verify(message.exist);
              if (error)
                return "exist." + error;
            }
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            if (properties.proof === 1)
              return "proof: multiple values";
            properties.proof = 1;
            {
              var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);
              if (error)
                return "nonexist." + error;
            }
          }
          return null;
        };
        CompressedBatchEntry.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedBatchEntry)
            return object;
          var message = new $root.ics23.CompressedBatchEntry();
          if (object.exist != null) {
            if (typeof object.exist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.exist: object expected");
            message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);
          }
          if (object.nonexist != null) {
            if (typeof object.nonexist !== "object")
              throw TypeError(".ics23.CompressedBatchEntry.nonexist: object expected");
            message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);
          }
          return message;
        };
        CompressedBatchEntry.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (message.exist != null && message.hasOwnProperty("exist")) {
            object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);
            if (options.oneofs)
              object.proof = "exist";
          }
          if (message.nonexist != null && message.hasOwnProperty("nonexist")) {
            object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);
            if (options.oneofs)
              object.proof = "nonexist";
          }
          return object;
        };
        CompressedBatchEntry.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedBatchEntry;
      }();
      ics23.CompressedExistenceProof = function() {
        function CompressedExistenceProof(properties) {
          this.path = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedExistenceProof.prototype.value = $util.newBuffer([]);
        CompressedExistenceProof.prototype.leaf = null;
        CompressedExistenceProof.prototype.path = $util.emptyArray;
        CompressedExistenceProof.create = function create(properties) {
          return new CompressedExistenceProof(properties);
        };
        CompressedExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(10).bytes(message.key);
          if (message.value != null && message.hasOwnProperty("value"))
            writer.uint32(18).bytes(message.value);
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            $root.ics23.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
          if (message.path != null && message.path.length) {
            writer.uint32(34).fork();
            for (var i = 0; i < message.path.length; ++i)
              writer.int32(message.path[i]);
            writer.ldelim();
          }
          return writer;
        };
        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.value = reader.bytes();
                break;
              case 3:
                message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());
                break;
              case 4:
                if (!(message.path && message.path.length))
                  message.path = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.path.push(reader.int32());
                } else
                  message.path.push(reader.int32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
              return "value: buffer expected";
          }
          if (message.leaf != null && message.hasOwnProperty("leaf")) {
            var error = $root.ics23.LeafOp.verify(message.leaf);
            if (error)
              return "leaf." + error;
          }
          if (message.path != null && message.hasOwnProperty("path")) {
            if (!Array.isArray(message.path))
              return "path: array expected";
            for (var i = 0; i < message.path.length; ++i)
              if (!$util.isInteger(message.path[i]))
                return "path: integer[] expected";
          }
          return null;
        };
        CompressedExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedExistenceProof)
            return object;
          var message = new $root.ics23.CompressedExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.value != null) {
            if (typeof object.value === "string")
              $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
            else if (object.value.length)
              message.value = object.value;
          }
          if (object.leaf != null) {
            if (typeof object.leaf !== "object")
              throw TypeError(".ics23.CompressedExistenceProof.leaf: object expected");
            message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);
          }
          if (object.path) {
            if (!Array.isArray(object.path))
              throw TypeError(".ics23.CompressedExistenceProof.path: array expected");
            message.path = [];
            for (var i = 0; i < object.path.length; ++i)
              message.path[i] = object.path[i] | 0;
          }
          return message;
        };
        CompressedExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.path = [];
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            if (options.bytes === String)
              object.value = "";
            else {
              object.value = [];
              if (options.bytes !== Array)
                object.value = $util.newBuffer(object.value);
            }
            object.leaf = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
          if (message.leaf != null && message.hasOwnProperty("leaf"))
            object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);
          if (message.path && message.path.length) {
            object.path = [];
            for (var j = 0; j < message.path.length; ++j)
              object.path[j] = message.path[j];
          }
          return object;
        };
        CompressedExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedExistenceProof;
      }();
      ics23.CompressedNonExistenceProof = function() {
        function CompressedNonExistenceProof(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);
        CompressedNonExistenceProof.prototype.left = null;
        CompressedNonExistenceProof.prototype.right = null;
        CompressedNonExistenceProof.create = function create(properties) {
          return new CompressedNonExistenceProof(properties);
        };
        CompressedNonExistenceProof.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && message.hasOwnProperty("key"))
            writer.uint32(10).bytes(message.key);
          if (message.left != null && message.hasOwnProperty("left"))
            $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
          if (message.right != null && message.hasOwnProperty("right"))
            $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
          return writer;
        };
        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        CompressedNonExistenceProof.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.key = reader.bytes();
                break;
              case 2:
                message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              case 3:
                message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        CompressedNonExistenceProof.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
              return "key: buffer expected";
          }
          if (message.left != null && message.hasOwnProperty("left")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.left);
            if (error)
              return "left." + error;
          }
          if (message.right != null && message.hasOwnProperty("right")) {
            var error = $root.ics23.CompressedExistenceProof.verify(message.right);
            if (error)
              return "right." + error;
          }
          return null;
        };
        CompressedNonExistenceProof.fromObject = function fromObject(object) {
          if (object instanceof $root.ics23.CompressedNonExistenceProof)
            return object;
          var message = new $root.ics23.CompressedNonExistenceProof();
          if (object.key != null) {
            if (typeof object.key === "string")
              $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
            else if (object.key.length)
              message.key = object.key;
          }
          if (object.left != null) {
            if (typeof object.left !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.left: object expected");
            message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);
          }
          if (object.right != null) {
            if (typeof object.right !== "object")
              throw TypeError(".ics23.CompressedNonExistenceProof.right: object expected");
            message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);
          }
          return message;
        };
        CompressedNonExistenceProof.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if (options.bytes === String)
              object.key = "";
            else {
              object.key = [];
              if (options.bytes !== Array)
                object.key = $util.newBuffer(object.key);
            }
            object.left = null;
            object.right = null;
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
          if (message.left != null && message.hasOwnProperty("left"))
            object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);
          if (message.right != null && message.hasOwnProperty("right"))
            object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);
          return object;
        };
        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return CompressedNonExistenceProof;
      }();
      return ics23;
    }();
    module.exports = $root;
  }
});

// node_modules/@confio/ics23/build/compress.js
var require_compress = __commonJS({
  "node_modules/@confio/ics23/build/compress.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decompress = exports.compress = void 0;
    var codecimpl_1 = require_codecimpl();
    function compress(proof) {
      if (!proof.batch) {
        return proof;
      }
      return { compressed: compressBatch(proof.batch) };
    }
    exports.compress = compress;
    function decompress(proof) {
      if (!proof.compressed) {
        return proof;
      }
      return { batch: decompressBatch(proof.compressed) };
    }
    exports.decompress = decompress;
    function compressBatch(proof) {
      const centries = [];
      const lookup = [];
      const registry = new Map();
      for (const entry of proof.entries) {
        if (entry.exist) {
          const centry = { exist: compressExist(entry.exist, lookup, registry) };
          centries.push(centry);
        } else if (entry.nonexist) {
          const non = entry.nonexist;
          const centry = {
            nonexist: {
              key: non.key,
              left: compressExist(non.left, lookup, registry),
              right: compressExist(non.right, lookup, registry)
            }
          };
          centries.push(centry);
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      }
      return {
        entries: centries,
        lookupInners: lookup
      };
    }
    function compressExist(exist, lookup, registry) {
      if (!exist) {
        return void 0;
      }
      const path = exist.path.map((inner) => {
        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();
        let idx = registry.get(sig);
        if (idx === void 0) {
          idx = lookup.length;
          lookup.push(inner);
          registry.set(sig, idx);
        }
        return idx;
      });
      return {
        key: exist.key,
        value: exist.value,
        leaf: exist.leaf,
        path
      };
    }
    function decompressBatch(proof) {
      const lookup = proof.lookupInners;
      const entries = proof.entries.map((comp) => {
        if (comp.exist) {
          return { exist: decompressExist(comp.exist, lookup) };
        } else if (comp.nonexist) {
          const non = comp.nonexist;
          return {
            nonexist: {
              key: non.key,
              left: decompressExist(non.left, lookup),
              right: decompressExist(non.right, lookup)
            }
          };
        } else {
          throw new Error("Unexpected batch entry during compress");
        }
      });
      return {
        entries
      };
    }
    function decompressExist(exist, lookup) {
      if (!exist) {
        return void 0;
      }
      const { key, value, leaf, path } = exist;
      const newPath = (path || []).map((idx) => lookup[idx]);
      return { key, value, leaf, path: newPath };
    }
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = {
      number,
      bool,
      bytes,
      hash,
      exists,
      output
    };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(uint8a) {
      if (!(uint8a instanceof Uint8Array))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string") {
        throw new TypeError("hexToBytes: expected string, got " + typeof hex);
      }
      if (hex.length % 2)
        throw new Error("hexToBytes: received invalid unpadded hex");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string") {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
      }
      return new TextEncoder().encode(str);
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error("Uint8Array list expected");
      if (arrays.length === 1)
        return arrays[0];
      const length = arrays.reduce((a, arr) => a + arr.length, 0);
      const result = new Uint8Array(length);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
        throw new TypeError("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashConstructor) {
      const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
      const tmp = hashConstructor();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashConstructor();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/_sha2.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/@noble/hashes/ripemd160.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
    var Pi = Id.map((i) => (9 * i + 5) % 16);
    var idxL = [Id];
    var idxR = [Pi];
    for (let i = 0; i < 4; i++)
      for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
    var shifts = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => new Uint8Array(i));
    var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
    var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
    var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
    var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
    var rotl = (word, shift) => word << shift | word >>> 32 - shift;
    function f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      else if (group === 1)
        return x & y | ~x & z;
      else if (group === 2)
        return (x | ~y) ^ z;
      else if (group === 3)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    var BUF = new Uint32Array(16);
    var RIPEMD160 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          BUF[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i = 0; i < 16; i++) {
            const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, l, s) => h >>> s;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    var rotr32H = (h, l) => l;
    var rotr32L = (h, l) => h;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    var u64 = {
      fromBig,
      split,
      toBig: exports.toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@noble/hashes/sha512.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _sha2_js_1 = require_sha2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n)));
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
  }
});

// node_modules/@confio/ics23/build/ops.js
var require_ops = __commonJS({
  "node_modules/@confio/ics23/build/ops.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.doHash = exports.applyInner = exports.applyLeaf = void 0;
    var ripemd160_1 = require_ripemd160();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var codecimpl_1 = require_codecimpl();
    function applyLeaf(leaf, key, value) {
      if (key.length === 0) {
        throw new Error("Missing key");
      }
      if (value.length === 0) {
        throw new Error("Missing value");
      }
      const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);
      const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);
      const data = new Uint8Array([
        ...ensureBytes(leaf.prefix),
        ...pkey,
        ...pvalue
      ]);
      return doHash(ensureHash(leaf.hash), data);
    }
    exports.applyLeaf = applyLeaf;
    function applyInner(inner, child) {
      if (child.length === 0) {
        throw new Error("Inner op needs child value");
      }
      const preimage = new Uint8Array([
        ...ensureBytes(inner.prefix),
        ...child,
        ...ensureBytes(inner.suffix)
      ]);
      return doHash(ensureHash(inner.hash), preimage);
    }
    exports.applyInner = applyInner;
    function ensure(maybe, value) {
      return maybe === void 0 || maybe === null ? value : maybe;
    }
    var ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);
    var ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);
    var ensureBytes = (b) => ensure(b, new Uint8Array([]));
    function prepareLeafData(hashOp, lengthOp, data) {
      const h = doHashOrNoop(hashOp, data);
      return doLengthOp(lengthOp, h);
    }
    function doHashOrNoop(hashOp, preimage) {
      if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {
        return preimage;
      }
      return doHash(hashOp, preimage);
    }
    function doHash(hashOp, preimage) {
      switch (hashOp) {
        case codecimpl_1.ics23.HashOp.SHA256:
          return (0, sha256_1.sha256)(preimage);
        case codecimpl_1.ics23.HashOp.SHA512:
          return (0, sha512_1.sha512)(preimage);
        case codecimpl_1.ics23.HashOp.RIPEMD160:
          return (0, ripemd160_1.ripemd160)(preimage);
        case codecimpl_1.ics23.HashOp.BITCOIN:
          return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));
        case codecimpl_1.ics23.HashOp.SHA512_256:
          return (0, sha512_1.sha512_256)(preimage);
      }
      throw new Error(`Unsupported hashop: ${hashOp}`);
    }
    exports.doHash = doHash;
    function doLengthOp(lengthOp, data) {
      switch (lengthOp) {
        case codecimpl_1.ics23.LengthOp.NO_PREFIX:
          return data;
        case codecimpl_1.ics23.LengthOp.VAR_PROTO:
          return new Uint8Array([...encodeVarintProto(data.length), ...data]);
        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:
          if (data.length !== 32) {
            throw new Error(`Length is ${data.length}, not 32 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:
          if (data.length !== 64) {
            throw new Error(`Length is ${data.length}, not 64 bytes`);
          }
          return data;
        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:
          return new Uint8Array([...encodeFixed32Le(data.length), ...data]);
      }
      throw new Error(`Unsupported lengthop: ${lengthOp}`);
    }
    function encodeVarintProto(n) {
      let enc = [];
      let l = n;
      while (l >= 128) {
        const b = l % 128 + 128;
        enc = [...enc, b];
        l = l / 128;
      }
      enc = [...enc, l];
      return new Uint8Array(enc);
    }
    function encodeFixed32Le(n) {
      const enc = new Uint8Array(4);
      let l = n;
      for (let i = enc.length; i > 0; i--) {
        enc[Math.abs(i - enc.length)] = l % 256;
        l = Math.floor(l / 256);
      }
      return enc;
    }
  }
});

// node_modules/@confio/ics23/build/specs.js
var require_specs = __commonJS({
  "node_modules/@confio/ics23/build/specs.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesBefore = exports.ensureBytesBefore = exports.bytesEqual = exports.ensureBytesEqual = exports.ensureInner = exports.ensureLeaf = void 0;
    function ensureLeaf(leaf, spec) {
      if (leaf.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${leaf.hash}`);
      }
      if (leaf.prehashKey !== spec.prehashKey) {
        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);
      }
      if (leaf.prehashValue !== spec.prehashValue) {
        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);
      }
      if (leaf.length !== spec.length) {
        throw new Error(`Unexpected length op: ${leaf.length}`);
      }
      ensurePrefix(leaf.prefix, spec.prefix);
    }
    exports.ensureLeaf = ensureLeaf;
    function ensureInner(inner, prefix, spec) {
      if (inner.hash !== spec.hash) {
        throw new Error(`Unexpected hashOp: ${inner.hash}`);
      }
      if (!inner.prefix) {
        throw new Error("No prefix set for inner node");
      }
      if (hasPrefix(inner.prefix, prefix)) {
        throw new Error(`Inner node has leaf prefix`);
      }
      if (inner.prefix.length < (spec.minPrefixLength || 0)) {
        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);
      }
      const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;
      if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {
        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);
      }
    }
    exports.ensureInner = ensureInner;
    function ensurePrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return;
      }
      if (!check) {
        throw new Error(`Target bytes missing`);
      }
      ensureBytesEqual(prefix, check.slice(0, prefix.length));
    }
    function ensureBytesEqual(a, b) {
      if (a.length !== b.length) {
        throw new Error(`Different lengths ${a.length} vs ${b.length}`);
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);
        }
      }
    }
    exports.ensureBytesEqual = ensureBytesEqual;
    function bytesEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports.bytesEqual = bytesEqual;
    function hasPrefix(check, prefix) {
      if (!prefix || prefix.length === 0) {
        return false;
      }
      if (!check) {
        return false;
      }
      if (check.length <= prefix.length) {
        return false;
      }
      for (let i = 0; i < prefix.length; i++) {
        if (check[i] !== prefix[i]) {
          return false;
        }
      }
      throw true;
    }
    function ensureBytesBefore(first, last) {
      if (!bytesBefore(first, last)) {
        throw new Error("first is after last");
      }
    }
    exports.ensureBytesBefore = ensureBytesBefore;
    function bytesBefore(first, last) {
      const min = first.length < last.length ? first.length : last.length;
      for (let i = 0; i < min; i++) {
        if (first[i] < last[i]) {
          return true;
        }
        if (first[i] > last[i]) {
          return false;
        }
      }
      return first.length < last.length;
    }
    exports.bytesBefore = bytesBefore;
  }
});

// node_modules/@confio/ics23/build/proofs.js
var require_proofs = __commonJS({
  "node_modules/@confio/ics23/build/proofs.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;
    var codecimpl_1 = require_codecimpl();
    var ops_1 = require_ops();
    var specs_1 = require_specs();
    exports.iavlSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 4,
        maxPrefixLength: 12,
        childSize: 33,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports.tendermintSpec = {
      leafSpec: {
        prefix: Uint8Array.from([0]),
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        length: codecimpl_1.ics23.LengthOp.VAR_PROTO
      },
      innerSpec: {
        childOrder: [0, 1],
        minPrefixLength: 1,
        maxPrefixLength: 1,
        childSize: 32,
        hash: codecimpl_1.ics23.HashOp.SHA256
      }
    };
    exports.smtSpec = {
      leafSpec: {
        hash: codecimpl_1.ics23.HashOp.SHA256,
        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,
        prehashValue: codecimpl_1.ics23.HashOp.SHA256,
        length: codecimpl_1.ics23.LengthOp.NO_PREFIX,
        prefix: Uint8Array.from([0])
      },
      innerSpec: {
        childOrder: [0, 1],
        childSize: 32,
        minPrefixLength: 1,
        maxPrefixLength: 1,
        emptyChild: new Uint8Array(32),
        hash: codecimpl_1.ics23.HashOp.SHA256
      },
      maxDepth: 256
    };
    function verifyExistence(proof, spec, root, key, value) {
      ensureSpec(proof, spec);
      const calc = calculateExistenceRoot(proof);
      (0, specs_1.ensureBytesEqual)(calc, root);
      (0, specs_1.ensureBytesEqual)(key, proof.key);
      (0, specs_1.ensureBytesEqual)(value, proof.value);
    }
    exports.verifyExistence = verifyExistence;
    function verifyNonExistence(proof, spec, root, key) {
      let leftKey;
      let rightKey;
      if (proof.left) {
        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);
        leftKey = proof.left.key;
      }
      if (proof.right) {
        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);
        rightKey = proof.right.key;
      }
      if (!leftKey && !rightKey) {
        throw new Error("neither left nor right proof defined");
      }
      if (leftKey) {
        (0, specs_1.ensureBytesBefore)(leftKey, key);
      }
      if (rightKey) {
        (0, specs_1.ensureBytesBefore)(key, rightKey);
      }
      if (!spec.innerSpec) {
        throw new Error("no inner spec");
      }
      if (!leftKey) {
        ensureLeftMost(spec.innerSpec, proof.right.path);
      } else if (!rightKey) {
        ensureRightMost(spec.innerSpec, proof.left.path);
      } else {
        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);
      }
      return;
    }
    exports.verifyNonExistence = verifyNonExistence;
    function calculateExistenceRoot(proof) {
      if (!proof.key || !proof.value) {
        throw new Error("Existence proof needs key and value set");
      }
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      const path = proof.path || [];
      let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);
      for (const inner of path) {
        res = (0, ops_1.applyInner)(inner, res);
      }
      return res;
    }
    exports.calculateExistenceRoot = calculateExistenceRoot;
    function ensureSpec(proof, spec) {
      if (!proof.leaf) {
        throw new Error("Existence proof must start with a leaf operation");
      }
      if (!spec.leafSpec) {
        throw new Error("Spec must include leafSpec");
      }
      if (!spec.innerSpec) {
        throw new Error("Spec must include innerSpec");
      }
      (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);
      const path = proof.path || [];
      if (spec.minDepth && path.length < spec.minDepth) {
        throw new Error(`Too few inner nodes ${path.length}`);
      }
      if (spec.maxDepth && path.length > spec.maxDepth) {
        throw new Error(`Too many inner nodes ${path.length}`);
      }
      for (const inner of path) {
        (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);
      }
    }
    exports.ensureSpec = ensureSpec;
    function ensureLeftMost(spec, path) {
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureRightMost(spec, path) {
      const len = spec.childOrder.length - 1;
      const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);
      for (const step of path) {
        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {
          throw new Error("Step not leftmost");
        }
      }
    }
    function ensureLeftNeighbor(spec, left, right) {
      const mutleft = [...left];
      const mutright = [...right];
      let topleft = mutleft.pop();
      let topright = mutright.pop();
      while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) && (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {
        topleft = mutleft.pop();
        topright = mutright.pop();
      }
      if (!isLeftStep(spec, topleft, topright)) {
        throw new Error(`Not left neightbor at first divergent step`);
      }
      ensureRightMost(spec, mutleft);
      ensureLeftMost(spec, mutright);
    }
    exports.ensureLeftNeighbor = ensureLeftNeighbor;
    function isLeftStep(spec, left, right) {
      const leftidx = orderFromPadding(spec, left);
      const rightidx = orderFromPadding(spec, right);
      return rightidx === leftidx + 1;
    }
    function orderFromPadding(spec, inner) {
      for (let branch = 0; branch < spec.childOrder.length; branch++) {
        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);
        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {
          return branch;
        }
      }
      throw new Error(`Cannot find any valid spacing for this node`);
    }
    function hasPadding(op, minPrefix, maxPrefix, suffix) {
      if ((op.prefix || []).length < minPrefix) {
        return false;
      }
      if ((op.prefix || []).length > maxPrefix) {
        return false;
      }
      return (op.suffix || []).length === suffix;
    }
    function getPadding(spec, branch) {
      const idx = getPosition(spec.childOrder, branch);
      const prefix = idx * spec.childSize;
      const minPrefix = prefix + spec.minPrefixLength;
      const maxPrefix = prefix + spec.maxPrefixLength;
      const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;
      return { minPrefix, maxPrefix, suffix };
    }
    function getPosition(order, branch) {
      if (branch < 0 || branch >= order.length) {
        throw new Error(`Invalid branch: ${branch}`);
      }
      return order.findIndex((val) => val === branch);
    }
  }
});

// node_modules/@confio/ics23/build/ics23.js
var require_ics23 = __commonJS({
  "node_modules/@confio/ics23/build/ics23.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.batchVerifyNonMembership = exports.batchVerifyMembership = exports.verifyNonMembership = exports.verifyMembership = void 0;
    var compress_1 = require_compress();
    var proofs_1 = require_proofs();
    var specs_1 = require_specs();
    function verifyMembership(proof, spec, root, key, value) {
      const norm = (0, compress_1.decompress)(proof);
      const exist = getExistForKey(norm, key);
      if (!exist) {
        return false;
      }
      try {
        (0, proofs_1.verifyExistence)(exist, spec, root, key, value);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports.verifyMembership = verifyMembership;
    function verifyNonMembership(proof, spec, root, key) {
      const norm = (0, compress_1.decompress)(proof);
      const nonexist = getNonExistForKey(norm, key);
      if (!nonexist) {
        return false;
      }
      try {
        (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);
        return true;
      } catch (_a) {
        return false;
      }
    }
    exports.verifyNonMembership = verifyNonMembership;
    function batchVerifyMembership(proof, spec, root, items) {
      const norm = (0, compress_1.decompress)(proof);
      for (const [key, value] of items.entries()) {
        if (!verifyMembership(norm, spec, root, key, value)) {
          return false;
        }
      }
      return true;
    }
    exports.batchVerifyMembership = batchVerifyMembership;
    function batchVerifyNonMembership(proof, spec, root, keys) {
      const norm = (0, compress_1.decompress)(proof);
      for (const key of keys) {
        if (!verifyNonMembership(norm, spec, root, key)) {
          return false;
        }
      }
      return true;
    }
    exports.batchVerifyNonMembership = batchVerifyNonMembership;
    function getExistForKey(proof, key) {
      const match = (p) => !!p && (0, specs_1.bytesEqual)(key, p.key);
      if (match(proof.exist)) {
        return proof.exist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.exist || null).find(match);
      }
      return void 0;
    }
    function getNonExistForKey(proof, key) {
      const match = (p) => {
        return !!p && (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) && (!p.right || (0, specs_1.bytesBefore)(key, p.right.key));
      };
      if (match(proof.nonexist)) {
        return proof.nonexist;
      } else if (proof.batch) {
        return proof.batch.entries.map((x) => x.nonexist || null).find(match);
      }
      return void 0;
    }
  }
});

// node_modules/@confio/ics23/build/index.js
var require_build7 = __commonJS({
  "node_modules/@confio/ics23/build/index.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyNonExistence = exports.verifyExistence = exports.tendermintSpec = exports.iavlSpec = exports.calculateExistenceRoot = exports.verifyNonMembership = exports.verifyMembership = exports.ics23 = void 0;
    var codecimpl_1 = require_codecimpl();
    Object.defineProperty(exports, "ics23", { enumerable: true, get: function() {
      return codecimpl_1.ics23;
    } });
    var ics23_1 = require_ics23();
    Object.defineProperty(exports, "verifyMembership", { enumerable: true, get: function() {
      return ics23_1.verifyMembership;
    } });
    Object.defineProperty(exports, "verifyNonMembership", { enumerable: true, get: function() {
      return ics23_1.verifyNonMembership;
    } });
    var proofs_1 = require_proofs();
    Object.defineProperty(exports, "calculateExistenceRoot", { enumerable: true, get: function() {
      return proofs_1.calculateExistenceRoot;
    } });
    Object.defineProperty(exports, "iavlSpec", { enumerable: true, get: function() {
      return proofs_1.iavlSpec;
    } });
    Object.defineProperty(exports, "tendermintSpec", { enumerable: true, get: function() {
      return proofs_1.tendermintSpec;
    } });
    Object.defineProperty(exports, "verifyExistence", { enumerable: true, get: function() {
      return proofs_1.verifyExistence;
    } });
    Object.defineProperty(exports, "verifyNonExistence", { enumerable: true, get: function() {
      return proofs_1.verifyNonExistence;
    } });
  }
});

// node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/symbol-observable/lib/ponyfill.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          try {
            _Symbol.observable = result;
          } catch (err) {
          }
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// node_modules/symbol-observable/ponyfill.js
var require_ponyfill2 = __commonJS({
  "node_modules/symbol-observable/ponyfill.js"(exports, module) {
    init_define_global();
    module.exports = require_ponyfill();
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    init_define_global();
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    init_define_global();
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    init_define_global();
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    init_define_global();
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var arePropertyDescriptorsSupported = function() {
      var obj = {};
      try {
        origDefineProperty(obj, "x", { enumerable: false, value: obj });
        for (var _ in obj) {
          return false;
        }
        return obj.x === obj;
      } catch (e) {
        return false;
      }
    };
    var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object && (!isFunction(predicate) || !predicate())) {
        return;
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/globalthis/implementation.browser.js"(exports, module) {
    init_define_global();
    "use strict";
    if (typeof self !== "undefined") {
      module.exports = self;
    } else if (typeof window !== "undefined") {
      module.exports = window;
    } else {
      module.exports = Function("return this")();
    }
  }
});

// node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/globalthis/polyfill.js"(exports, module) {
    init_define_global();
    "use strict";
    var implementation = require_implementation_browser();
    module.exports = function getPolyfill() {
      if (typeof define_global_default !== "object" || !define_global_default || define_global_default.Math !== Math || define_global_default.Array !== Array) {
        return implementation;
      }
      return define_global_default;
    };
  }
});

// node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "node_modules/globalthis/shim.js"(exports, module) {
    init_define_global();
    "use strict";
    var define = require_define_properties();
    var getPolyfill = require_polyfill();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define.supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: false
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "node_modules/globalthis/index.js"(exports, module) {
    init_define_global();
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation_browser();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal = function() {
      return polyfill;
    };
    defineProperties(getGlobal, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = getGlobal;
  }
});

// node_modules/xstream/index.js
var require_xstream = __commonJS({
  "node_modules/xstream/index.js"(exports) {
    init_define_global();
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NO_IL = exports.NO = exports.MemoryStream = exports.Stream = void 0;
    var ponyfill_1 = require_ponyfill2();
    var globalthis_1 = require_globalthis();
    var $$observable = ponyfill_1.default(globalthis_1.getPolyfill());
    var NO = {};
    exports.NO = NO;
    function noop() {
    }
    function cp(a) {
      var l = a.length;
      var b = Array(l);
      for (var i = 0; i < l; ++i)
        b[i] = a[i];
      return b;
    }
    function and(f1, f2) {
      return function andFn(t) {
        return f1(t) && f2(t);
      };
    }
    function _try(c, t, u) {
      try {
        return c.f(t);
      } catch (e) {
        u._e(e);
        return NO;
      }
    }
    var NO_IL = {
      _n: noop,
      _e: noop,
      _c: noop
    };
    exports.NO_IL = NO_IL;
    function internalizeProducer(producer) {
      producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
      };
      producer._stop = producer.stop;
    }
    var StreamSub = function() {
      function StreamSub2(_stream, _listener) {
        this._stream = _stream;
        this._listener = _listener;
      }
      StreamSub2.prototype.unsubscribe = function() {
        this._stream._remove(this._listener);
      };
      return StreamSub2;
    }();
    var Observer = function() {
      function Observer2(_listener) {
        this._listener = _listener;
      }
      Observer2.prototype.next = function(value) {
        this._listener._n(value);
      };
      Observer2.prototype.error = function(err) {
        this._listener._e(err);
      };
      Observer2.prototype.complete = function() {
        this._listener._c();
      };
      return Observer2;
    }();
    var FromObservable = function() {
      function FromObservable2(observable) {
        this.type = "fromObservable";
        this.ins = observable;
        this.active = false;
      }
      FromObservable2.prototype._start = function(out) {
        this.out = out;
        this.active = true;
        this._sub = this.ins.subscribe(new Observer(out));
        if (!this.active)
          this._sub.unsubscribe();
      };
      FromObservable2.prototype._stop = function() {
        if (this._sub)
          this._sub.unsubscribe();
        this.active = false;
      };
      return FromObservable2;
    }();
    var Merge = function() {
      function Merge2(insArr) {
        this.type = "merge";
        this.insArr = insArr;
        this.out = NO;
        this.ac = 0;
      }
      Merge2.prototype._start = function(out) {
        this.out = out;
        var s = this.insArr;
        var L = s.length;
        this.ac = L;
        for (var i = 0; i < L; i++)
          s[i]._add(this);
      };
      Merge2.prototype._stop = function() {
        var s = this.insArr;
        var L = s.length;
        for (var i = 0; i < L; i++)
          s[i]._remove(this);
        this.out = NO;
      };
      Merge2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        u._n(t);
      };
      Merge2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      Merge2.prototype._c = function() {
        if (--this.ac <= 0) {
          var u = this.out;
          if (u === NO)
            return;
          u._c();
        }
      };
      return Merge2;
    }();
    var CombineListener = function() {
      function CombineListener2(i, out, p) {
        this.i = i;
        this.out = out;
        this.p = p;
        p.ils.push(this);
      }
      CombineListener2.prototype._n = function(t) {
        var p = this.p, out = this.out;
        if (out === NO)
          return;
        if (p.up(t, this.i)) {
          var b = cp(p.vals);
          out._n(b);
        }
      };
      CombineListener2.prototype._e = function(err) {
        var out = this.out;
        if (out === NO)
          return;
        out._e(err);
      };
      CombineListener2.prototype._c = function() {
        var p = this.p;
        if (p.out === NO)
          return;
        if (--p.Nc === 0)
          p.out._c();
      };
      return CombineListener2;
    }();
    var Combine = function() {
      function Combine2(insArr) {
        this.type = "combine";
        this.insArr = insArr;
        this.out = NO;
        this.ils = [];
        this.Nc = this.Nn = 0;
        this.vals = [];
      }
      Combine2.prototype.up = function(t, i) {
        var v = this.vals[i];
        var Nn = !this.Nn ? 0 : v === NO ? --this.Nn : this.Nn;
        this.vals[i] = t;
        return Nn === 0;
      };
      Combine2.prototype._start = function(out) {
        this.out = out;
        var s = this.insArr;
        var n = this.Nc = this.Nn = s.length;
        var vals = this.vals = new Array(n);
        if (n === 0) {
          out._n([]);
          out._c();
        } else {
          for (var i = 0; i < n; i++) {
            vals[i] = NO;
            s[i]._add(new CombineListener(i, out, this));
          }
        }
      };
      Combine2.prototype._stop = function() {
        var s = this.insArr;
        var n = s.length;
        var ils = this.ils;
        for (var i = 0; i < n; i++)
          s[i]._remove(ils[i]);
        this.out = NO;
        this.ils = [];
        this.vals = [];
      };
      return Combine2;
    }();
    var FromArray = function() {
      function FromArray2(a) {
        this.type = "fromArray";
        this.a = a;
      }
      FromArray2.prototype._start = function(out) {
        var a = this.a;
        for (var i = 0, n = a.length; i < n; i++)
          out._n(a[i]);
        out._c();
      };
      FromArray2.prototype._stop = function() {
      };
      return FromArray2;
    }();
    var FromPromise = function() {
      function FromPromise2(p) {
        this.type = "fromPromise";
        this.on = false;
        this.p = p;
      }
      FromPromise2.prototype._start = function(out) {
        var prod = this;
        this.on = true;
        this.p.then(function(v) {
          if (prod.on) {
            out._n(v);
            out._c();
          }
        }, function(e) {
          out._e(e);
        }).then(noop, function(err) {
          setTimeout(function() {
            throw err;
          });
        });
      };
      FromPromise2.prototype._stop = function() {
        this.on = false;
      };
      return FromPromise2;
    }();
    var Periodic = function() {
      function Periodic2(period) {
        this.type = "periodic";
        this.period = period;
        this.intervalID = -1;
        this.i = 0;
      }
      Periodic2.prototype._start = function(out) {
        var self2 = this;
        function intervalHandler() {
          out._n(self2.i++);
        }
        this.intervalID = setInterval(intervalHandler, this.period);
      };
      Periodic2.prototype._stop = function() {
        if (this.intervalID !== -1)
          clearInterval(this.intervalID);
        this.intervalID = -1;
        this.i = 0;
      };
      return Periodic2;
    }();
    var Debug = function() {
      function Debug2(ins, arg) {
        this.type = "debug";
        this.ins = ins;
        this.out = NO;
        this.s = noop;
        this.l = "";
        if (typeof arg === "string")
          this.l = arg;
        else if (typeof arg === "function")
          this.s = arg;
      }
      Debug2.prototype._start = function(out) {
        this.out = out;
        this.ins._add(this);
      };
      Debug2.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
      };
      Debug2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        var s = this.s, l = this.l;
        if (s !== noop) {
          try {
            s(t);
          } catch (e) {
            u._e(e);
          }
        } else if (l)
          console.log(l + ":", t);
        else
          console.log(t);
        u._n(t);
      };
      Debug2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      Debug2.prototype._c = function() {
        var u = this.out;
        if (u === NO)
          return;
        u._c();
      };
      return Debug2;
    }();
    var Drop = function() {
      function Drop2(max, ins) {
        this.type = "drop";
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.dropped = 0;
      }
      Drop2.prototype._start = function(out) {
        this.out = out;
        this.dropped = 0;
        this.ins._add(this);
      };
      Drop2.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
      };
      Drop2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        if (this.dropped++ >= this.max)
          u._n(t);
      };
      Drop2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      Drop2.prototype._c = function() {
        var u = this.out;
        if (u === NO)
          return;
        u._c();
      };
      return Drop2;
    }();
    var EndWhenListener = function() {
      function EndWhenListener2(out, op) {
        this.out = out;
        this.op = op;
      }
      EndWhenListener2.prototype._n = function() {
        this.op.end();
      };
      EndWhenListener2.prototype._e = function(err) {
        this.out._e(err);
      };
      EndWhenListener2.prototype._c = function() {
        this.op.end();
      };
      return EndWhenListener2;
    }();
    var EndWhen = function() {
      function EndWhen2(o, ins) {
        this.type = "endWhen";
        this.ins = ins;
        this.out = NO;
        this.o = o;
        this.oil = NO_IL;
      }
      EndWhen2.prototype._start = function(out) {
        this.out = out;
        this.o._add(this.oil = new EndWhenListener(out, this));
        this.ins._add(this);
      };
      EndWhen2.prototype._stop = function() {
        this.ins._remove(this);
        this.o._remove(this.oil);
        this.out = NO;
        this.oil = NO_IL;
      };
      EndWhen2.prototype.end = function() {
        var u = this.out;
        if (u === NO)
          return;
        u._c();
      };
      EndWhen2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        u._n(t);
      };
      EndWhen2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      EndWhen2.prototype._c = function() {
        this.end();
      };
      return EndWhen2;
    }();
    var Filter = function() {
      function Filter2(passes, ins) {
        this.type = "filter";
        this.ins = ins;
        this.out = NO;
        this.f = passes;
      }
      Filter2.prototype._start = function(out) {
        this.out = out;
        this.ins._add(this);
      };
      Filter2.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
      };
      Filter2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        var r = _try(this, t, u);
        if (r === NO || !r)
          return;
        u._n(t);
      };
      Filter2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      Filter2.prototype._c = function() {
        var u = this.out;
        if (u === NO)
          return;
        u._c();
      };
      return Filter2;
    }();
    var FlattenListener = function() {
      function FlattenListener2(out, op) {
        this.out = out;
        this.op = op;
      }
      FlattenListener2.prototype._n = function(t) {
        this.out._n(t);
      };
      FlattenListener2.prototype._e = function(err) {
        this.out._e(err);
      };
      FlattenListener2.prototype._c = function() {
        this.op.inner = NO;
        this.op.less();
      };
      return FlattenListener2;
    }();
    var Flatten = function() {
      function Flatten2(ins) {
        this.type = "flatten";
        this.ins = ins;
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
      }
      Flatten2.prototype._start = function(out) {
        this.out = out;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
        this.ins._add(this);
      };
      Flatten2.prototype._stop = function() {
        this.ins._remove(this);
        if (this.inner !== NO)
          this.inner._remove(this.il);
        this.out = NO;
        this.open = true;
        this.inner = NO;
        this.il = NO_IL;
      };
      Flatten2.prototype.less = function() {
        var u = this.out;
        if (u === NO)
          return;
        if (!this.open && this.inner === NO)
          u._c();
      };
      Flatten2.prototype._n = function(s) {
        var u = this.out;
        if (u === NO)
          return;
        var _a = this, inner = _a.inner, il = _a.il;
        if (inner !== NO && il !== NO_IL)
          inner._remove(il);
        (this.inner = s)._add(this.il = new FlattenListener(u, this));
      };
      Flatten2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      Flatten2.prototype._c = function() {
        this.open = false;
        this.less();
      };
      return Flatten2;
    }();
    var Fold = function() {
      function Fold2(f, seed, ins) {
        var _this = this;
        this.type = "fold";
        this.ins = ins;
        this.out = NO;
        this.f = function(t) {
          return f(_this.acc, t);
        };
        this.acc = this.seed = seed;
      }
      Fold2.prototype._start = function(out) {
        this.out = out;
        this.acc = this.seed;
        out._n(this.acc);
        this.ins._add(this);
      };
      Fold2.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
        this.acc = this.seed;
      };
      Fold2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        var r = _try(this, t, u);
        if (r === NO)
          return;
        u._n(this.acc = r);
      };
      Fold2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      Fold2.prototype._c = function() {
        var u = this.out;
        if (u === NO)
          return;
        u._c();
      };
      return Fold2;
    }();
    var Last = function() {
      function Last2(ins) {
        this.type = "last";
        this.ins = ins;
        this.out = NO;
        this.has = false;
        this.val = NO;
      }
      Last2.prototype._start = function(out) {
        this.out = out;
        this.has = false;
        this.ins._add(this);
      };
      Last2.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
        this.val = NO;
      };
      Last2.prototype._n = function(t) {
        this.has = true;
        this.val = t;
      };
      Last2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      Last2.prototype._c = function() {
        var u = this.out;
        if (u === NO)
          return;
        if (this.has) {
          u._n(this.val);
          u._c();
        } else
          u._e(new Error("last() failed because input stream completed"));
      };
      return Last2;
    }();
    var MapOp = function() {
      function MapOp2(project, ins) {
        this.type = "map";
        this.ins = ins;
        this.out = NO;
        this.f = project;
      }
      MapOp2.prototype._start = function(out) {
        this.out = out;
        this.ins._add(this);
      };
      MapOp2.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
      };
      MapOp2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        var r = _try(this, t, u);
        if (r === NO)
          return;
        u._n(r);
      };
      MapOp2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      MapOp2.prototype._c = function() {
        var u = this.out;
        if (u === NO)
          return;
        u._c();
      };
      return MapOp2;
    }();
    var Remember = function() {
      function Remember2(ins) {
        this.type = "remember";
        this.ins = ins;
        this.out = NO;
      }
      Remember2.prototype._start = function(out) {
        this.out = out;
        this.ins._add(out);
      };
      Remember2.prototype._stop = function() {
        this.ins._remove(this.out);
        this.out = NO;
      };
      return Remember2;
    }();
    var ReplaceError = function() {
      function ReplaceError2(replacer, ins) {
        this.type = "replaceError";
        this.ins = ins;
        this.out = NO;
        this.f = replacer;
      }
      ReplaceError2.prototype._start = function(out) {
        this.out = out;
        this.ins._add(this);
      };
      ReplaceError2.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
      };
      ReplaceError2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        u._n(t);
      };
      ReplaceError2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        try {
          this.ins._remove(this);
          (this.ins = this.f(err))._add(this);
        } catch (e) {
          u._e(e);
        }
      };
      ReplaceError2.prototype._c = function() {
        var u = this.out;
        if (u === NO)
          return;
        u._c();
      };
      return ReplaceError2;
    }();
    var StartWith = function() {
      function StartWith2(ins, val) {
        this.type = "startWith";
        this.ins = ins;
        this.out = NO;
        this.val = val;
      }
      StartWith2.prototype._start = function(out) {
        this.out = out;
        this.out._n(this.val);
        this.ins._add(out);
      };
      StartWith2.prototype._stop = function() {
        this.ins._remove(this.out);
        this.out = NO;
      };
      return StartWith2;
    }();
    var Take = function() {
      function Take2(max, ins) {
        this.type = "take";
        this.ins = ins;
        this.out = NO;
        this.max = max;
        this.taken = 0;
      }
      Take2.prototype._start = function(out) {
        this.out = out;
        this.taken = 0;
        if (this.max <= 0)
          out._c();
        else
          this.ins._add(this);
      };
      Take2.prototype._stop = function() {
        this.ins._remove(this);
        this.out = NO;
      };
      Take2.prototype._n = function(t) {
        var u = this.out;
        if (u === NO)
          return;
        var m = ++this.taken;
        if (m < this.max)
          u._n(t);
        else if (m === this.max) {
          u._n(t);
          u._c();
        }
      };
      Take2.prototype._e = function(err) {
        var u = this.out;
        if (u === NO)
          return;
        u._e(err);
      };
      Take2.prototype._c = function() {
        var u = this.out;
        if (u === NO)
          return;
        u._c();
      };
      return Take2;
    }();
    var Stream = function() {
      function Stream2(producer) {
        this._prod = producer || NO;
        this._ils = [];
        this._stopID = NO;
        this._dl = NO;
        this._d = false;
        this._target = null;
        this._err = NO;
      }
      Stream2.prototype._n = function(t) {
        var a = this._ils;
        var L = a.length;
        if (this._d)
          this._dl._n(t);
        if (L == 1)
          a[0]._n(t);
        else if (L == 0)
          return;
        else {
          var b = cp(a);
          for (var i = 0; i < L; i++)
            b[i]._n(t);
        }
      };
      Stream2.prototype._e = function(err) {
        if (this._err !== NO)
          return;
        this._err = err;
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
          this._dl._e(err);
        if (L == 1)
          a[0]._e(err);
        else if (L == 0)
          return;
        else {
          var b = cp(a);
          for (var i = 0; i < L; i++)
            b[i]._e(err);
        }
        if (!this._d && L == 0)
          throw this._err;
      };
      Stream2.prototype._c = function() {
        var a = this._ils;
        var L = a.length;
        this._x();
        if (this._d)
          this._dl._c();
        if (L == 1)
          a[0]._c();
        else if (L == 0)
          return;
        else {
          var b = cp(a);
          for (var i = 0; i < L; i++)
            b[i]._c();
        }
      };
      Stream2.prototype._x = function() {
        if (this._ils.length === 0)
          return;
        if (this._prod !== NO)
          this._prod._stop();
        this._err = NO;
        this._ils = [];
      };
      Stream2.prototype._stopNow = function() {
        this._prod._stop();
        this._err = NO;
        this._stopID = NO;
      };
      Stream2.prototype._add = function(il) {
        var ta = this._target;
        if (ta)
          return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1)
          return;
        if (this._stopID !== NO) {
          clearTimeout(this._stopID);
          this._stopID = NO;
        } else {
          var p = this._prod;
          if (p !== NO)
            p._start(this);
        }
      };
      Stream2.prototype._remove = function(il) {
        var _this = this;
        var ta = this._target;
        if (ta)
          return ta._remove(il);
        var a = this._ils;
        var i = a.indexOf(il);
        if (i > -1) {
          a.splice(i, 1);
          if (this._prod !== NO && a.length <= 0) {
            this._err = NO;
            this._stopID = setTimeout(function() {
              return _this._stopNow();
            });
          } else if (a.length === 1) {
            this._pruneCycles();
          }
        }
      };
      Stream2.prototype._pruneCycles = function() {
        if (this._hasNoSinks(this, []))
          this._remove(this._ils[0]);
      };
      Stream2.prototype._hasNoSinks = function(x, trace) {
        if (trace.indexOf(x) !== -1)
          return true;
        else if (x.out === this)
          return true;
        else if (x.out && x.out !== NO)
          return this._hasNoSinks(x.out, trace.concat(x));
        else if (x._ils) {
          for (var i = 0, N = x._ils.length; i < N; i++)
            if (!this._hasNoSinks(x._ils[i], trace.concat(x)))
              return false;
          return true;
        } else
          return false;
      };
      Stream2.prototype.ctor = function() {
        return this instanceof MemoryStream ? MemoryStream : Stream2;
      };
      Stream2.prototype.addListener = function(listener) {
        listener._n = listener.next || noop;
        listener._e = listener.error || noop;
        listener._c = listener.complete || noop;
        this._add(listener);
      };
      Stream2.prototype.removeListener = function(listener) {
        this._remove(listener);
      };
      Stream2.prototype.subscribe = function(listener) {
        this.addListener(listener);
        return new StreamSub(this, listener);
      };
      Stream2.prototype[$$observable] = function() {
        return this;
      };
      Stream2.create = function(producer) {
        if (producer) {
          if (typeof producer.start !== "function" || typeof producer.stop !== "function")
            throw new Error("producer requires both start and stop functions");
          internalizeProducer(producer);
        }
        return new Stream2(producer);
      };
      Stream2.createWithMemory = function(producer) {
        if (producer)
          internalizeProducer(producer);
        return new MemoryStream(producer);
      };
      Stream2.never = function() {
        return new Stream2({ _start: noop, _stop: noop });
      };
      Stream2.empty = function() {
        return new Stream2({
          _start: function(il) {
            il._c();
          },
          _stop: noop
        });
      };
      Stream2.throw = function(error) {
        return new Stream2({
          _start: function(il) {
            il._e(error);
          },
          _stop: noop
        });
      };
      Stream2.from = function(input) {
        if (typeof input[$$observable] === "function")
          return Stream2.fromObservable(input);
        else if (typeof input.then === "function")
          return Stream2.fromPromise(input);
        else if (Array.isArray(input))
          return Stream2.fromArray(input);
        throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
      };
      Stream2.of = function() {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          items[_i] = arguments[_i];
        }
        return Stream2.fromArray(items);
      };
      Stream2.fromArray = function(array) {
        return new Stream2(new FromArray(array));
      };
      Stream2.fromPromise = function(promise) {
        return new Stream2(new FromPromise(promise));
      };
      Stream2.fromObservable = function(obs) {
        if (obs.endWhen !== void 0)
          return obs;
        var o = typeof obs[$$observable] === "function" ? obs[$$observable]() : obs;
        return new Stream2(new FromObservable(o));
      };
      Stream2.periodic = function(period) {
        return new Stream2(new Periodic(period));
      };
      Stream2.prototype._map = function(project) {
        return new (this.ctor())(new MapOp(project, this));
      };
      Stream2.prototype.map = function(project) {
        return this._map(project);
      };
      Stream2.prototype.mapTo = function(projectedValue) {
        var s = this.map(function() {
          return projectedValue;
        });
        var op = s._prod;
        op.type = "mapTo";
        return s;
      };
      Stream2.prototype.filter = function(passes) {
        var p = this._prod;
        if (p instanceof Filter)
          return new Stream2(new Filter(and(p.f, passes), p.ins));
        return new Stream2(new Filter(passes, this));
      };
      Stream2.prototype.take = function(amount) {
        return new (this.ctor())(new Take(amount, this));
      };
      Stream2.prototype.drop = function(amount) {
        return new Stream2(new Drop(amount, this));
      };
      Stream2.prototype.last = function() {
        return new Stream2(new Last(this));
      };
      Stream2.prototype.startWith = function(initial) {
        return new MemoryStream(new StartWith(this, initial));
      };
      Stream2.prototype.endWhen = function(other) {
        return new (this.ctor())(new EndWhen(other, this));
      };
      Stream2.prototype.fold = function(accumulate, seed) {
        return new MemoryStream(new Fold(accumulate, seed, this));
      };
      Stream2.prototype.replaceError = function(replace) {
        return new (this.ctor())(new ReplaceError(replace, this));
      };
      Stream2.prototype.flatten = function() {
        return new Stream2(new Flatten(this));
      };
      Stream2.prototype.compose = function(operator) {
        return operator(this);
      };
      Stream2.prototype.remember = function() {
        return new MemoryStream(new Remember(this));
      };
      Stream2.prototype.debug = function(labelOrSpy) {
        return new (this.ctor())(new Debug(this, labelOrSpy));
      };
      Stream2.prototype.imitate = function(target) {
        if (target instanceof MemoryStream)
          throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
        this._target = target;
        for (var ils = this._ils, N = ils.length, i = 0; i < N; i++)
          target._add(ils[i]);
        this._ils = [];
      };
      Stream2.prototype.shamefullySendNext = function(value) {
        this._n(value);
      };
      Stream2.prototype.shamefullySendError = function(error) {
        this._e(error);
      };
      Stream2.prototype.shamefullySendComplete = function() {
        this._c();
      };
      Stream2.prototype.setDebugListener = function(listener) {
        if (!listener) {
          this._d = false;
          this._dl = NO;
        } else {
          this._d = true;
          listener._n = listener.next || noop;
          listener._e = listener.error || noop;
          listener._c = listener.complete || noop;
          this._dl = listener;
        }
      };
      Stream2.merge = function merge() {
        var streams = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          streams[_i] = arguments[_i];
        }
        return new Stream2(new Merge(streams));
      };
      Stream2.combine = function combine() {
        var streams = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          streams[_i] = arguments[_i];
        }
        return new Stream2(new Combine(streams));
      };
      return Stream2;
    }();
    exports.Stream = Stream;
    var MemoryStream = function(_super) {
      __extends(MemoryStream2, _super);
      function MemoryStream2(producer) {
        var _this = _super.call(this, producer) || this;
        _this._has = false;
        return _this;
      }
      MemoryStream2.prototype._n = function(x) {
        this._v = x;
        this._has = true;
        _super.prototype._n.call(this, x);
      };
      MemoryStream2.prototype._add = function(il) {
        var ta = this._target;
        if (ta)
          return ta._add(il);
        var a = this._ils;
        a.push(il);
        if (a.length > 1) {
          if (this._has)
            il._n(this._v);
          return;
        }
        if (this._stopID !== NO) {
          if (this._has)
            il._n(this._v);
          clearTimeout(this._stopID);
          this._stopID = NO;
        } else if (this._has)
          il._n(this._v);
        else {
          var p = this._prod;
          if (p !== NO)
            p._start(this);
        }
      };
      MemoryStream2.prototype._stopNow = function() {
        this._has = false;
        _super.prototype._stopNow.call(this);
      };
      MemoryStream2.prototype._x = function() {
        this._has = false;
        _super.prototype._x.call(this);
      };
      MemoryStream2.prototype.map = function(project) {
        return this._map(project);
      };
      MemoryStream2.prototype.mapTo = function(projectedValue) {
        return _super.prototype.mapTo.call(this, projectedValue);
      };
      MemoryStream2.prototype.take = function(amount) {
        return _super.prototype.take.call(this, amount);
      };
      MemoryStream2.prototype.endWhen = function(other) {
        return _super.prototype.endWhen.call(this, other);
      };
      MemoryStream2.prototype.replaceError = function(replace) {
        return _super.prototype.replaceError.call(this, replace);
      };
      MemoryStream2.prototype.remember = function() {
        return this;
      };
      MemoryStream2.prototype.debug = function(labelOrSpy) {
        return _super.prototype.debug.call(this, labelOrSpy);
      };
      return MemoryStream2;
    }(Stream);
    exports.MemoryStream = MemoryStream;
    var xs = Stream;
    exports.default = xs;
  }
});

// node_modules/@cosmjs/stream/build/concat.js
var require_concat = __commonJS({
  "node_modules/@cosmjs/stream/build/concat.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = void 0;
    var xstream_1 = require_xstream();
    function concat(...streams) {
      const subscriptions = new Array();
      const queues = new Array();
      const completedStreams = new Set();
      let activeStreamIndex = 0;
      function reset() {
        while (subscriptions.length > 0) {
          const subscription = subscriptions.shift();
          subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
      }
      const producer = {
        start: (listener) => {
          streams.forEach((_) => queues.push([]));
          function emitAllQueuesEvents(streamIndex) {
            while (true) {
              const element = queues[streamIndex].shift();
              if (element === void 0) {
                return;
              }
              listener.next(element);
            }
          }
          function isDone() {
            return activeStreamIndex >= streams.length;
          }
          if (isDone()) {
            listener.complete();
            return;
          }
          streams.forEach((stream, index) => {
            subscriptions.push(stream.subscribe({
              next: (value) => {
                if (index === activeStreamIndex) {
                  listener.next(value);
                } else {
                  queues[index].push(value);
                }
              },
              complete: () => {
                completedStreams.add(index);
                while (completedStreams.has(activeStreamIndex)) {
                  emitAllQueuesEvents(activeStreamIndex);
                  activeStreamIndex++;
                }
                if (isDone()) {
                  listener.complete();
                } else {
                  emitAllQueuesEvents(activeStreamIndex);
                }
              },
              error: (error) => {
                listener.error(error);
                reset();
              }
            }));
          });
        },
        stop: () => {
          reset();
        }
      };
      return xstream_1.Stream.create(producer);
    }
    exports.concat = concat;
  }
});

// node_modules/@cosmjs/stream/build/defaultvalueproducer.js
var require_defaultvalueproducer = __commonJS({
  "node_modules/@cosmjs/stream/build/defaultvalueproducer.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultValueProducer = void 0;
    var DefaultValueProducer = class {
      constructor(value, callbacks) {
        this.callbacks = callbacks;
        this.internalValue = value;
      }
      get value() {
        return this.internalValue;
      }
      update(value) {
        this.internalValue = value;
        if (this.listener) {
          this.listener.next(value);
        }
      }
      error(error) {
        if (this.listener) {
          this.listener.error(error);
        }
      }
      start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) {
          this.callbacks.onStarted();
        }
      }
      stop() {
        if (this.callbacks) {
          this.callbacks.onStop();
        }
        this.listener = void 0;
      }
    };
    exports.DefaultValueProducer = DefaultValueProducer;
  }
});

// node_modules/@cosmjs/stream/build/dropduplicates.js
var require_dropduplicates = __commonJS({
  "node_modules/@cosmjs/stream/build/dropduplicates.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropDuplicates = void 0;
    function dropDuplicates(valueToKey) {
      const operand = (instream) => {
        const emittedKeys = new Set();
        const deduplicatedStream = instream.filter((value) => !emittedKeys.has(valueToKey(value))).debug((value) => emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
      };
      return operand;
    }
    exports.dropDuplicates = dropDuplicates;
  }
});

// node_modules/@cosmjs/stream/build/promise.js
var require_promise = __commonJS({
  "node_modules/@cosmjs/stream/build/promise.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.firstEvent = exports.toListPromise = exports.fromListPromise = void 0;
    var xstream_1 = require_xstream();
    function fromListPromise(promise) {
      const producer = {
        start: (listener) => {
          promise.then((iterable) => {
            for (const element of iterable) {
              listener.next(element);
            }
            listener.complete();
          }).catch((error) => listener.error(error));
        },
        stop: () => {
        }
      };
      return xstream_1.Stream.create(producer);
    }
    exports.fromListPromise = fromListPromise;
    async function toListPromise(stream, count) {
      return new Promise((resolve, reject) => {
        if (count === 0) {
          resolve([]);
          return;
        }
        const events = new Array();
        stream.take(count).subscribe({
          next: (event) => {
            events.push(event);
            if (events.length === count) {
              resolve(events);
            }
          },
          complete: () => {
            reject(`Stream completed before all events could be collected. Collected ${events.length}, expected ${count}`);
          },
          error: (error) => reject(error)
        });
      });
    }
    exports.toListPromise = toListPromise;
    async function firstEvent(stream) {
      return (await toListPromise(stream, 1))[0];
    }
    exports.firstEvent = firstEvent;
  }
});

// node_modules/@cosmjs/stream/build/reducer.js
var require_reducer = __commonJS({
  "node_modules/@cosmjs/stream/build/reducer.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0;
    var Reducer = class {
      constructor(stream, reducer, initState) {
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject) => {
          const subscription = this.stream.subscribe({
            next: (evt) => {
              this.state = this.reducer(this.state, evt);
            },
            complete: () => {
              resolve();
              subscription.unsubscribe();
            },
            error: (err) => {
              reject(err);
              subscription.unsubscribe();
            }
          });
        });
      }
      value() {
        return this.state;
      }
      async finished() {
        return this.completed;
      }
    };
    exports.Reducer = Reducer;
    function increment(sum, _) {
      return sum + 1;
    }
    function countStream(stream) {
      return new Reducer(stream, increment, 0);
    }
    exports.countStream = countStream;
    function append(list, evt) {
      return [...list, evt];
    }
    function asArray(stream) {
      return new Reducer(stream, append, []);
    }
    exports.asArray = asArray;
    function last(_, event) {
      return event;
    }
    function lastValue(stream) {
      return new Reducer(stream, last, void 0);
    }
    exports.lastValue = lastValue;
  }
});

// node_modules/@cosmjs/stream/build/valueandupdates.js
var require_valueandupdates = __commonJS({
  "node_modules/@cosmjs/stream/build/valueandupdates.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = void 0;
    var xstream_1 = require_xstream();
    var ValueAndUpdates = class {
      constructor(producer) {
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
      }
      get value() {
        return this.producer.value;
      }
      async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value) => value === search;
        return new Promise((resolve, reject) => {
          const subscription = this.updates.subscribe({
            next: (newValue) => {
              if (searchImplementation(newValue)) {
                resolve(newValue);
                setTimeout(() => subscription.unsubscribe(), 0);
              }
            },
            complete: () => {
              subscription.unsubscribe();
              reject("Update stream completed without expected value");
            },
            error: (error) => {
              reject(error);
            }
          });
        });
      }
    };
    exports.ValueAndUpdates = ValueAndUpdates;
  }
});

// node_modules/@cosmjs/stream/build/index.js
var require_build8 = __commonJS({
  "node_modules/@cosmjs/stream/build/index.js"(exports) {
    init_define_global();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = exports.toListPromise = exports.fromListPromise = exports.firstEvent = exports.dropDuplicates = exports.DefaultValueProducer = exports.concat = void 0;
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var defaultvalueproducer_1 = require_defaultvalueproducer();
    Object.defineProperty(exports, "DefaultValueProducer", { enumerable: true, get: function() {
      return defaultvalueproducer_1.DefaultValueProducer;
    } });
    var dropduplicates_1 = require_dropduplicates();
    Object.defineProperty(exports, "dropDuplicates", { enumerable: true, get: function() {
      return dropduplicates_1.dropDuplicates;
    } });
    var promise_1 = require_promise();
    Object.defineProperty(exports, "firstEvent", { enumerable: true, get: function() {
      return promise_1.firstEvent;
    } });
    Object.defineProperty(exports, "fromListPromise", { enumerable: true, get: function() {
      return promise_1.fromListPromise;
    } });
    Object.defineProperty(exports, "toListPromise", { enumerable: true, get: function() {
      return promise_1.toListPromise;
    } });
    __exportStar(require_reducer(), exports);
    var valueandupdates_1 = require_valueandupdates();
    Object.defineProperty(exports, "ValueAndUpdates", { enumerable: true, get: function() {
      return valueandupdates_1.ValueAndUpdates;
    } });
  }
});

// node_modules/@cosmjs/stargate/build/queries/queryclient.js
var require_queryclient = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/queryclient.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClient = void 0;
    var ics23_1 = require_build7();
    var encoding_1 = require_build();
    var stream_1 = require_build8();
    var utils_1 = require_build2();
    function checkAndParseOp(op, kind, key) {
      if (op.type !== kind) {
        throw new Error(`Op expected to be ${kind}, got "${op.type}`);
      }
      if (!(0, utils_1.arrayContentEquals)(key, op.key)) {
        throw new Error(`Proven key different than queried key.
Query: ${(0, encoding_1.toHex)(key)}
Proven: ${(0, encoding_1.toHex)(op.key)}`);
      }
      return ics23_1.ics23.CommitmentProof.decode(op.data);
    }
    var QueryClient = class {
      constructor(tmClient) {
        this.tmClient = tmClient;
      }
      static withExtensions(tmClient, ...extensionSetups) {
        const client = new QueryClient(tmClient);
        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));
        for (const extension of extensions) {
          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
          for (const [moduleKey, moduleValue] of Object.entries(extension)) {
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
            const current = client[moduleKey] || {};
            client[moduleKey] = Object.assign(Object.assign({}, current), moduleValue);
          }
        }
        return client;
      }
      async queryVerified(store, key, desiredHeight) {
        const { height, proof, value } = await this.queryRawProof(store, key, desiredHeight);
        const subProof = checkAndParseOp(proof.ops[0], "ics23:iavl", key);
        const storeProof = checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        (0, utils_1.assert)(storeProof.exist);
        (0, utils_1.assert)(storeProof.exist.value);
        if (!value || value.length === 0) {
          (0, utils_1.assert)(subProof.nonexist);
          (0, ics23_1.verifyNonExistence)(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);
        } else {
          (0, utils_1.assert)(subProof.exist);
          (0, utils_1.assert)(subProof.exist.value);
          (0, ics23_1.verifyExistence)(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);
        }
        const header = await this.getNextHeader(height);
        (0, ics23_1.verifyExistence)(storeProof.exist, ics23_1.tendermintSpec, header.appHash, (0, encoding_1.toAscii)(store), storeProof.exist.value);
        return value;
      }
      async queryRawProof(store, queryKey, desiredHeight) {
        var _a;
        const { key, value, height, proof, code, log } = await this.tmClient.abciQuery({
          path: `/store/${store}/key`,
          data: queryKey,
          prove: true,
          height: desiredHeight
        });
        if (code) {
          throw new Error(`Query failed with (${code}): ${log}`);
        }
        if (!(0, utils_1.arrayContentEquals)(queryKey, key)) {
          throw new Error(`Response key ${(0, encoding_1.toHex)(key)} doesn't match query key ${(0, encoding_1.toHex)(queryKey)}`);
        }
        if (!height) {
          throw new Error("No query height returned");
        }
        if (!proof || proof.ops.length !== 2) {
          throw new Error(`Expected 2 proof ops, got ${(_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0}. Are you using stargate?`);
        }
        checkAndParseOp(proof.ops[0], "ics23:iavl", key);
        checkAndParseOp(proof.ops[1], "ics23:simple", (0, encoding_1.toAscii)(store));
        return {
          key,
          value,
          height,
          proof: {
            ops: [...proof.ops]
          }
        };
      }
      async queryUnverified(path, request) {
        const response = await this.tmClient.abciQuery({
          path,
          data: request,
          prove: false
        });
        if (response.code) {
          throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        return response.value;
      }
      async getNextHeader(height) {
        (0, utils_1.assertDefined)(height);
        if (height === 0) {
          throw new Error("Query returned height 0, cannot prove it");
        }
        const searchHeight = height + 1;
        let nextHeader;
        let headersSubscription;
        try {
          headersSubscription = this.tmClient.subscribeNewBlockHeader();
        } catch (_a) {
        }
        if (headersSubscription) {
          const firstHeader = await (0, stream_1.firstEvent)(headersSubscription);
          if (firstHeader.height === searchHeight) {
            nextHeader = firstHeader;
          }
        }
        while (!nextHeader) {
          const correctHeader = (await this.tmClient.blockchain(height, searchHeight)).blockMetas.map((meta) => meta.header).find((h) => h.height === searchHeight);
          if (correctHeader) {
            nextHeader = correctHeader;
          } else {
            await (0, utils_1.sleep)(1e3);
          }
        }
        (0, utils_1.assert)(nextHeader.height === searchHeight, "Got wrong header. This is a bug in the logic above.");
        return nextHeader;
      }
    };
    exports.QueryClient = QueryClient;
  }
});

// node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js
var require_pagination = __commonJS({
  "node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageResponse = exports.PageRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "cosmos.base.query.v1beta1";
    var basePageRequest = { offset: long_1.default.UZERO, limit: long_1.default.UZERO, countTotal: false, reverse: false };
    exports.PageRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (!message.offset.isZero()) {
          writer.uint32(16).uint64(message.offset);
        }
        if (!message.limit.isZero()) {
          writer.uint32(24).uint64(message.limit);
        }
        if (message.countTotal === true) {
          writer.uint32(32).bool(message.countTotal);
        }
        if (message.reverse === true) {
          writer.uint32(40).bool(message.reverse);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePageRequest);
        message.key = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.offset = reader.uint64();
              break;
            case 3:
              message.limit = reader.uint64();
              break;
            case 4:
              message.countTotal = reader.bool();
              break;
            case 5:
              message.reverse = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePageRequest);
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.offset = object.offset !== void 0 && object.offset !== null ? long_1.default.fromString(object.offset) : long_1.default.UZERO;
        message.limit = object.limit !== void 0 && object.limit !== null ? long_1.default.fromString(object.limit) : long_1.default.UZERO;
        message.countTotal = object.countTotal !== void 0 && object.countTotal !== null ? Boolean(object.countTotal) : false;
        message.reverse = object.reverse !== void 0 && object.reverse !== null ? Boolean(object.reverse) : false;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.offset !== void 0 && (obj.offset = (message.offset || long_1.default.UZERO).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || long_1.default.UZERO).toString());
        message.countTotal !== void 0 && (obj.countTotal = message.countTotal);
        message.reverse !== void 0 && (obj.reverse = message.reverse);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, basePageRequest);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.offset = object.offset !== void 0 && object.offset !== null ? long_1.default.fromValue(object.offset) : long_1.default.UZERO;
        message.limit = object.limit !== void 0 && object.limit !== null ? long_1.default.fromValue(object.limit) : long_1.default.UZERO;
        message.countTotal = (_b = object.countTotal) !== null && _b !== void 0 ? _b : false;
        message.reverse = (_c = object.reverse) !== null && _c !== void 0 ? _c : false;
        return message;
      }
    };
    var basePageResponse = { total: long_1.default.UZERO };
    exports.PageResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nextKey.length !== 0) {
          writer.uint32(10).bytes(message.nextKey);
        }
        if (!message.total.isZero()) {
          writer.uint32(16).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePageResponse);
        message.nextKey = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextKey = reader.bytes();
              break;
            case 2:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePageResponse);
        message.nextKey = object.nextKey !== void 0 && object.nextKey !== null ? bytesFromBase64(object.nextKey) : new Uint8Array();
        message.total = object.total !== void 0 && object.total !== null ? long_1.default.fromString(object.total) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.nextKey !== void 0 && (obj.nextKey = base64FromBytes(message.nextKey !== void 0 ? message.nextKey : new Uint8Array()));
        message.total !== void 0 && (obj.total = (message.total || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, basePageResponse);
        message.nextKey = (_a = object.nextKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.total = object.total !== void 0 && object.total !== null ? long_1.default.fromValue(object.total) : long_1.default.UZERO;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js
var require_query = __commonJS({
  "node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryAccountResponse = exports.QueryAccountRequest = exports.QueryAccountsResponse = exports.QueryAccountsRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var auth_1 = require_auth();
    exports.protobufPackage = "cosmos.auth.v1beta1";
    var baseQueryAccountsRequest = {};
    exports.QueryAccountsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAccountsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryAccountsRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryAccountsRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryAccountsResponse = {};
    exports.QueryAccountsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.accounts) {
          any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAccountsResponse);
        message.accounts = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryAccountsResponse);
        message.accounts = ((_a = object.accounts) !== null && _a !== void 0 ? _a : []).map((e) => any_1.Any.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryAccountsResponse);
        message.accounts = ((_a = object.accounts) === null || _a === void 0 ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryAccountRequest = { address: "" };
    exports.QueryAccountRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAccountRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryAccountRequest);
        message.address = object.address !== void 0 && object.address !== null ? String(object.address) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryAccountRequest);
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryAccountResponse = {};
    exports.QueryAccountResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAccountResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryAccountResponse);
        message.account = object.account !== void 0 && object.account !== null ? any_1.Any.fromJSON(object.account) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryAccountResponse);
        message.account = object.account !== void 0 && object.account !== null ? any_1.Any.fromPartial(object.account) : void 0;
        return message;
      }
    };
    var baseQueryParamsRequest = {};
    exports.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      }
    };
    var baseQueryParamsResponse = {};
    exports.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          auth_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = auth_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? auth_1.Params.fromJSON(object.params) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? auth_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? auth_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Accounts = this.Accounts.bind(this);
        this.Account = this.Account.bind(this);
        this.Params = this.Params.bind(this);
      }
      Accounts(request) {
        const data = exports.QueryAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data);
        return promise.then((data2) => exports.QueryAccountsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Account(request) {
        const data = exports.QueryAccountRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Account", data);
        return promise.then((data2) => exports.QueryAccountResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/queries/utils.js
var require_utils2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/utils.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeCosmosSdkDecFromProto = exports.longify = exports.createProtobufRpcClient = exports.createPagination = exports.toAccAddress = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build3();
    var pagination_1 = require_pagination();
    var long_1 = __importDefault(require_long());
    function toAccAddress(address) {
      return encoding_1.Bech32.decode(address).data;
    }
    exports.toAccAddress = toAccAddress;
    function createPagination(paginationKey) {
      return paginationKey ? pagination_1.PageRequest.fromPartial({
        key: paginationKey,
        offset: long_1.default.fromNumber(0, true),
        limit: long_1.default.fromNumber(0, true),
        countTotal: false
      }) : void 0;
    }
    exports.createPagination = createPagination;
    function createProtobufRpcClient(base) {
      return {
        request: (service, method, data) => {
          const path = `/${service}/${method}`;
          return base.queryUnverified(path, data);
        }
      };
    }
    exports.createProtobufRpcClient = createProtobufRpcClient;
    function longify(value) {
      const checkedValue = math_1.Uint64.fromString(value.toString());
      return long_1.default.fromBytesBE([...checkedValue.toBytesBigEndian()], true);
    }
    exports.longify = longify;
    function decodeCosmosSdkDecFromProto(input) {
      const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
      return math_1.Decimal.fromAtomics(asString, 18);
    }
    exports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
  }
});

// node_modules/@cosmjs/stargate/build/queries/auth.js
var require_auth2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/auth.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthExtension = void 0;
    var query_1 = require_query();
    var utils_1 = require_utils2();
    function setupAuthExtension(base) {
      const rpc = (0, utils_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        auth: {
          account: async (address) => {
            const { account } = await queryService.Account({ address });
            return account !== null && account !== void 0 ? account : null;
          }
        }
      };
    }
    exports.setupAuthExtension = setupAuthExtension;
  }
});

// node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js
var require_query2 = __commonJS({
  "node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryDenomMetadataResponse = exports.QueryDenomMetadataRequest = exports.QueryDenomsMetadataResponse = exports.QueryDenomsMetadataRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QuerySupplyOfResponse = exports.QuerySupplyOfRequest = exports.QueryTotalSupplyResponse = exports.QueryTotalSupplyRequest = exports.QueryAllBalancesResponse = exports.QueryAllBalancesRequest = exports.QueryBalanceResponse = exports.QueryBalanceRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin();
    var pagination_1 = require_pagination();
    var bank_1 = require_bank();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    var baseQueryBalanceRequest = { address: "", denom: "" };
    exports.QueryBalanceRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
          writer.uint32(18).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryBalanceRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryBalanceRequest);
        message.address = object.address !== void 0 && object.address !== null ? String(object.address) : "";
        message.denom = object.denom !== void 0 && object.denom !== null ? String(object.denom) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryBalanceRequest);
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.denom = (_b = object.denom) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseQueryBalanceResponse = {};
    exports.QueryBalanceResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryBalanceResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryBalanceResponse);
        message.balance = object.balance !== void 0 && object.balance !== null ? coin_1.Coin.fromJSON(object.balance) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryBalanceResponse);
        message.balance = object.balance !== void 0 && object.balance !== null ? coin_1.Coin.fromPartial(object.balance) : void 0;
        return message;
      }
    };
    var baseQueryAllBalancesRequest = { address: "" };
    exports.QueryAllBalancesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAllBalancesRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryAllBalancesRequest);
        message.address = object.address !== void 0 && object.address !== null ? String(object.address) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryAllBalancesRequest);
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryAllBalancesResponse = {};
    exports.QueryAllBalancesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.balances) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAllBalancesResponse);
        message.balances = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryAllBalancesResponse);
        message.balances = ((_a = object.balances) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryAllBalancesResponse);
        message.balances = ((_a = object.balances) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryTotalSupplyRequest = {};
    exports.QueryTotalSupplyRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTotalSupplyRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryTotalSupplyRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryTotalSupplyRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryTotalSupplyResponse = {};
    exports.QueryTotalSupplyResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.supply) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTotalSupplyResponse);
        message.supply = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.supply.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryTotalSupplyResponse);
        message.supply = ((_a = object.supply) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.supply) {
          obj.supply = message.supply.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.supply = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryTotalSupplyResponse);
        message.supply = ((_a = object.supply) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQuerySupplyOfRequest = { denom: "" };
    exports.QuerySupplyOfRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQuerySupplyOfRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQuerySupplyOfRequest);
        message.denom = object.denom !== void 0 && object.denom !== null ? String(object.denom) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQuerySupplyOfRequest);
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQuerySupplyOfResponse = {};
    exports.QuerySupplyOfResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQuerySupplyOfResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQuerySupplyOfResponse);
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromJSON(object.amount) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQuerySupplyOfResponse);
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    var baseQueryParamsRequest = {};
    exports.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      }
    };
    var baseQueryParamsResponse = {};
    exports.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? bank_1.Params.fromJSON(object.params) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? bank_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var baseQueryDenomsMetadataRequest = {};
    exports.QueryDenomsMetadataRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDenomsMetadataRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDenomsMetadataRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryDenomsMetadataRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDenomsMetadataResponse = {};
    exports.QueryDenomsMetadataResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.metadatas) {
          bank_1.Metadata.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDenomsMetadataResponse);
        message.metadatas = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadatas.push(bank_1.Metadata.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryDenomsMetadataResponse);
        message.metadatas = ((_a = object.metadatas) !== null && _a !== void 0 ? _a : []).map((e) => bank_1.Metadata.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.metadatas) {
          obj.metadatas = message.metadatas.map((e) => e ? bank_1.Metadata.toJSON(e) : void 0);
        } else {
          obj.metadatas = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDenomsMetadataResponse);
        message.metadatas = ((_a = object.metadatas) === null || _a === void 0 ? void 0 : _a.map((e) => bank_1.Metadata.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDenomMetadataRequest = { denom: "" };
    exports.QueryDenomMetadataRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDenomMetadataRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDenomMetadataRequest);
        message.denom = object.denom !== void 0 && object.denom !== null ? String(object.denom) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDenomMetadataRequest);
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryDenomMetadataResponse = {};
    exports.QueryDenomMetadataResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.metadata !== void 0) {
          bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDenomMetadataResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDenomMetadataResponse);
        message.metadata = object.metadata !== void 0 && object.metadata !== null ? bank_1.Metadata.fromJSON(object.metadata) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.metadata !== void 0 && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryDenomMetadataResponse);
        message.metadata = object.metadata !== void 0 && object.metadata !== null ? bank_1.Metadata.fromPartial(object.metadata) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Balance = this.Balance.bind(this);
        this.AllBalances = this.AllBalances.bind(this);
        this.TotalSupply = this.TotalSupply.bind(this);
        this.SupplyOf = this.SupplyOf.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomMetadata = this.DenomMetadata.bind(this);
        this.DenomsMetadata = this.DenomsMetadata.bind(this);
      }
      Balance(request) {
        const data = exports.QueryBalanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", data);
        return promise.then((data2) => exports.QueryBalanceResponse.decode(new minimal_1.default.Reader(data2)));
      }
      AllBalances(request) {
        const data = exports.QueryAllBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", data);
        return promise.then((data2) => exports.QueryAllBalancesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      TotalSupply(request) {
        const data = exports.QueryTotalSupplyRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", data);
        return promise.then((data2) => exports.QueryTotalSupplyResponse.decode(new minimal_1.default.Reader(data2)));
      }
      SupplyOf(request) {
        const data = exports.QuerySupplyOfRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", data);
        return promise.then((data2) => exports.QuerySupplyOfResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DenomMetadata(request) {
        const data = exports.QueryDenomMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", data);
        return promise.then((data2) => exports.QueryDenomMetadataResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DenomsMetadata(request) {
        const data = exports.QueryDenomsMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", data);
        return promise.then((data2) => exports.QueryDenomsMetadataResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/queries/bank.js
var require_bank2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/bank.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupBankExtension = void 0;
    var utils_1 = require_build2();
    var query_1 = require_query2();
    var utils_2 = require_utils2();
    function setupBankExtension(base) {
      const rpc = (0, utils_2.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        bank: {
          balance: async (address, denom) => {
            const { balance } = await queryService.Balance({ address, denom });
            (0, utils_1.assert)(balance);
            return balance;
          },
          allBalances: async (address) => {
            const { balances } = await queryService.AllBalances({ address });
            return balances;
          },
          totalSupply: async () => {
            const { supply } = await queryService.TotalSupply({});
            return supply;
          },
          supplyOf: async (denom) => {
            const { amount } = await queryService.SupplyOf({ denom });
            (0, utils_1.assert)(amount);
            return amount;
          },
          denomMetadata: async (denom) => {
            const { metadata } = await queryService.DenomMetadata({ denom });
            (0, utils_1.assert)(metadata);
            return metadata;
          },
          denomsMetadata: async () => {
            const { metadatas } = await queryService.DenomsMetadata({
              pagination: void 0
            });
            return metadatas;
          }
        }
      };
    }
    exports.setupBankExtension = setupBankExtension;
  }
});

// node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js
var require_distribution = __commonJS({
  "node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommunityPoolSpendProposalWithDeposit = exports.DelegationDelegatorReward = exports.DelegatorStartingInfo = exports.CommunityPoolSpendProposal = exports.FeePool = exports.ValidatorSlashEvents = exports.ValidatorSlashEvent = exports.ValidatorOutstandingRewards = exports.ValidatorAccumulatedCommission = exports.ValidatorCurrentRewards = exports.ValidatorHistoricalRewards = exports.Params = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    var baseParams = {
      communityTax: "",
      baseProposerReward: "",
      bonusProposerReward: "",
      withdrawAddrEnabled: false
    };
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.communityTax !== "") {
          writer.uint32(10).string(message.communityTax);
        }
        if (message.baseProposerReward !== "") {
          writer.uint32(18).string(message.baseProposerReward);
        }
        if (message.bonusProposerReward !== "") {
          writer.uint32(26).string(message.bonusProposerReward);
        }
        if (message.withdrawAddrEnabled === true) {
          writer.uint32(32).bool(message.withdrawAddrEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityTax = reader.string();
              break;
            case 2:
              message.baseProposerReward = reader.string();
              break;
            case 3:
              message.bonusProposerReward = reader.string();
              break;
            case 4:
              message.withdrawAddrEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseParams);
        message.communityTax = object.communityTax !== void 0 && object.communityTax !== null ? String(object.communityTax) : "";
        message.baseProposerReward = object.baseProposerReward !== void 0 && object.baseProposerReward !== null ? String(object.baseProposerReward) : "";
        message.bonusProposerReward = object.bonusProposerReward !== void 0 && object.bonusProposerReward !== null ? String(object.bonusProposerReward) : "";
        message.withdrawAddrEnabled = object.withdrawAddrEnabled !== void 0 && object.withdrawAddrEnabled !== null ? Boolean(object.withdrawAddrEnabled) : false;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.communityTax !== void 0 && (obj.communityTax = message.communityTax);
        message.baseProposerReward !== void 0 && (obj.baseProposerReward = message.baseProposerReward);
        message.bonusProposerReward !== void 0 && (obj.bonusProposerReward = message.bonusProposerReward);
        message.withdrawAddrEnabled !== void 0 && (obj.withdrawAddrEnabled = message.withdrawAddrEnabled);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseParams);
        message.communityTax = (_a = object.communityTax) !== null && _a !== void 0 ? _a : "";
        message.baseProposerReward = (_b = object.baseProposerReward) !== null && _b !== void 0 ? _b : "";
        message.bonusProposerReward = (_c = object.bonusProposerReward) !== null && _c !== void 0 ? _c : "";
        message.withdrawAddrEnabled = (_d = object.withdrawAddrEnabled) !== null && _d !== void 0 ? _d : false;
        return message;
      }
    };
    var baseValidatorHistoricalRewards = { referenceCount: 0 };
    exports.ValidatorHistoricalRewards = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.cumulativeRewardRatio) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.referenceCount !== 0) {
          writer.uint32(16).uint32(message.referenceCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorHistoricalRewards);
        message.cumulativeRewardRatio = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cumulativeRewardRatio.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.referenceCount = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseValidatorHistoricalRewards);
        message.cumulativeRewardRatio = ((_a = object.cumulativeRewardRatio) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.DecCoin.fromJSON(e));
        message.referenceCount = object.referenceCount !== void 0 && object.referenceCount !== null ? Number(object.referenceCount) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.cumulativeRewardRatio) {
          obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.cumulativeRewardRatio = [];
        }
        message.referenceCount !== void 0 && (obj.referenceCount = message.referenceCount);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseValidatorHistoricalRewards);
        message.cumulativeRewardRatio = ((_a = object.cumulativeRewardRatio) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.referenceCount = (_b = object.referenceCount) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var baseValidatorCurrentRewards = { period: long_1.default.UZERO };
    exports.ValidatorCurrentRewards = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (!message.period.isZero()) {
          writer.uint32(16).uint64(message.period);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorCurrentRewards);
        message.rewards = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.period = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseValidatorCurrentRewards);
        message.rewards = ((_a = object.rewards) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.DecCoin.fromJSON(e));
        message.period = object.period !== void 0 && object.period !== null ? long_1.default.fromString(object.period) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        message.period !== void 0 && (obj.period = (message.period || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidatorCurrentRewards);
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.period = object.period !== void 0 && object.period !== null ? long_1.default.fromValue(object.period) : long_1.default.UZERO;
        return message;
      }
    };
    var baseValidatorAccumulatedCommission = {};
    exports.ValidatorAccumulatedCommission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.commission) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorAccumulatedCommission);
        message.commission = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseValidatorAccumulatedCommission);
        message.commission = ((_a = object.commission) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.DecCoin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidatorAccumulatedCommission);
        message.commission = ((_a = object.commission) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseValidatorOutstandingRewards = {};
    exports.ValidatorOutstandingRewards = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorOutstandingRewards);
        message.rewards = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseValidatorOutstandingRewards);
        message.rewards = ((_a = object.rewards) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.DecCoin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidatorOutstandingRewards);
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseValidatorSlashEvent = { validatorPeriod: long_1.default.UZERO, fraction: "" };
    exports.ValidatorSlashEvent = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.validatorPeriod.isZero()) {
          writer.uint32(8).uint64(message.validatorPeriod);
        }
        if (message.fraction !== "") {
          writer.uint32(18).string(message.fraction);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorSlashEvent);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorPeriod = reader.uint64();
              break;
            case 2:
              message.fraction = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseValidatorSlashEvent);
        message.validatorPeriod = object.validatorPeriod !== void 0 && object.validatorPeriod !== null ? long_1.default.fromString(object.validatorPeriod) : long_1.default.UZERO;
        message.fraction = object.fraction !== void 0 && object.fraction !== null ? String(object.fraction) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorPeriod !== void 0 && (obj.validatorPeriod = (message.validatorPeriod || long_1.default.UZERO).toString());
        message.fraction !== void 0 && (obj.fraction = message.fraction);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidatorSlashEvent);
        message.validatorPeriod = object.validatorPeriod !== void 0 && object.validatorPeriod !== null ? long_1.default.fromValue(object.validatorPeriod) : long_1.default.UZERO;
        message.fraction = (_a = object.fraction) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseValidatorSlashEvents = {};
    exports.ValidatorSlashEvents = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validatorSlashEvents) {
          exports.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorSlashEvents);
        message.validatorSlashEvents = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorSlashEvents.push(exports.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseValidatorSlashEvents);
        message.validatorSlashEvents = ((_a = object.validatorSlashEvents) !== null && _a !== void 0 ? _a : []).map((e) => exports.ValidatorSlashEvent.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorSlashEvents) {
          obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => e ? exports.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.validatorSlashEvents = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidatorSlashEvents);
        message.validatorSlashEvents = ((_a = object.validatorSlashEvents) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ValidatorSlashEvent.fromPartial(e))) || [];
        return message;
      }
    };
    var baseFeePool = {};
    exports.FeePool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.communityPool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseFeePool);
        message.communityPool = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityPool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseFeePool);
        message.communityPool = ((_a = object.communityPool) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.DecCoin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.communityPool) {
          obj.communityPool = message.communityPool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.communityPool = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseFeePool);
        message.communityPool = ((_a = object.communityPool) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseCommunityPoolSpendProposal = { title: "", description: "", recipient: "" };
    exports.CommunityPoolSpendProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCommunityPoolSpendProposal);
        message.amount = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseCommunityPoolSpendProposal);
        message.title = object.title !== void 0 && object.title !== null ? String(object.title) : "";
        message.description = object.description !== void 0 && object.description !== null ? String(object.description) : "";
        message.recipient = object.recipient !== void 0 && object.recipient !== null ? String(object.recipient) : "";
        message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseCommunityPoolSpendProposal);
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.recipient = (_c = object.recipient) !== null && _c !== void 0 ? _c : "";
        message.amount = ((_d = object.amount) === null || _d === void 0 ? void 0 : _d.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseDelegatorStartingInfo = { previousPeriod: long_1.default.UZERO, stake: "", height: long_1.default.UZERO };
    exports.DelegatorStartingInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.previousPeriod.isZero()) {
          writer.uint32(8).uint64(message.previousPeriod);
        }
        if (message.stake !== "") {
          writer.uint32(18).string(message.stake);
        }
        if (!message.height.isZero()) {
          writer.uint32(24).uint64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDelegatorStartingInfo);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.previousPeriod = reader.uint64();
              break;
            case 2:
              message.stake = reader.string();
              break;
            case 3:
              message.height = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDelegatorStartingInfo);
        message.previousPeriod = object.previousPeriod !== void 0 && object.previousPeriod !== null ? long_1.default.fromString(object.previousPeriod) : long_1.default.UZERO;
        message.stake = object.stake !== void 0 && object.stake !== null ? String(object.stake) : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.previousPeriod !== void 0 && (obj.previousPeriod = (message.previousPeriod || long_1.default.UZERO).toString());
        message.stake !== void 0 && (obj.stake = message.stake);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseDelegatorStartingInfo);
        message.previousPeriod = object.previousPeriod !== void 0 && object.previousPeriod !== null ? long_1.default.fromValue(object.previousPeriod) : long_1.default.UZERO;
        message.stake = (_a = object.stake) !== null && _a !== void 0 ? _a : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.UZERO;
        return message;
      }
    };
    var baseDelegationDelegatorReward = { validatorAddress: "" };
    exports.DelegationDelegatorReward = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        for (const v of message.reward) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDelegationDelegatorReward);
        message.reward = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.reward.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseDelegationDelegatorReward);
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        message.reward = ((_a = object.reward) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.DecCoin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.reward) {
          obj.reward = message.reward.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.reward = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseDelegationDelegatorReward);
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        message.reward = ((_b = object.reward) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseCommunityPoolSpendProposalWithDeposit = {
      title: "",
      description: "",
      recipient: "",
      amount: "",
      deposit: ""
    };
    exports.CommunityPoolSpendProposalWithDeposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        if (message.amount !== "") {
          writer.uint32(34).string(message.amount);
        }
        if (message.deposit !== "") {
          writer.uint32(42).string(message.deposit);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCommunityPoolSpendProposalWithDeposit);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            case 5:
              message.deposit = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCommunityPoolSpendProposalWithDeposit);
        message.title = object.title !== void 0 && object.title !== null ? String(object.title) : "";
        message.description = object.description !== void 0 && object.description !== null ? String(object.description) : "";
        message.recipient = object.recipient !== void 0 && object.recipient !== null ? String(object.recipient) : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? String(object.amount) : "";
        message.deposit = object.deposit !== void 0 && object.deposit !== null ? String(object.deposit) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.deposit !== void 0 && (obj.deposit = message.deposit);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseCommunityPoolSpendProposalWithDeposit);
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.recipient = (_c = object.recipient) !== null && _c !== void 0 ? _c : "";
        message.amount = (_d = object.amount) !== null && _d !== void 0 ? _d : "";
        message.deposit = (_e = object.deposit) !== null && _e !== void 0 ? _e : "";
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js
var require_query3 = __commonJS({
  "node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryCommunityPoolResponse = exports.QueryCommunityPoolRequest = exports.QueryDelegatorWithdrawAddressResponse = exports.QueryDelegatorWithdrawAddressRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryDelegationTotalRewardsResponse = exports.QueryDelegationTotalRewardsRequest = exports.QueryDelegationRewardsResponse = exports.QueryDelegationRewardsRequest = exports.QueryValidatorSlashesResponse = exports.QueryValidatorSlashesRequest = exports.QueryValidatorCommissionResponse = exports.QueryValidatorCommissionRequest = exports.QueryValidatorOutstandingRewardsResponse = exports.QueryValidatorOutstandingRewardsRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var distribution_1 = require_distribution();
    var pagination_1 = require_pagination();
    var coin_1 = require_coin();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    var baseQueryParamsRequest = {};
    exports.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      }
    };
    var baseQueryParamsResponse = {};
    exports.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? distribution_1.Params.fromJSON(object.params) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? distribution_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var baseQueryValidatorOutstandingRewardsRequest = { validatorAddress: "" };
    exports.QueryValidatorOutstandingRewardsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorOutstandingRewardsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorOutstandingRewardsRequest);
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorOutstandingRewardsRequest);
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryValidatorOutstandingRewardsResponse = {};
    exports.QueryValidatorOutstandingRewardsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rewards !== void 0) {
          distribution_1.ValidatorOutstandingRewards.encode(message.rewards, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorOutstandingRewardsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards = distribution_1.ValidatorOutstandingRewards.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorOutstandingRewardsResponse);
        message.rewards = object.rewards !== void 0 && object.rewards !== null ? distribution_1.ValidatorOutstandingRewards.fromJSON(object.rewards) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.rewards !== void 0 && (obj.rewards = message.rewards ? distribution_1.ValidatorOutstandingRewards.toJSON(message.rewards) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryValidatorOutstandingRewardsResponse);
        message.rewards = object.rewards !== void 0 && object.rewards !== null ? distribution_1.ValidatorOutstandingRewards.fromPartial(object.rewards) : void 0;
        return message;
      }
    };
    var baseQueryValidatorCommissionRequest = { validatorAddress: "" };
    exports.QueryValidatorCommissionRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorCommissionRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorCommissionRequest);
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorCommissionRequest);
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryValidatorCommissionResponse = {};
    exports.QueryValidatorCommissionResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.commission !== void 0) {
          distribution_1.ValidatorAccumulatedCommission.encode(message.commission, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorCommissionResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission = distribution_1.ValidatorAccumulatedCommission.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorCommissionResponse);
        message.commission = object.commission !== void 0 && object.commission !== null ? distribution_1.ValidatorAccumulatedCommission.fromJSON(object.commission) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.commission !== void 0 && (obj.commission = message.commission ? distribution_1.ValidatorAccumulatedCommission.toJSON(message.commission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryValidatorCommissionResponse);
        message.commission = object.commission !== void 0 && object.commission !== null ? distribution_1.ValidatorAccumulatedCommission.fromPartial(object.commission) : void 0;
        return message;
      }
    };
    var baseQueryValidatorSlashesRequest = {
      validatorAddress: "",
      startingHeight: long_1.default.UZERO,
      endingHeight: long_1.default.UZERO
    };
    exports.QueryValidatorSlashesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        if (!message.startingHeight.isZero()) {
          writer.uint32(16).uint64(message.startingHeight);
        }
        if (!message.endingHeight.isZero()) {
          writer.uint32(24).uint64(message.endingHeight);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorSlashesRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.startingHeight = reader.uint64();
              break;
            case 3:
              message.endingHeight = reader.uint64();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorSlashesRequest);
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        message.startingHeight = object.startingHeight !== void 0 && object.startingHeight !== null ? long_1.default.fromString(object.startingHeight) : long_1.default.UZERO;
        message.endingHeight = object.endingHeight !== void 0 && object.endingHeight !== null ? long_1.default.fromString(object.endingHeight) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.startingHeight !== void 0 && (obj.startingHeight = (message.startingHeight || long_1.default.UZERO).toString());
        message.endingHeight !== void 0 && (obj.endingHeight = (message.endingHeight || long_1.default.UZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorSlashesRequest);
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        message.startingHeight = object.startingHeight !== void 0 && object.startingHeight !== null ? long_1.default.fromValue(object.startingHeight) : long_1.default.UZERO;
        message.endingHeight = object.endingHeight !== void 0 && object.endingHeight !== null ? long_1.default.fromValue(object.endingHeight) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryValidatorSlashesResponse = {};
    exports.QueryValidatorSlashesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.slashes) {
          distribution_1.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorSlashesResponse);
        message.slashes = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.slashes.push(distribution_1.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorSlashesResponse);
        message.slashes = ((_a = object.slashes) !== null && _a !== void 0 ? _a : []).map((e) => distribution_1.ValidatorSlashEvent.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.slashes) {
          obj.slashes = message.slashes.map((e) => e ? distribution_1.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.slashes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorSlashesResponse);
        message.slashes = ((_a = object.slashes) === null || _a === void 0 ? void 0 : _a.map((e) => distribution_1.ValidatorSlashEvent.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDelegationRewardsRequest = { delegatorAddress: "", validatorAddress: "" };
    exports.QueryDelegationRewardsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegationRewardsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegationRewardsRequest);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryDelegationRewardsRequest);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseQueryDelegationRewardsResponse = {};
    exports.QueryDelegationRewardsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegationRewardsResponse);
        message.rewards = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegationRewardsResponse);
        message.rewards = ((_a = object.rewards) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.DecCoin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegationRewardsResponse);
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseQueryDelegationTotalRewardsRequest = { delegatorAddress: "" };
    exports.QueryDelegationTotalRewardsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegationTotalRewardsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegationTotalRewardsRequest);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegationTotalRewardsRequest);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryDelegationTotalRewardsResponse = {};
    exports.QueryDelegationTotalRewardsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
          distribution_1.DelegationDelegatorReward.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.total) {
          coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegationTotalRewardsResponse);
        message.rewards = [];
        message.total = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(distribution_1.DelegationDelegatorReward.decode(reader, reader.uint32()));
              break;
            case 2:
              message.total.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryDelegationTotalRewardsResponse);
        message.rewards = ((_a = object.rewards) !== null && _a !== void 0 ? _a : []).map((e) => distribution_1.DelegationDelegatorReward.fromJSON(e));
        message.total = ((_b = object.total) !== null && _b !== void 0 ? _b : []).map((e) => coin_1.DecCoin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? distribution_1.DelegationDelegatorReward.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryDelegationTotalRewardsResponse);
        message.rewards = ((_a = object.rewards) === null || _a === void 0 ? void 0 : _a.map((e) => distribution_1.DelegationDelegatorReward.fromPartial(e))) || [];
        message.total = ((_b = object.total) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseQueryDelegatorValidatorsRequest = { delegatorAddress: "" };
    exports.QueryDelegatorValidatorsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorValidatorsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegatorValidatorsRequest);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorValidatorsRequest);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryDelegatorValidatorsResponse = { validators: "" };
    exports.QueryDelegatorValidatorsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorValidatorsResponse);
        message.validators = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorValidatorsResponse);
        message.validators = ((_a = object.validators) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e);
        } else {
          obj.validators = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorValidatorsResponse);
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    var baseQueryDelegatorWithdrawAddressRequest = { delegatorAddress: "" };
    exports.QueryDelegatorWithdrawAddressRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorWithdrawAddressRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegatorWithdrawAddressRequest);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorWithdrawAddressRequest);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryDelegatorWithdrawAddressResponse = { withdrawAddress: "" };
    exports.QueryDelegatorWithdrawAddressResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.withdrawAddress !== "") {
          writer.uint32(10).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorWithdrawAddressResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegatorWithdrawAddressResponse);
        message.withdrawAddress = object.withdrawAddress !== void 0 && object.withdrawAddress !== null ? String(object.withdrawAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorWithdrawAddressResponse);
        message.withdrawAddress = (_a = object.withdrawAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryCommunityPoolRequest = {};
    exports.QueryCommunityPoolRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryCommunityPoolRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryCommunityPoolRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryCommunityPoolRequest);
        return message;
      }
    };
    var baseQueryCommunityPoolResponse = {};
    exports.QueryCommunityPoolResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.pool) {
          coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryCommunityPoolResponse);
        message.pool = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryCommunityPoolResponse);
        message.pool = ((_a = object.pool) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.DecCoin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.pool) {
          obj.pool = message.pool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.pool = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryCommunityPoolResponse);
        message.pool = ((_a = object.pool) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this);
        this.ValidatorCommission = this.ValidatorCommission.bind(this);
        this.ValidatorSlashes = this.ValidatorSlashes.bind(this);
        this.DelegationRewards = this.DelegationRewards.bind(this);
        this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this);
        this.CommunityPool = this.CommunityPool.bind(this);
      }
      Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorOutstandingRewards(request) {
        const data = exports.QueryValidatorOutstandingRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", data);
        return promise.then((data2) => exports.QueryValidatorOutstandingRewardsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorCommission(request) {
        const data = exports.QueryValidatorCommissionRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", data);
        return promise.then((data2) => exports.QueryValidatorCommissionResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorSlashes(request) {
        const data = exports.QueryValidatorSlashesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", data);
        return promise.then((data2) => exports.QueryValidatorSlashesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegationRewards(request) {
        const data = exports.QueryDelegationRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", data);
        return promise.then((data2) => exports.QueryDelegationRewardsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegationTotalRewards(request) {
        const data = exports.QueryDelegationTotalRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", data);
        return promise.then((data2) => exports.QueryDelegationTotalRewardsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorValidators(request) {
        const data = exports.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", data);
        return promise.then((data2) => exports.QueryDelegatorValidatorsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorWithdrawAddress(request) {
        const data = exports.QueryDelegatorWithdrawAddressRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", data);
        return promise.then((data2) => exports.QueryDelegatorWithdrawAddressResponse.decode(new minimal_1.default.Reader(data2)));
      }
      CommunityPool(request) {
        const data = exports.QueryCommunityPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", data);
        return promise.then((data2) => exports.QueryCommunityPoolResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/queries/distribution.js
var require_distribution2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/distribution.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupDistributionExtension = void 0;
    var query_1 = require_query3();
    var long_1 = __importDefault(require_long());
    var utils_1 = require_utils2();
    function setupDistributionExtension(base) {
      const rpc = (0, utils_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        distribution: {
          communityPool: async () => {
            const response = await queryService.CommunityPool({});
            return response;
          },
          delegationRewards: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegationRewards({
              delegatorAddress,
              validatorAddress
            });
            return response;
          },
          delegationTotalRewards: async (delegatorAddress) => {
            const response = await queryService.DelegationTotalRewards({
              delegatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddress
            });
            return response;
          },
          delegatorWithdrawAddress: async (delegatorAddress) => {
            const response = await queryService.DelegatorWithdrawAddress({
              delegatorAddress
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          validatorCommission: async (validatorAddress) => {
            const response = await queryService.ValidatorCommission({
              validatorAddress
            });
            return response;
          },
          validatorOutstandingRewards: async (validatorAddress) => {
            const response = await queryService.ValidatorOutstandingRewards({
              validatorAddress
            });
            return response;
          },
          validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey) => {
            const response = await queryService.ValidatorSlashes({
              validatorAddress,
              startingHeight: long_1.default.fromNumber(startingHeight, true),
              endingHeight: long_1.default.fromNumber(endingHeight, true),
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports.setupDistributionExtension = setupDistributionExtension;
  }
});

// node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js
var require_query4 = __commonJS({
  "node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryTallyResultResponse = exports.QueryTallyResultRequest = exports.QueryDepositsResponse = exports.QueryDepositsRequest = exports.QueryDepositResponse = exports.QueryDepositRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryVotesResponse = exports.QueryVotesRequest = exports.QueryVoteResponse = exports.QueryVoteRequest = exports.QueryProposalsResponse = exports.QueryProposalsRequest = exports.QueryProposalResponse = exports.QueryProposalRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var gov_1 = require_gov();
    var pagination_1 = require_pagination();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    var baseQueryProposalRequest = { proposalId: long_1.default.UZERO };
    exports.QueryProposalRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryProposalRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryProposalRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryProposalRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        return message;
      }
    };
    var baseQueryProposalResponse = {};
    exports.QueryProposalResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposal !== void 0) {
          gov_1.Proposal.encode(message.proposal, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryProposalResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposal = gov_1.Proposal.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryProposalResponse);
        message.proposal = object.proposal !== void 0 && object.proposal !== null ? gov_1.Proposal.fromJSON(object.proposal) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposal !== void 0 && (obj.proposal = message.proposal ? gov_1.Proposal.toJSON(message.proposal) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryProposalResponse);
        message.proposal = object.proposal !== void 0 && object.proposal !== null ? gov_1.Proposal.fromPartial(object.proposal) : void 0;
        return message;
      }
    };
    var baseQueryProposalsRequest = { proposalStatus: 0, voter: "", depositor: "" };
    exports.QueryProposalsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proposalStatus !== 0) {
          writer.uint32(8).int32(message.proposalStatus);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.depositor !== "") {
          writer.uint32(26).string(message.depositor);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryProposalsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalStatus = reader.int32();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.depositor = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryProposalsRequest);
        message.proposalStatus = object.proposalStatus !== void 0 && object.proposalStatus !== null ? gov_1.proposalStatusFromJSON(object.proposalStatus) : 0;
        message.voter = object.voter !== void 0 && object.voter !== null ? String(object.voter) : "";
        message.depositor = object.depositor !== void 0 && object.depositor !== null ? String(object.depositor) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalStatus !== void 0 && (obj.proposalStatus = gov_1.proposalStatusToJSON(message.proposalStatus));
        message.voter !== void 0 && (obj.voter = message.voter);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseQueryProposalsRequest);
        message.proposalStatus = (_a = object.proposalStatus) !== null && _a !== void 0 ? _a : 0;
        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : "";
        message.depositor = (_c = object.depositor) !== null && _c !== void 0 ? _c : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryProposalsResponse = {};
    exports.QueryProposalsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.proposals) {
          gov_1.Proposal.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryProposalsResponse);
        message.proposals = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposals.push(gov_1.Proposal.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryProposalsResponse);
        message.proposals = ((_a = object.proposals) !== null && _a !== void 0 ? _a : []).map((e) => gov_1.Proposal.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.proposals) {
          obj.proposals = message.proposals.map((e) => e ? gov_1.Proposal.toJSON(e) : void 0);
        } else {
          obj.proposals = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryProposalsResponse);
        message.proposals = ((_a = object.proposals) === null || _a === void 0 ? void 0 : _a.map((e) => gov_1.Proposal.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryVoteRequest = { proposalId: long_1.default.UZERO, voter: "" };
    exports.QueryVoteRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryVoteRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryVoteRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.voter = object.voter !== void 0 && object.voter !== null ? String(object.voter) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryVoteRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.voter = (_a = object.voter) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryVoteResponse = {};
    exports.QueryVoteResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.vote !== void 0) {
          gov_1.Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryVoteResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vote = gov_1.Vote.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryVoteResponse);
        message.vote = object.vote !== void 0 && object.vote !== null ? gov_1.Vote.fromJSON(object.vote) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.vote !== void 0 && (obj.vote = message.vote ? gov_1.Vote.toJSON(message.vote) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryVoteResponse);
        message.vote = object.vote !== void 0 && object.vote !== null ? gov_1.Vote.fromPartial(object.vote) : void 0;
        return message;
      }
    };
    var baseQueryVotesRequest = { proposalId: long_1.default.UZERO };
    exports.QueryVotesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryVotesRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryVotesRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryVotesRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryVotesResponse = {};
    exports.QueryVotesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.votes) {
          gov_1.Vote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryVotesResponse);
        message.votes = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votes.push(gov_1.Vote.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryVotesResponse);
        message.votes = ((_a = object.votes) !== null && _a !== void 0 ? _a : []).map((e) => gov_1.Vote.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? gov_1.Vote.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryVotesResponse);
        message.votes = ((_a = object.votes) === null || _a === void 0 ? void 0 : _a.map((e) => gov_1.Vote.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryParamsRequest = { paramsType: "" };
    exports.QueryParamsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.paramsType !== "") {
          writer.uint32(10).string(message.paramsType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paramsType = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsRequest);
        message.paramsType = object.paramsType !== void 0 && object.paramsType !== null ? String(object.paramsType) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.paramsType !== void 0 && (obj.paramsType = message.paramsType);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryParamsRequest);
        message.paramsType = (_a = object.paramsType) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryParamsResponse = {};
    exports.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.votingParams !== void 0) {
          gov_1.VotingParams.encode(message.votingParams, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositParams !== void 0) {
          gov_1.DepositParams.encode(message.depositParams, writer.uint32(18).fork()).ldelim();
        }
        if (message.tallyParams !== void 0) {
          gov_1.TallyParams.encode(message.tallyParams, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingParams = gov_1.VotingParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.depositParams = gov_1.DepositParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.tallyParams = gov_1.TallyParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.votingParams = object.votingParams !== void 0 && object.votingParams !== null ? gov_1.VotingParams.fromJSON(object.votingParams) : void 0;
        message.depositParams = object.depositParams !== void 0 && object.depositParams !== null ? gov_1.DepositParams.fromJSON(object.depositParams) : void 0;
        message.tallyParams = object.tallyParams !== void 0 && object.tallyParams !== null ? gov_1.TallyParams.fromJSON(object.tallyParams) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.votingParams !== void 0 && (obj.votingParams = message.votingParams ? gov_1.VotingParams.toJSON(message.votingParams) : void 0);
        message.depositParams !== void 0 && (obj.depositParams = message.depositParams ? gov_1.DepositParams.toJSON(message.depositParams) : void 0);
        message.tallyParams !== void 0 && (obj.tallyParams = message.tallyParams ? gov_1.TallyParams.toJSON(message.tallyParams) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.votingParams = object.votingParams !== void 0 && object.votingParams !== null ? gov_1.VotingParams.fromPartial(object.votingParams) : void 0;
        message.depositParams = object.depositParams !== void 0 && object.depositParams !== null ? gov_1.DepositParams.fromPartial(object.depositParams) : void 0;
        message.tallyParams = object.tallyParams !== void 0 && object.tallyParams !== null ? gov_1.TallyParams.fromPartial(object.tallyParams) : void 0;
        return message;
      }
    };
    var baseQueryDepositRequest = { proposalId: long_1.default.UZERO, depositor: "" };
    exports.QueryDepositRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDepositRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDepositRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.depositor = object.depositor !== void 0 && object.depositor !== null ? String(object.depositor) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDepositRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.depositor = (_a = object.depositor) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryDepositResponse = {};
    exports.QueryDepositResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.deposit !== void 0) {
          gov_1.Deposit.encode(message.deposit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDepositResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit = gov_1.Deposit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDepositResponse);
        message.deposit = object.deposit !== void 0 && object.deposit !== null ? gov_1.Deposit.fromJSON(object.deposit) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.deposit !== void 0 && (obj.deposit = message.deposit ? gov_1.Deposit.toJSON(message.deposit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryDepositResponse);
        message.deposit = object.deposit !== void 0 && object.deposit !== null ? gov_1.Deposit.fromPartial(object.deposit) : void 0;
        return message;
      }
    };
    var baseQueryDepositsRequest = { proposalId: long_1.default.UZERO };
    exports.QueryDepositsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDepositsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDepositsRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryDepositsRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDepositsResponse = {};
    exports.QueryDepositsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.deposits) {
          gov_1.Deposit.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDepositsResponse);
        message.deposits = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposits.push(gov_1.Deposit.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryDepositsResponse);
        message.deposits = ((_a = object.deposits) !== null && _a !== void 0 ? _a : []).map((e) => gov_1.Deposit.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.deposits) {
          obj.deposits = message.deposits.map((e) => e ? gov_1.Deposit.toJSON(e) : void 0);
        } else {
          obj.deposits = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDepositsResponse);
        message.deposits = ((_a = object.deposits) === null || _a === void 0 ? void 0 : _a.map((e) => gov_1.Deposit.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryTallyResultRequest = { proposalId: long_1.default.UZERO };
    exports.QueryTallyResultRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTallyResultRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryTallyResultRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryTallyResultRequest);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        return message;
      }
    };
    var baseQueryTallyResultResponse = {};
    exports.QueryTallyResultResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tally !== void 0) {
          gov_1.TallyResult.encode(message.tally, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTallyResultResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tally = gov_1.TallyResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryTallyResultResponse);
        message.tally = object.tally !== void 0 && object.tally !== null ? gov_1.TallyResult.fromJSON(object.tally) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.tally !== void 0 && (obj.tally = message.tally ? gov_1.TallyResult.toJSON(message.tally) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryTallyResultResponse);
        message.tally = object.tally !== void 0 && object.tally !== null ? gov_1.TallyResult.fromPartial(object.tally) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Proposal = this.Proposal.bind(this);
        this.Proposals = this.Proposals.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Votes = this.Votes.bind(this);
        this.Params = this.Params.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.Deposits = this.Deposits.bind(this);
        this.TallyResult = this.TallyResult.bind(this);
      }
      Proposal(request) {
        const data = exports.QueryProposalRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", data);
        return promise.then((data2) => exports.QueryProposalResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Proposals(request) {
        const data = exports.QueryProposalsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", data);
        return promise.then((data2) => exports.QueryProposalsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Vote(request) {
        const data = exports.QueryVoteRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", data);
        return promise.then((data2) => exports.QueryVoteResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Votes(request) {
        const data = exports.QueryVotesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", data);
        return promise.then((data2) => exports.QueryVotesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Deposit(request) {
        const data = exports.QueryDepositRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", data);
        return promise.then((data2) => exports.QueryDepositResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Deposits(request) {
        const data = exports.QueryDepositsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", data);
        return promise.then((data2) => exports.QueryDepositsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      TallyResult(request) {
        const data = exports.QueryTallyResultRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", data);
        return promise.then((data2) => exports.QueryTallyResultResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/queries/gov.js
var require_gov2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/gov.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupGovExtension = void 0;
    var query_1 = require_query4();
    var utils_1 = require_utils2();
    function setupGovExtension(base) {
      const rpc = (0, utils_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        gov: {
          params: async (parametersType) => {
            const response = await queryService.Params({ paramsType: parametersType });
            return response;
          },
          proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey) => {
            const response = await queryService.Proposals({
              proposalStatus,
              depositor: depositorAddress,
              voter: voterAddress,
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          proposal: async (proposalId) => {
            const response = await queryService.Proposal({ proposalId: (0, utils_1.longify)(proposalId) });
            return response;
          },
          deposits: async (proposalId, paginationKey) => {
            const response = await queryService.Deposits({
              proposalId: (0, utils_1.longify)(proposalId),
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          deposit: async (proposalId, depositorAddress) => {
            const response = await queryService.Deposit({
              proposalId: (0, utils_1.longify)(proposalId),
              depositor: depositorAddress
            });
            return response;
          },
          tally: async (proposalId) => {
            const response = await queryService.TallyResult({
              proposalId: (0, utils_1.longify)(proposalId)
            });
            return response;
          },
          votes: async (proposalId, paginationKey) => {
            const response = await queryService.Votes({
              proposalId: (0, utils_1.longify)(proposalId),
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          vote: async (proposalId, voterAddress) => {
            const response = await queryService.Vote({
              proposalId: (0, utils_1.longify)(proposalId),
              voter: voterAddress
            });
            return response;
          }
        }
      };
    }
    exports.setupGovExtension = setupGovExtension;
  }
});

// node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js
var require_transfer = __commonJS({
  "node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.DenomTrace = exports.FungibleTokenPacketData = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "ibc.applications.transfer.v1";
    var baseFungibleTokenPacketData = { denom: "", amount: long_1.default.UZERO, sender: "", receiver: "" };
    exports.FungibleTokenPacketData = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (!message.amount.isZero()) {
          writer.uint32(16).uint64(message.amount);
        }
        if (message.sender !== "") {
          writer.uint32(26).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(34).string(message.receiver);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseFungibleTokenPacketData);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.uint64();
              break;
            case 3:
              message.sender = reader.string();
              break;
            case 4:
              message.receiver = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseFungibleTokenPacketData);
        message.denom = object.denom !== void 0 && object.denom !== null ? String(object.denom) : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? long_1.default.fromString(object.amount) : long_1.default.UZERO;
        message.sender = object.sender !== void 0 && object.sender !== null ? String(object.sender) : "";
        message.receiver = object.receiver !== void 0 && object.receiver !== null ? String(object.receiver) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = (message.amount || long_1.default.UZERO).toString());
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseFungibleTokenPacketData);
        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? long_1.default.fromValue(object.amount) : long_1.default.UZERO;
        message.sender = (_b = object.sender) !== null && _b !== void 0 ? _b : "";
        message.receiver = (_c = object.receiver) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseDenomTrace = { path: "", baseDenom: "" };
    exports.DenomTrace = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.path !== "") {
          writer.uint32(10).string(message.path);
        }
        if (message.baseDenom !== "") {
          writer.uint32(18).string(message.baseDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDenomTrace);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.path = reader.string();
              break;
            case 2:
              message.baseDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDenomTrace);
        message.path = object.path !== void 0 && object.path !== null ? String(object.path) : "";
        message.baseDenom = object.baseDenom !== void 0 && object.baseDenom !== null ? String(object.baseDenom) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.path !== void 0 && (obj.path = message.path);
        message.baseDenom !== void 0 && (obj.baseDenom = message.baseDenom);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseDenomTrace);
        message.path = (_a = object.path) !== null && _a !== void 0 ? _a : "";
        message.baseDenom = (_b = object.baseDenom) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseParams = { sendEnabled: false, receiveEnabled: false };
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sendEnabled === true) {
          writer.uint32(8).bool(message.sendEnabled);
        }
        if (message.receiveEnabled === true) {
          writer.uint32(16).bool(message.receiveEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled = reader.bool();
              break;
            case 2:
              message.receiveEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseParams);
        message.sendEnabled = object.sendEnabled !== void 0 && object.sendEnabled !== null ? Boolean(object.sendEnabled) : false;
        message.receiveEnabled = object.receiveEnabled !== void 0 && object.receiveEnabled !== null ? Boolean(object.receiveEnabled) : false;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.sendEnabled !== void 0 && (obj.sendEnabled = message.sendEnabled);
        message.receiveEnabled !== void 0 && (obj.receiveEnabled = message.receiveEnabled);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseParams);
        message.sendEnabled = (_a = object.sendEnabled) !== null && _a !== void 0 ? _a : false;
        message.receiveEnabled = (_b = object.receiveEnabled) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js
var require_query5 = __commonJS({
  "node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryDenomTracesResponse = exports.QueryDenomTracesRequest = exports.QueryDenomTraceResponse = exports.QueryDenomTraceRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var transfer_1 = require_transfer();
    var pagination_1 = require_pagination();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    var baseQueryDenomTraceRequest = { hash: "" };
    exports.QueryDenomTraceRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDenomTraceRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDenomTraceRequest);
        message.hash = object.hash !== void 0 && object.hash !== null ? String(object.hash) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDenomTraceRequest);
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryDenomTraceResponse = {};
    exports.QueryDenomTraceResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denomTrace !== void 0) {
          transfer_1.DenomTrace.encode(message.denomTrace, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDenomTraceResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTrace = transfer_1.DenomTrace.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDenomTraceResponse);
        message.denomTrace = object.denomTrace !== void 0 && object.denomTrace !== null ? transfer_1.DenomTrace.fromJSON(object.denomTrace) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.denomTrace !== void 0 && (obj.denomTrace = message.denomTrace ? transfer_1.DenomTrace.toJSON(message.denomTrace) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryDenomTraceResponse);
        message.denomTrace = object.denomTrace !== void 0 && object.denomTrace !== null ? transfer_1.DenomTrace.fromPartial(object.denomTrace) : void 0;
        return message;
      }
    };
    var baseQueryDenomTracesRequest = {};
    exports.QueryDenomTracesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDenomTracesRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDenomTracesRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryDenomTracesRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDenomTracesResponse = {};
    exports.QueryDenomTracesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.denomTraces) {
          transfer_1.DenomTrace.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDenomTracesResponse);
        message.denomTraces = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTraces.push(transfer_1.DenomTrace.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryDenomTracesResponse);
        message.denomTraces = ((_a = object.denomTraces) !== null && _a !== void 0 ? _a : []).map((e) => transfer_1.DenomTrace.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomTraces) {
          obj.denomTraces = message.denomTraces.map((e) => e ? transfer_1.DenomTrace.toJSON(e) : void 0);
        } else {
          obj.denomTraces = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDenomTracesResponse);
        message.denomTraces = ((_a = object.denomTraces) === null || _a === void 0 ? void 0 : _a.map((e) => transfer_1.DenomTrace.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryParamsRequest = {};
    exports.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      }
    };
    var baseQueryParamsResponse = {};
    exports.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          transfer_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = transfer_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? transfer_1.Params.fromJSON(object.params) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? transfer_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? transfer_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.DenomTrace = this.DenomTrace.bind(this);
        this.DenomTraces = this.DenomTraces.bind(this);
        this.Params = this.Params.bind(this);
      }
      DenomTrace(request) {
        const data = exports.QueryDenomTraceRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", data);
        return promise.then((data2) => exports.QueryDenomTraceResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DenomTraces(request) {
        const data = exports.QueryDenomTracesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", data);
        return promise.then((data2) => exports.QueryDenomTracesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "Params", data);
        return promise.then((data2) => exports.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/client/v1/client.js
var require_client = __commonJS({
  "node_modules/cosmjs-types/ibc/core/client/v1/client.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Height = exports.ClientUpdateProposal = exports.ClientConsensusStates = exports.ConsensusStateWithHeight = exports.IdentifiedClientState = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    exports.protobufPackage = "ibc.core.client.v1";
    var baseIdentifiedClientState = { clientId: "" };
    exports.IdentifiedClientState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseIdentifiedClientState);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseIdentifiedClientState);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromJSON(object.clientState) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseIdentifiedClientState);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        return message;
      }
    };
    var baseConsensusStateWithHeight = {};
    exports.ConsensusStateWithHeight = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.height !== void 0) {
          exports.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConsensusStateWithHeight);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = exports.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseConsensusStateWithHeight);
        message.height = object.height !== void 0 && object.height !== null ? exports.Height.fromJSON(object.height) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromJSON(object.consensusState) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? exports.Height.toJSON(message.height) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseConsensusStateWithHeight);
        message.height = object.height !== void 0 && object.height !== null ? exports.Height.fromPartial(object.height) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        return message;
      }
    };
    var baseClientConsensusStates = { clientId: "" };
    exports.ClientConsensusStates = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.consensusStates) {
          exports.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientConsensusStates);
        message.consensusStates = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.consensusStates.push(exports.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseClientConsensusStates);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.consensusStates = ((_a = object.consensusStates) !== null && _a !== void 0 ? _a : []).map((e) => exports.ConsensusStateWithHeight.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? exports.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseClientConsensusStates);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.consensusStates = ((_b = object.consensusStates) === null || _b === void 0 ? void 0 : _b.map((e) => exports.ConsensusStateWithHeight.fromPartial(e))) || [];
        return message;
      }
    };
    var baseClientUpdateProposal = { title: "", description: "", clientId: "" };
    exports.ClientUpdateProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.clientId !== "") {
          writer.uint32(26).string(message.clientId);
        }
        if (message.header !== void 0) {
          any_1.Any.encode(message.header, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientUpdateProposal);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.clientId = reader.string();
              break;
            case 4:
              message.header = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseClientUpdateProposal);
        message.title = object.title !== void 0 && object.title !== null ? String(object.title) : "";
        message.description = object.description !== void 0 && object.description !== null ? String(object.description) : "";
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.header = object.header !== void 0 && object.header !== null ? any_1.Any.fromJSON(object.header) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header !== void 0 && (obj.header = message.header ? any_1.Any.toJSON(message.header) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseClientUpdateProposal);
        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : "";
        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : "";
        message.clientId = (_c = object.clientId) !== null && _c !== void 0 ? _c : "";
        message.header = object.header !== void 0 && object.header !== null ? any_1.Any.fromPartial(object.header) : void 0;
        return message;
      }
    };
    var baseHeight = { revisionNumber: long_1.default.UZERO, revisionHeight: long_1.default.UZERO };
    exports.Height = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.revisionNumber.isZero()) {
          writer.uint32(8).uint64(message.revisionNumber);
        }
        if (!message.revisionHeight.isZero()) {
          writer.uint32(16).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHeight);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.revisionNumber = reader.uint64();
              break;
            case 2:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseHeight);
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromString(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromString(object.revisionHeight) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseHeight);
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO;
        return message;
      }
    };
    var baseParams = { allowedClients: "" };
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.allowedClients) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParams);
        message.allowedClients = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowedClients.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseParams);
        message.allowedClients = ((_a = object.allowedClients) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowedClients) {
          obj.allowedClients = message.allowedClients.map((e) => e);
        } else {
          obj.allowedClients = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseParams);
        message.allowedClients = ((_a = object.allowedClients) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/channel/v1/channel.js
var require_channel = __commonJS({
  "node_modules/cosmjs-types/ibc/core/channel/v1/channel.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Acknowledgement = exports.PacketState = exports.Packet = exports.Counterparty = exports.IdentifiedChannel = exports.Channel = exports.orderToJSON = exports.orderFromJSON = exports.Order = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var client_1 = require_client();
    exports.protobufPackage = "ibc.core.channel.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["STATE_CLOSED"] = 4] = "STATE_CLOSED";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State = exports.State || (exports.State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
          return State.STATE_CLOSED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.STATE_CLOSED:
          return "STATE_CLOSED";
        default:
          return "UNKNOWN";
      }
    }
    exports.stateToJSON = stateToJSON;
    var Order;
    (function(Order2) {
      Order2[Order2["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
      Order2[Order2["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
      Order2[Order2["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
      Order2[Order2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Order = exports.Order || (exports.Order = {}));
    function orderFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
          return Order.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
          return Order.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
          return Order.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Order.UNRECOGNIZED;
      }
    }
    exports.orderFromJSON = orderFromJSON;
    function orderToJSON(object) {
      switch (object) {
        case Order.ORDER_NONE_UNSPECIFIED:
          return "ORDER_NONE_UNSPECIFIED";
        case Order.ORDER_UNORDERED:
          return "ORDER_UNORDERED";
        case Order.ORDER_ORDERED:
          return "ORDER_ORDERED";
        default:
          return "UNKNOWN";
      }
    }
    exports.orderToJSON = orderToJSON;
    var baseChannel = { state: 0, ordering: 0, connectionHops: "", version: "" };
    exports.Channel = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseChannel);
        message.connectionHops = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseChannel);
        message.state = object.state !== void 0 && object.state !== null ? stateFromJSON(object.state) : 0;
        message.ordering = object.ordering !== void 0 && object.ordering !== null ? orderFromJSON(object.ordering) : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports.Counterparty.fromJSON(object.counterparty) : void 0;
        message.connectionHops = ((_a = object.connectionHops) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        message.version = object.version !== void 0 && object.version !== null ? String(object.version) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseChannel);
        message.state = (_a = object.state) !== null && _a !== void 0 ? _a : 0;
        message.ordering = (_b = object.ordering) !== null && _b !== void 0 ? _b : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports.Counterparty.fromPartial(object.counterparty) : void 0;
        message.connectionHops = ((_c = object.connectionHops) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    var baseIdentifiedChannel = {
      state: 0,
      ordering: 0,
      connectionHops: "",
      version: "",
      portId: "",
      channelId: ""
    };
    exports.IdentifiedChannel = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.connectionHops) {
          writer.uint32(34).string(v);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.portId !== "") {
          writer.uint32(50).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(58).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseIdentifiedChannel);
        message.connectionHops = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.portId = reader.string();
              break;
            case 7:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseIdentifiedChannel);
        message.state = object.state !== void 0 && object.state !== null ? stateFromJSON(object.state) : 0;
        message.ordering = object.ordering !== void 0 && object.ordering !== null ? orderFromJSON(object.ordering) : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports.Counterparty.fromJSON(object.counterparty) : void 0;
        message.connectionHops = ((_a = object.connectionHops) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        message.version = object.version !== void 0 && object.version !== null ? String(object.version) : "";
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = Object.assign({}, baseIdentifiedChannel);
        message.state = (_a = object.state) !== null && _a !== void 0 ? _a : 0;
        message.ordering = (_b = object.ordering) !== null && _b !== void 0 ? _b : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports.Counterparty.fromPartial(object.counterparty) : void 0;
        message.connectionHops = ((_c = object.connectionHops) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.version = (_d = object.version) !== null && _d !== void 0 ? _d : "";
        message.portId = (_e = object.portId) !== null && _e !== void 0 ? _e : "";
        message.channelId = (_f = object.channelId) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    var baseCounterparty = { portId: "", channelId: "" };
    exports.Counterparty = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCounterparty);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCounterparty);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseCounterparty);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var basePacket = {
      sequence: long_1.default.UZERO,
      sourcePort: "",
      sourceChannel: "",
      destinationPort: "",
      destinationChannel: "",
      timeoutTimestamp: long_1.default.UZERO
    };
    exports.Packet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.sequence.isZero()) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.sourcePort !== "") {
          writer.uint32(18).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(26).string(message.sourceChannel);
        }
        if (message.destinationPort !== "") {
          writer.uint32(34).string(message.destinationPort);
        }
        if (message.destinationChannel !== "") {
          writer.uint32(42).string(message.destinationChannel);
        }
        if (message.data.length !== 0) {
          writer.uint32(50).bytes(message.data);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(58).fork()).ldelim();
        }
        if (!message.timeoutTimestamp.isZero()) {
          writer.uint32(64).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePacket);
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.sourcePort = reader.string();
              break;
            case 3:
              message.sourceChannel = reader.string();
              break;
            case 4:
              message.destinationPort = reader.string();
              break;
            case 5:
              message.destinationChannel = reader.string();
              break;
            case 6:
              message.data = reader.bytes();
              break;
            case 7:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.timeoutTimestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePacket);
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;
        message.sourcePort = object.sourcePort !== void 0 && object.sourcePort !== null ? String(object.sourcePort) : "";
        message.sourceChannel = object.sourceChannel !== void 0 && object.sourceChannel !== null ? String(object.sourceChannel) : "";
        message.destinationPort = object.destinationPort !== void 0 && object.destinationPort !== null ? String(object.destinationPort) : "";
        message.destinationChannel = object.destinationChannel !== void 0 && object.destinationChannel !== null ? String(object.destinationChannel) : "";
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? client_1.Height.fromJSON(object.timeoutHeight) : void 0;
        message.timeoutTimestamp = object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null ? long_1.default.fromString(object.timeoutTimestamp) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.destinationPort !== void 0 && (obj.destinationPort = message.destinationPort);
        message.destinationChannel !== void 0 && (obj.destinationChannel = message.destinationChannel);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, basePacket);
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        message.sourcePort = (_a = object.sourcePort) !== null && _a !== void 0 ? _a : "";
        message.sourceChannel = (_b = object.sourceChannel) !== null && _b !== void 0 ? _b : "";
        message.destinationPort = (_c = object.destinationPort) !== null && _c !== void 0 ? _c : "";
        message.destinationChannel = (_d = object.destinationChannel) !== null && _d !== void 0 ? _d : "";
        message.data = (_e = object.data) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? client_1.Height.fromPartial(object.timeoutHeight) : void 0;
        message.timeoutTimestamp = object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null ? long_1.default.fromValue(object.timeoutTimestamp) : long_1.default.UZERO;
        return message;
      }
    };
    var basePacketState = { portId: "", channelId: "", sequence: long_1.default.UZERO };
    exports.PacketState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        if (message.data.length !== 0) {
          writer.uint32(34).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePacketState);
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            case 4:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePacketState);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, basePacketState);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var baseAcknowledgement = {};
    exports.Acknowledgement = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== void 0) {
          writer.uint32(170).bytes(message.result);
        }
        if (message.error !== void 0) {
          writer.uint32(178).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAcknowledgement);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 21:
              message.result = reader.bytes();
              break;
            case 22:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseAcknowledgement);
        message.result = object.result !== void 0 && object.result !== null ? bytesFromBase64(object.result) : void 0;
        message.error = object.error !== void 0 && object.error !== null ? String(object.error) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = message.result !== void 0 ? base64FromBytes(message.result) : void 0);
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseAcknowledgement);
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : void 0;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/channel/v1/query.js
var require_query6 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/channel/v1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryNextSequenceReceiveResponse = exports.QueryNextSequenceReceiveRequest = exports.QueryUnreceivedAcksResponse = exports.QueryUnreceivedAcksRequest = exports.QueryUnreceivedPacketsResponse = exports.QueryUnreceivedPacketsRequest = exports.QueryPacketAcknowledgementsResponse = exports.QueryPacketAcknowledgementsRequest = exports.QueryPacketAcknowledgementResponse = exports.QueryPacketAcknowledgementRequest = exports.QueryPacketReceiptResponse = exports.QueryPacketReceiptRequest = exports.QueryPacketCommitmentsResponse = exports.QueryPacketCommitmentsRequest = exports.QueryPacketCommitmentResponse = exports.QueryPacketCommitmentRequest = exports.QueryChannelConsensusStateResponse = exports.QueryChannelConsensusStateRequest = exports.QueryChannelClientStateResponse = exports.QueryChannelClientStateRequest = exports.QueryConnectionChannelsResponse = exports.QueryConnectionChannelsRequest = exports.QueryChannelsResponse = exports.QueryChannelsRequest = exports.QueryChannelResponse = exports.QueryChannelRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var channel_1 = require_channel();
    var client_1 = require_client();
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    exports.protobufPackage = "ibc.core.channel.v1";
    var baseQueryChannelRequest = { portId: "", channelId: "" };
    exports.QueryChannelRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryChannelRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryChannelRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryChannelRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseQueryChannelResponse = {};
    exports.QueryChannelResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryChannelResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryChannelResponse);
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromJSON(object.channel) : void 0;
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryChannelResponse);
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryChannelsRequest = {};
    exports.QueryChannelsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryChannelsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryChannelsRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryChannelsRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryChannelsResponse = {};
    exports.QueryChannelsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryChannelsResponse);
        message.channels = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryChannelsResponse);
        message.channels = ((_a = object.channels) !== null && _a !== void 0 ? _a : []).map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromJSON(object.height) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryChannelsResponse);
        message.channels = ((_a = object.channels) === null || _a === void 0 ? void 0 : _a.map((e) => channel_1.IdentifiedChannel.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    var baseQueryConnectionChannelsRequest = { connection: "" };
    exports.QueryConnectionChannelsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connection !== "") {
          writer.uint32(10).string(message.connection);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionChannelsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConnectionChannelsRequest);
        message.connection = object.connection !== void 0 && object.connection !== null ? String(object.connection) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionChannelsRequest);
        message.connection = (_a = object.connection) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryConnectionChannelsResponse = {};
    exports.QueryConnectionChannelsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.channels) {
          channel_1.IdentifiedChannel.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionChannelsResponse);
        message.channels = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionChannelsResponse);
        message.channels = ((_a = object.channels) !== null && _a !== void 0 ? _a : []).map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromJSON(object.height) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionChannelsResponse);
        message.channels = ((_a = object.channels) === null || _a === void 0 ? void 0 : _a.map((e) => channel_1.IdentifiedChannel.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    var baseQueryChannelClientStateRequest = { portId: "", channelId: "" };
    exports.QueryChannelClientStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryChannelClientStateRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryChannelClientStateRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryChannelClientStateRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseQueryChannelClientStateResponse = {};
    exports.QueryChannelClientStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryChannelClientStateResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryChannelClientStateResponse);
        message.identifiedClientState = object.identifiedClientState !== void 0 && object.identifiedClientState !== null ? client_1.IdentifiedClientState.fromJSON(object.identifiedClientState) : void 0;
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryChannelClientStateResponse);
        message.identifiedClientState = object.identifiedClientState !== void 0 && object.identifiedClientState !== null ? client_1.IdentifiedClientState.fromPartial(object.identifiedClientState) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryChannelConsensusStateRequest = {
      portId: "",
      channelId: "",
      revisionNumber: long_1.default.UZERO,
      revisionHeight: long_1.default.UZERO
    };
    exports.QueryChannelConsensusStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.revisionNumber.isZero()) {
          writer.uint32(24).uint64(message.revisionNumber);
        }
        if (!message.revisionHeight.isZero()) {
          writer.uint32(32).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryChannelConsensusStateRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.revisionNumber = reader.uint64();
              break;
            case 4:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryChannelConsensusStateRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromString(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromString(object.revisionHeight) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryChannelConsensusStateRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO;
        return message;
      }
    };
    var baseQueryChannelConsensusStateResponse = { clientId: "" };
    exports.QueryChannelConsensusStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryChannelConsensusStateResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryChannelConsensusStateResponse);
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromJSON(object.consensusState) : void 0;
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryChannelConsensusStateResponse);
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryPacketCommitmentRequest = { portId: "", channelId: "", sequence: long_1.default.UZERO };
    exports.QueryPacketCommitmentRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketCommitmentRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPacketCommitmentRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryPacketCommitmentRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    var baseQueryPacketCommitmentResponse = {};
    exports.QueryPacketCommitmentResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.commitment.length !== 0) {
          writer.uint32(10).bytes(message.commitment);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketCommitmentResponse);
        message.commitment = new Uint8Array();
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitment = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPacketCommitmentResponse);
        message.commitment = object.commitment !== void 0 && object.commitment !== null ? bytesFromBase64(object.commitment) : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.commitment !== void 0 && (obj.commitment = base64FromBytes(message.commitment !== void 0 ? message.commitment : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryPacketCommitmentResponse);
        message.commitment = (_a = object.commitment) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryPacketCommitmentsRequest = { portId: "", channelId: "" };
    exports.QueryPacketCommitmentsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketCommitmentsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPacketCommitmentsRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryPacketCommitmentsRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryPacketCommitmentsResponse = {};
    exports.QueryPacketCommitmentsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.commitments) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketCommitmentsResponse);
        message.commitments = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitments.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryPacketCommitmentsResponse);
        message.commitments = ((_a = object.commitments) !== null && _a !== void 0 ? _a : []).map((e) => channel_1.PacketState.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromJSON(object.height) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.commitments) {
          obj.commitments = message.commitments.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.commitments = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryPacketCommitmentsResponse);
        message.commitments = ((_a = object.commitments) === null || _a === void 0 ? void 0 : _a.map((e) => channel_1.PacketState.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    var baseQueryPacketReceiptRequest = { portId: "", channelId: "", sequence: long_1.default.UZERO };
    exports.QueryPacketReceiptRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketReceiptRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPacketReceiptRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryPacketReceiptRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    var baseQueryPacketReceiptResponse = { received: false };
    exports.QueryPacketReceiptResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.received === true) {
          writer.uint32(16).bool(message.received);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketReceiptResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.received = reader.bool();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPacketReceiptResponse);
        message.received = object.received !== void 0 && object.received !== null ? Boolean(object.received) : false;
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.received !== void 0 && (obj.received = message.received);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryPacketReceiptResponse);
        message.received = (_a = object.received) !== null && _a !== void 0 ? _a : false;
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryPacketAcknowledgementRequest = { portId: "", channelId: "", sequence: long_1.default.UZERO };
    exports.QueryPacketAcknowledgementRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (!message.sequence.isZero()) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketAcknowledgementRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPacketAcknowledgementRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromString(object.sequence) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryPacketAcknowledgementRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.sequence = object.sequence !== void 0 && object.sequence !== null ? long_1.default.fromValue(object.sequence) : long_1.default.UZERO;
        return message;
      }
    };
    var baseQueryPacketAcknowledgementResponse = {};
    exports.QueryPacketAcknowledgementResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.acknowledgement.length !== 0) {
          writer.uint32(10).bytes(message.acknowledgement);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketAcknowledgementResponse);
        message.acknowledgement = new Uint8Array();
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgement = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPacketAcknowledgementResponse);
        message.acknowledgement = object.acknowledgement !== void 0 && object.acknowledgement !== null ? bytesFromBase64(object.acknowledgement) : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.acknowledgement !== void 0 && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryPacketAcknowledgementResponse);
        message.acknowledgement = (_a = object.acknowledgement) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryPacketAcknowledgementsRequest = { portId: "", channelId: "" };
    exports.QueryPacketAcknowledgementsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketAcknowledgementsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPacketAcknowledgementsRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryPacketAcknowledgementsRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryPacketAcknowledgementsResponse = {};
    exports.QueryPacketAcknowledgementsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.acknowledgements) {
          channel_1.PacketState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPacketAcknowledgementsResponse);
        message.acknowledgements = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgements.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryPacketAcknowledgementsResponse);
        message.acknowledgements = ((_a = object.acknowledgements) !== null && _a !== void 0 ? _a : []).map((e) => channel_1.PacketState.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromJSON(object.height) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.acknowledgements) {
          obj.acknowledgements = message.acknowledgements.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.acknowledgements = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryPacketAcknowledgementsResponse);
        message.acknowledgements = ((_a = object.acknowledgements) === null || _a === void 0 ? void 0 : _a.map((e) => channel_1.PacketState.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    var baseQueryUnreceivedPacketsRequest = {
      portId: "",
      channelId: "",
      packetCommitmentSequences: long_1.default.UZERO
    };
    exports.QueryUnreceivedPacketsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetCommitmentSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryUnreceivedPacketsRequest);
        message.packetCommitmentSequences = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryUnreceivedPacketsRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.packetCommitmentSequences = ((_a = object.packetCommitmentSequences) !== null && _a !== void 0 ? _a : []).map((e) => long_1.default.fromString(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseQueryUnreceivedPacketsRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.packetCommitmentSequences = ((_c = object.packetCommitmentSequences) === null || _c === void 0 ? void 0 : _c.map((e) => long_1.default.fromValue(e))) || [];
        return message;
      }
    };
    var baseQueryUnreceivedPacketsResponse = { sequences: long_1.default.UZERO };
    exports.QueryUnreceivedPacketsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryUnreceivedPacketsResponse);
        message.sequences = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryUnreceivedPacketsResponse);
        message.sequences = ((_a = object.sequences) !== null && _a !== void 0 ? _a : []).map((e) => long_1.default.fromString(e));
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromJSON(object.height) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryUnreceivedPacketsResponse);
        message.sequences = ((_a = object.sequences) === null || _a === void 0 ? void 0 : _a.map((e) => long_1.default.fromValue(e))) || [];
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    var baseQueryUnreceivedAcksRequest = { portId: "", channelId: "", packetAckSequences: long_1.default.UZERO };
    exports.QueryUnreceivedAcksRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v of message.packetAckSequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryUnreceivedAcksRequest);
        message.packetAckSequences = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetAckSequences.push(reader.uint64());
                }
              } else {
                message.packetAckSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryUnreceivedAcksRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.packetAckSequences = ((_a = object.packetAckSequences) !== null && _a !== void 0 ? _a : []).map((e) => long_1.default.fromString(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetAckSequences) {
          obj.packetAckSequences = message.packetAckSequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.packetAckSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseQueryUnreceivedAcksRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.packetAckSequences = ((_c = object.packetAckSequences) === null || _c === void 0 ? void 0 : _c.map((e) => long_1.default.fromValue(e))) || [];
        return message;
      }
    };
    var baseQueryUnreceivedAcksResponse = { sequences: long_1.default.UZERO };
    exports.QueryUnreceivedAcksResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.sequences) {
          writer.uint64(v);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryUnreceivedAcksResponse);
        message.sequences = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryUnreceivedAcksResponse);
        message.sequences = ((_a = object.sequences) !== null && _a !== void 0 ? _a : []).map((e) => long_1.default.fromString(e));
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromJSON(object.height) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || long_1.default.UZERO).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryUnreceivedAcksResponse);
        message.sequences = ((_a = object.sequences) === null || _a === void 0 ? void 0 : _a.map((e) => long_1.default.fromValue(e))) || [];
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    var baseQueryNextSequenceReceiveRequest = { portId: "", channelId: "" };
    exports.QueryNextSequenceReceiveRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryNextSequenceReceiveRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryNextSequenceReceiveRequest);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryNextSequenceReceiveRequest);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseQueryNextSequenceReceiveResponse = { nextSequenceReceive: long_1.default.UZERO };
    exports.QueryNextSequenceReceiveResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.nextSequenceReceive.isZero()) {
          writer.uint32(8).uint64(message.nextSequenceReceive);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryNextSequenceReceiveResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceReceive = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryNextSequenceReceiveResponse);
        message.nextSequenceReceive = object.nextSequenceReceive !== void 0 && object.nextSequenceReceive !== null ? long_1.default.fromString(object.nextSequenceReceive) : long_1.default.UZERO;
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceReceive !== void 0 && (obj.nextSequenceReceive = (message.nextSequenceReceive || long_1.default.UZERO).toString());
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryNextSequenceReceiveResponse);
        message.nextSequenceReceive = object.nextSequenceReceive !== void 0 && object.nextSequenceReceive !== null ? long_1.default.fromValue(object.nextSequenceReceive) : long_1.default.UZERO;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Channel = this.Channel.bind(this);
        this.Channels = this.Channels.bind(this);
        this.ConnectionChannels = this.ConnectionChannels.bind(this);
        this.ChannelClientState = this.ChannelClientState.bind(this);
        this.ChannelConsensusState = this.ChannelConsensusState.bind(this);
        this.PacketCommitment = this.PacketCommitment.bind(this);
        this.PacketCommitments = this.PacketCommitments.bind(this);
        this.PacketReceipt = this.PacketReceipt.bind(this);
        this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this);
        this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this);
        this.UnreceivedPackets = this.UnreceivedPackets.bind(this);
        this.UnreceivedAcks = this.UnreceivedAcks.bind(this);
        this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
      }
      Channel(request) {
        const data = exports.QueryChannelRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channel", data);
        return promise.then((data2) => exports.QueryChannelResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Channels(request) {
        const data = exports.QueryChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channels", data);
        return promise.then((data2) => exports.QueryChannelsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionChannels(request) {
        const data = exports.QueryConnectionChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", data);
        return promise.then((data2) => exports.QueryConnectionChannelsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelClientState(request) {
        const data = exports.QueryChannelClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", data);
        return promise.then((data2) => exports.QueryChannelClientStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelConsensusState(request) {
        const data = exports.QueryChannelConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", data);
        return promise.then((data2) => exports.QueryChannelConsensusStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketCommitment(request) {
        const data = exports.QueryPacketCommitmentRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", data);
        return promise.then((data2) => exports.QueryPacketCommitmentResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketCommitments(request) {
        const data = exports.QueryPacketCommitmentsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", data);
        return promise.then((data2) => exports.QueryPacketCommitmentsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketReceipt(request) {
        const data = exports.QueryPacketReceiptRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", data);
        return promise.then((data2) => exports.QueryPacketReceiptResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketAcknowledgement(request) {
        const data = exports.QueryPacketAcknowledgementRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", data);
        return promise.then((data2) => exports.QueryPacketAcknowledgementResponse.decode(new minimal_1.default.Reader(data2)));
      }
      PacketAcknowledgements(request) {
        const data = exports.QueryPacketAcknowledgementsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", data);
        return promise.then((data2) => exports.QueryPacketAcknowledgementsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UnreceivedPackets(request) {
        const data = exports.QueryUnreceivedPacketsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", data);
        return promise.then((data2) => exports.QueryUnreceivedPacketsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UnreceivedAcks(request) {
        const data = exports.QueryUnreceivedAcksRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", data);
        return promise.then((data2) => exports.QueryUnreceivedAcksResponse.decode(new minimal_1.default.Reader(data2)));
      }
      NextSequenceReceive(request) {
        const data = exports.QueryNextSequenceReceiveRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", data);
        return promise.then((data2) => exports.QueryNextSequenceReceiveResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/client/v1/query.js
var require_query7 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/client/v1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryClientParamsResponse = exports.QueryClientParamsRequest = exports.QueryConsensusStatesResponse = exports.QueryConsensusStatesRequest = exports.QueryConsensusStateResponse = exports.QueryConsensusStateRequest = exports.QueryClientStatesResponse = exports.QueryClientStatesRequest = exports.QueryClientStateResponse = exports.QueryClientStateRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    var client_1 = require_client();
    var pagination_1 = require_pagination();
    exports.protobufPackage = "ibc.core.client.v1";
    var baseQueryClientStateRequest = { clientId: "" };
    exports.QueryClientStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryClientStateRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryClientStateRequest);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryClientStateRequest);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryClientStateResponse = {};
    exports.QueryClientStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryClientStateResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryClientStateResponse);
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromJSON(object.clientState) : void 0;
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryClientStateResponse);
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryClientStatesRequest = {};
    exports.QueryClientStatesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryClientStatesRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryClientStatesRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryClientStatesRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryClientStatesResponse = {};
    exports.QueryClientStatesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.clientStates) {
          client_1.IdentifiedClientState.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryClientStatesResponse);
        message.clientStates = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientStates.push(client_1.IdentifiedClientState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryClientStatesResponse);
        message.clientStates = ((_a = object.clientStates) !== null && _a !== void 0 ? _a : []).map((e) => client_1.IdentifiedClientState.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.clientStates) {
          obj.clientStates = message.clientStates.map((e) => e ? client_1.IdentifiedClientState.toJSON(e) : void 0);
        } else {
          obj.clientStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryClientStatesResponse);
        message.clientStates = ((_a = object.clientStates) === null || _a === void 0 ? void 0 : _a.map((e) => client_1.IdentifiedClientState.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryConsensusStateRequest = {
      clientId: "",
      revisionNumber: long_1.default.UZERO,
      revisionHeight: long_1.default.UZERO,
      latestHeight: false
    };
    exports.QueryConsensusStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (!message.revisionNumber.isZero()) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (!message.revisionHeight.isZero()) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        if (message.latestHeight === true) {
          writer.uint32(32).bool(message.latestHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConsensusStateRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            case 4:
              message.latestHeight = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConsensusStateRequest);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromString(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromString(object.revisionHeight) : long_1.default.UZERO;
        message.latestHeight = object.latestHeight !== void 0 && object.latestHeight !== null ? Boolean(object.latestHeight) : false;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryConsensusStateRequest);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO;
        message.latestHeight = (_b = object.latestHeight) !== null && _b !== void 0 ? _b : false;
        return message;
      }
    };
    var baseQueryConsensusStateResponse = {};
    exports.QueryConsensusStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConsensusStateResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConsensusStateResponse);
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromJSON(object.consensusState) : void 0;
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConsensusStateResponse);
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryConsensusStatesRequest = { clientId: "" };
    exports.QueryConsensusStatesRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConsensusStatesRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConsensusStatesRequest);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConsensusStatesRequest);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryConsensusStatesResponse = {};
    exports.QueryConsensusStatesResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.consensusStates) {
          client_1.ConsensusStateWithHeight.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConsensusStatesResponse);
        message.consensusStates = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStates.push(client_1.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryConsensusStatesResponse);
        message.consensusStates = ((_a = object.consensusStates) !== null && _a !== void 0 ? _a : []).map((e) => client_1.ConsensusStateWithHeight.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? client_1.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConsensusStatesResponse);
        message.consensusStates = ((_a = object.consensusStates) === null || _a === void 0 ? void 0 : _a.map((e) => client_1.ConsensusStateWithHeight.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryClientParamsRequest = {};
    exports.QueryClientParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryClientParamsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryClientParamsRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryClientParamsRequest);
        return message;
      }
    };
    var baseQueryClientParamsResponse = {};
    exports.QueryClientParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryClientParamsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryClientParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? client_1.Params.fromJSON(object.params) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryClientParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? client_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ClientState = this.ClientState.bind(this);
        this.ClientStates = this.ClientStates.bind(this);
        this.ConsensusState = this.ConsensusState.bind(this);
        this.ConsensusStates = this.ConsensusStates.bind(this);
        this.ClientParams = this.ClientParams.bind(this);
      }
      ClientState(request) {
        const data = exports.QueryClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientState", data);
        return promise.then((data2) => exports.QueryClientStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ClientStates(request) {
        const data = exports.QueryClientStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStates", data);
        return promise.then((data2) => exports.QueryClientStatesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConsensusState(request) {
        const data = exports.QueryConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", data);
        return promise.then((data2) => exports.QueryConsensusStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConsensusStates(request) {
        const data = exports.QueryConsensusStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", data);
        return promise.then((data2) => exports.QueryConsensusStatesResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ClientParams(request) {
        const data = exports.QueryClientParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientParams", data);
        return promise.then((data2) => exports.QueryClientParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/confio/proofs.js
var require_proofs2 = __commonJS({
  "node_modules/cosmjs-types/confio/proofs.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchEntry = exports.CompressedBatchProof = exports.BatchEntry = exports.BatchProof = exports.InnerSpec = exports.ProofSpec = exports.InnerOp = exports.LeafOp = exports.CommitmentProof = exports.NonExistenceProof = exports.ExistenceProof = exports.lengthOpToJSON = exports.lengthOpFromJSON = exports.LengthOp = exports.hashOpToJSON = exports.hashOpFromJSON = exports.HashOp = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "ics23";
    var HashOp;
    (function(HashOp2) {
      HashOp2[HashOp2["NO_HASH"] = 0] = "NO_HASH";
      HashOp2[HashOp2["SHA256"] = 1] = "SHA256";
      HashOp2[HashOp2["SHA512"] = 2] = "SHA512";
      HashOp2[HashOp2["KECCAK"] = 3] = "KECCAK";
      HashOp2[HashOp2["RIPEMD160"] = 4] = "RIPEMD160";
      HashOp2[HashOp2["BITCOIN"] = 5] = "BITCOIN";
      HashOp2[HashOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HashOp = exports.HashOp || (exports.HashOp = {}));
    function hashOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_HASH":
          return HashOp.NO_HASH;
        case 1:
        case "SHA256":
          return HashOp.SHA256;
        case 2:
        case "SHA512":
          return HashOp.SHA512;
        case 3:
        case "KECCAK":
          return HashOp.KECCAK;
        case 4:
        case "RIPEMD160":
          return HashOp.RIPEMD160;
        case 5:
        case "BITCOIN":
          return HashOp.BITCOIN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return HashOp.UNRECOGNIZED;
      }
    }
    exports.hashOpFromJSON = hashOpFromJSON;
    function hashOpToJSON(object) {
      switch (object) {
        case HashOp.NO_HASH:
          return "NO_HASH";
        case HashOp.SHA256:
          return "SHA256";
        case HashOp.SHA512:
          return "SHA512";
        case HashOp.KECCAK:
          return "KECCAK";
        case HashOp.RIPEMD160:
          return "RIPEMD160";
        case HashOp.BITCOIN:
          return "BITCOIN";
        default:
          return "UNKNOWN";
      }
    }
    exports.hashOpToJSON = hashOpToJSON;
    var LengthOp;
    (function(LengthOp2) {
      LengthOp2[LengthOp2["NO_PREFIX"] = 0] = "NO_PREFIX";
      LengthOp2[LengthOp2["VAR_PROTO"] = 1] = "VAR_PROTO";
      LengthOp2[LengthOp2["VAR_RLP"] = 2] = "VAR_RLP";
      LengthOp2[LengthOp2["FIXED32_BIG"] = 3] = "FIXED32_BIG";
      LengthOp2[LengthOp2["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
      LengthOp2[LengthOp2["FIXED64_BIG"] = 5] = "FIXED64_BIG";
      LengthOp2[LengthOp2["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
      LengthOp2[LengthOp2["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
      LengthOp2[LengthOp2["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
      LengthOp2[LengthOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LengthOp = exports.LengthOp || (exports.LengthOp = {}));
    function lengthOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_PREFIX":
          return LengthOp.NO_PREFIX;
        case 1:
        case "VAR_PROTO":
          return LengthOp.VAR_PROTO;
        case 2:
        case "VAR_RLP":
          return LengthOp.VAR_RLP;
        case 3:
        case "FIXED32_BIG":
          return LengthOp.FIXED32_BIG;
        case 4:
        case "FIXED32_LITTLE":
          return LengthOp.FIXED32_LITTLE;
        case 5:
        case "FIXED64_BIG":
          return LengthOp.FIXED64_BIG;
        case 6:
        case "FIXED64_LITTLE":
          return LengthOp.FIXED64_LITTLE;
        case 7:
        case "REQUIRE_32_BYTES":
          return LengthOp.REQUIRE_32_BYTES;
        case 8:
        case "REQUIRE_64_BYTES":
          return LengthOp.REQUIRE_64_BYTES;
        case -1:
        case "UNRECOGNIZED":
        default:
          return LengthOp.UNRECOGNIZED;
      }
    }
    exports.lengthOpFromJSON = lengthOpFromJSON;
    function lengthOpToJSON(object) {
      switch (object) {
        case LengthOp.NO_PREFIX:
          return "NO_PREFIX";
        case LengthOp.VAR_PROTO:
          return "VAR_PROTO";
        case LengthOp.VAR_RLP:
          return "VAR_RLP";
        case LengthOp.FIXED32_BIG:
          return "FIXED32_BIG";
        case LengthOp.FIXED32_LITTLE:
          return "FIXED32_LITTLE";
        case LengthOp.FIXED64_BIG:
          return "FIXED64_BIG";
        case LengthOp.FIXED64_LITTLE:
          return "FIXED64_LITTLE";
        case LengthOp.REQUIRE_32_BYTES:
          return "REQUIRE_32_BYTES";
        case LengthOp.REQUIRE_64_BYTES:
          return "REQUIRE_64_BYTES";
        default:
          return "UNKNOWN";
      }
    }
    exports.lengthOpToJSON = lengthOpToJSON;
    var baseExistenceProof = {};
    exports.ExistenceProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.path) {
          exports.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseExistenceProof);
        message.path = [];
        message.key = new Uint8Array();
        message.value = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              message.path.push(exports.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseExistenceProof);
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.value = object.value !== void 0 && object.value !== null ? bytesFromBase64(object.value) : new Uint8Array();
        message.leaf = object.leaf !== void 0 && object.leaf !== null ? exports.LeafOp.fromJSON(object.leaf) : void 0;
        message.path = ((_a = object.path) !== null && _a !== void 0 ? _a : []).map((e) => exports.InnerOp.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => e ? exports.InnerOp.toJSON(e) : void 0);
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseExistenceProof);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.leaf = object.leaf !== void 0 && object.leaf !== null ? exports.LeafOp.fromPartial(object.leaf) : void 0;
        message.path = ((_c = object.path) === null || _c === void 0 ? void 0 : _c.map((e) => exports.InnerOp.fromPartial(e))) || [];
        return message;
      }
    };
    var baseNonExistenceProof = {};
    exports.NonExistenceProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseNonExistenceProof);
        message.key = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseNonExistenceProof);
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.left = object.left !== void 0 && object.left !== null ? exports.ExistenceProof.fromJSON(object.left) : void 0;
        message.right = object.right !== void 0 && object.right !== null ? exports.ExistenceProof.fromJSON(object.right) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports.ExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports.ExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseNonExistenceProof);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.left = object.left !== void 0 && object.left !== null ? exports.ExistenceProof.fromPartial(object.left) : void 0;
        message.right = object.right !== void 0 && object.right !== null ? exports.ExistenceProof.fromPartial(object.right) : void 0;
        return message;
      }
    };
    var baseCommitmentProof = {};
    exports.CommitmentProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exist !== void 0) {
          exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        if (message.batch !== void 0) {
          exports.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();
        }
        if (message.compressed !== void 0) {
          exports.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCommitmentProof);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.batch = exports.BatchProof.decode(reader, reader.uint32());
              break;
            case 4:
              message.compressed = exports.CompressedBatchProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCommitmentProof);
        message.exist = object.exist !== void 0 && object.exist !== null ? exports.ExistenceProof.fromJSON(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports.NonExistenceProof.fromJSON(object.nonexist) : void 0;
        message.batch = object.batch !== void 0 && object.batch !== null ? exports.BatchProof.fromJSON(object.batch) : void 0;
        message.compressed = object.compressed !== void 0 && object.compressed !== null ? exports.CompressedBatchProof.fromJSON(object.compressed) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : void 0);
        message.batch !== void 0 && (obj.batch = message.batch ? exports.BatchProof.toJSON(message.batch) : void 0);
        message.compressed !== void 0 && (obj.compressed = message.compressed ? exports.CompressedBatchProof.toJSON(message.compressed) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseCommitmentProof);
        message.exist = object.exist !== void 0 && object.exist !== null ? exports.ExistenceProof.fromPartial(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports.NonExistenceProof.fromPartial(object.nonexist) : void 0;
        message.batch = object.batch !== void 0 && object.batch !== null ? exports.BatchProof.fromPartial(object.batch) : void 0;
        message.compressed = object.compressed !== void 0 && object.compressed !== null ? exports.CompressedBatchProof.fromPartial(object.compressed) : void 0;
        return message;
      }
    };
    var baseLeafOp = { hash: 0, prehashKey: 0, prehashValue: 0, length: 0 };
    exports.LeafOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prehashKey !== 0) {
          writer.uint32(16).int32(message.prehashKey);
        }
        if (message.prehashValue !== 0) {
          writer.uint32(24).int32(message.prehashValue);
        }
        if (message.length !== 0) {
          writer.uint32(32).int32(message.length);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(42).bytes(message.prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseLeafOp);
        message.prefix = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prehashKey = reader.int32();
              break;
            case 3:
              message.prehashValue = reader.int32();
              break;
            case 4:
              message.length = reader.int32();
              break;
            case 5:
              message.prefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseLeafOp);
        message.hash = object.hash !== void 0 && object.hash !== null ? hashOpFromJSON(object.hash) : 0;
        message.prehashKey = object.prehashKey !== void 0 && object.prehashKey !== null ? hashOpFromJSON(object.prehashKey) : 0;
        message.prehashValue = object.prehashValue !== void 0 && object.prehashValue !== null ? hashOpFromJSON(object.prehashValue) : 0;
        message.length = object.length !== void 0 && object.length !== null ? lengthOpFromJSON(object.length) : 0;
        message.prefix = object.prefix !== void 0 && object.prefix !== null ? bytesFromBase64(object.prefix) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prehashKey !== void 0 && (obj.prehashKey = hashOpToJSON(message.prehashKey));
        message.prehashValue !== void 0 && (obj.prehashValue = hashOpToJSON(message.prehashValue));
        message.length !== void 0 && (obj.length = lengthOpToJSON(message.length));
        message.prefix !== void 0 && (obj.prefix = base64FromBytes(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseLeafOp);
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : 0;
        message.prehashKey = (_b = object.prehashKey) !== null && _b !== void 0 ? _b : 0;
        message.prehashValue = (_c = object.prehashValue) !== null && _c !== void 0 ? _c : 0;
        message.length = (_d = object.length) !== null && _d !== void 0 ? _d : 0;
        message.prefix = (_e = object.prefix) !== null && _e !== void 0 ? _e : new Uint8Array();
        return message;
      }
    };
    var baseInnerOp = { hash: 0 };
    exports.InnerOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(18).bytes(message.prefix);
        }
        if (message.suffix.length !== 0) {
          writer.uint32(26).bytes(message.suffix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInnerOp);
        message.prefix = new Uint8Array();
        message.suffix = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prefix = reader.bytes();
              break;
            case 3:
              message.suffix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseInnerOp);
        message.hash = object.hash !== void 0 && object.hash !== null ? hashOpFromJSON(object.hash) : 0;
        message.prefix = object.prefix !== void 0 && object.prefix !== null ? bytesFromBase64(object.prefix) : new Uint8Array();
        message.suffix = object.suffix !== void 0 && object.suffix !== null ? bytesFromBase64(object.suffix) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prefix !== void 0 && (obj.prefix = base64FromBytes(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        message.suffix !== void 0 && (obj.suffix = base64FromBytes(message.suffix !== void 0 ? message.suffix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseInnerOp);
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : 0;
        message.prefix = (_b = object.prefix) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.suffix = (_c = object.suffix) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var baseProofSpec = { maxDepth: 0, minDepth: 0 };
    exports.ProofSpec = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.leafSpec !== void 0) {
          exports.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();
        }
        if (message.innerSpec !== void 0) {
          exports.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxDepth !== 0) {
          writer.uint32(24).int32(message.maxDepth);
        }
        if (message.minDepth !== 0) {
          writer.uint32(32).int32(message.minDepth);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseProofSpec);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.leafSpec = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 2:
              message.innerSpec = exports.InnerSpec.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxDepth = reader.int32();
              break;
            case 4:
              message.minDepth = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseProofSpec);
        message.leafSpec = object.leafSpec !== void 0 && object.leafSpec !== null ? exports.LeafOp.fromJSON(object.leafSpec) : void 0;
        message.innerSpec = object.innerSpec !== void 0 && object.innerSpec !== null ? exports.InnerSpec.fromJSON(object.innerSpec) : void 0;
        message.maxDepth = object.maxDepth !== void 0 && object.maxDepth !== null ? Number(object.maxDepth) : 0;
        message.minDepth = object.minDepth !== void 0 && object.minDepth !== null ? Number(object.minDepth) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.leafSpec !== void 0 && (obj.leafSpec = message.leafSpec ? exports.LeafOp.toJSON(message.leafSpec) : void 0);
        message.innerSpec !== void 0 && (obj.innerSpec = message.innerSpec ? exports.InnerSpec.toJSON(message.innerSpec) : void 0);
        message.maxDepth !== void 0 && (obj.maxDepth = message.maxDepth);
        message.minDepth !== void 0 && (obj.minDepth = message.minDepth);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseProofSpec);
        message.leafSpec = object.leafSpec !== void 0 && object.leafSpec !== null ? exports.LeafOp.fromPartial(object.leafSpec) : void 0;
        message.innerSpec = object.innerSpec !== void 0 && object.innerSpec !== null ? exports.InnerSpec.fromPartial(object.innerSpec) : void 0;
        message.maxDepth = (_a = object.maxDepth) !== null && _a !== void 0 ? _a : 0;
        message.minDepth = (_b = object.minDepth) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var baseInnerSpec = {
      childOrder: 0,
      childSize: 0,
      minPrefixLength: 0,
      maxPrefixLength: 0,
      hash: 0
    };
    exports.InnerSpec = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        writer.uint32(10).fork();
        for (const v of message.childOrder) {
          writer.int32(v);
        }
        writer.ldelim();
        if (message.childSize !== 0) {
          writer.uint32(16).int32(message.childSize);
        }
        if (message.minPrefixLength !== 0) {
          writer.uint32(24).int32(message.minPrefixLength);
        }
        if (message.maxPrefixLength !== 0) {
          writer.uint32(32).int32(message.maxPrefixLength);
        }
        if (message.emptyChild.length !== 0) {
          writer.uint32(42).bytes(message.emptyChild);
        }
        if (message.hash !== 0) {
          writer.uint32(48).int32(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInnerSpec);
        message.childOrder = [];
        message.emptyChild = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.childOrder.push(reader.int32());
                }
              } else {
                message.childOrder.push(reader.int32());
              }
              break;
            case 2:
              message.childSize = reader.int32();
              break;
            case 3:
              message.minPrefixLength = reader.int32();
              break;
            case 4:
              message.maxPrefixLength = reader.int32();
              break;
            case 5:
              message.emptyChild = reader.bytes();
              break;
            case 6:
              message.hash = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseInnerSpec);
        message.childOrder = ((_a = object.childOrder) !== null && _a !== void 0 ? _a : []).map((e) => Number(e));
        message.childSize = object.childSize !== void 0 && object.childSize !== null ? Number(object.childSize) : 0;
        message.minPrefixLength = object.minPrefixLength !== void 0 && object.minPrefixLength !== null ? Number(object.minPrefixLength) : 0;
        message.maxPrefixLength = object.maxPrefixLength !== void 0 && object.maxPrefixLength !== null ? Number(object.maxPrefixLength) : 0;
        message.emptyChild = object.emptyChild !== void 0 && object.emptyChild !== null ? bytesFromBase64(object.emptyChild) : new Uint8Array();
        message.hash = object.hash !== void 0 && object.hash !== null ? hashOpFromJSON(object.hash) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.childOrder) {
          obj.childOrder = message.childOrder.map((e) => e);
        } else {
          obj.childOrder = [];
        }
        message.childSize !== void 0 && (obj.childSize = message.childSize);
        message.minPrefixLength !== void 0 && (obj.minPrefixLength = message.minPrefixLength);
        message.maxPrefixLength !== void 0 && (obj.maxPrefixLength = message.maxPrefixLength);
        message.emptyChild !== void 0 && (obj.emptyChild = base64FromBytes(message.emptyChild !== void 0 ? message.emptyChild : new Uint8Array()));
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = Object.assign({}, baseInnerSpec);
        message.childOrder = ((_a = object.childOrder) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.childSize = (_b = object.childSize) !== null && _b !== void 0 ? _b : 0;
        message.minPrefixLength = (_c = object.minPrefixLength) !== null && _c !== void 0 ? _c : 0;
        message.maxPrefixLength = (_d = object.maxPrefixLength) !== null && _d !== void 0 ? _d : 0;
        message.emptyChild = (_e = object.emptyChild) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.hash = (_f = object.hash) !== null && _f !== void 0 ? _f : 0;
        return message;
      }
    };
    var baseBatchProof = {};
    exports.BatchProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.entries) {
          exports.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBatchProof);
        message.entries = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports.BatchEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseBatchProof);
        message.entries = ((_a = object.entries) !== null && _a !== void 0 ? _a : []).map((e) => exports.BatchEntry.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.BatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseBatchProof);
        message.entries = ((_a = object.entries) === null || _a === void 0 ? void 0 : _a.map((e) => exports.BatchEntry.fromPartial(e))) || [];
        return message;
      }
    };
    var baseBatchEntry = {};
    exports.BatchEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exist !== void 0) {
          exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBatchEntry);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseBatchEntry);
        message.exist = object.exist !== void 0 && object.exist !== null ? exports.ExistenceProof.fromJSON(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports.NonExistenceProof.fromJSON(object.nonexist) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseBatchEntry);
        message.exist = object.exist !== void 0 && object.exist !== null ? exports.ExistenceProof.fromPartial(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports.NonExistenceProof.fromPartial(object.nonexist) : void 0;
        return message;
      }
    };
    var baseCompressedBatchProof = {};
    exports.CompressedBatchProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.entries) {
          exports.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.lookupInners) {
          exports.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCompressedBatchProof);
        message.entries = [];
        message.lookupInners = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports.CompressedBatchEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.lookupInners.push(exports.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a, _b;
        const message = Object.assign({}, baseCompressedBatchProof);
        message.entries = ((_a = object.entries) !== null && _a !== void 0 ? _a : []).map((e) => exports.CompressedBatchEntry.fromJSON(e));
        message.lookupInners = ((_b = object.lookupInners) !== null && _b !== void 0 ? _b : []).map((e) => exports.InnerOp.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.CompressedBatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        if (message.lookupInners) {
          obj.lookupInners = message.lookupInners.map((e) => e ? exports.InnerOp.toJSON(e) : void 0);
        } else {
          obj.lookupInners = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseCompressedBatchProof);
        message.entries = ((_a = object.entries) === null || _a === void 0 ? void 0 : _a.map((e) => exports.CompressedBatchEntry.fromPartial(e))) || [];
        message.lookupInners = ((_b = object.lookupInners) === null || _b === void 0 ? void 0 : _b.map((e) => exports.InnerOp.fromPartial(e))) || [];
        return message;
      }
    };
    var baseCompressedBatchEntry = {};
    exports.CompressedBatchEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exist !== void 0) {
          exports.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCompressedBatchEntry);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.CompressedNonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCompressedBatchEntry);
        message.exist = object.exist !== void 0 && object.exist !== null ? exports.CompressedExistenceProof.fromJSON(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports.CompressedNonExistenceProof.fromJSON(object.nonexist) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.CompressedExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.CompressedNonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseCompressedBatchEntry);
        message.exist = object.exist !== void 0 && object.exist !== null ? exports.CompressedExistenceProof.fromPartial(object.exist) : void 0;
        message.nonexist = object.nonexist !== void 0 && object.nonexist !== null ? exports.CompressedNonExistenceProof.fromPartial(object.nonexist) : void 0;
        return message;
      }
    };
    var baseCompressedExistenceProof = { path: 0 };
    exports.CompressedExistenceProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v of message.path) {
          writer.int32(v);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCompressedExistenceProof);
        message.path = [];
        message.key = new Uint8Array();
        message.value = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.path.push(reader.int32());
                }
              } else {
                message.path.push(reader.int32());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseCompressedExistenceProof);
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.value = object.value !== void 0 && object.value !== null ? bytesFromBase64(object.value) : new Uint8Array();
        message.leaf = object.leaf !== void 0 && object.leaf !== null ? exports.LeafOp.fromJSON(object.leaf) : void 0;
        message.path = ((_a = object.path) !== null && _a !== void 0 ? _a : []).map((e) => Number(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => e);
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseCompressedExistenceProof);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.leaf = object.leaf !== void 0 && object.leaf !== null ? exports.LeafOp.fromPartial(object.leaf) : void 0;
        message.path = ((_c = object.path) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    var baseCompressedNonExistenceProof = {};
    exports.CompressedNonExistenceProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCompressedNonExistenceProof);
        message.key = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCompressedNonExistenceProof);
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.left = object.left !== void 0 && object.left !== null ? exports.CompressedExistenceProof.fromJSON(object.left) : void 0;
        message.right = object.right !== void 0 && object.right !== null ? exports.CompressedExistenceProof.fromJSON(object.right) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports.CompressedExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports.CompressedExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseCompressedNonExistenceProof);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.left = object.left !== void 0 && object.left !== null ? exports.CompressedExistenceProof.fromPartial(object.left) : void 0;
        message.right = object.right !== void 0 && object.right !== null ? exports.CompressedExistenceProof.fromPartial(object.right) : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js
var require_commitment = __commonJS({
  "node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleProof = exports.MerklePath = exports.MerklePrefix = exports.MerkleRoot = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var proofs_1 = require_proofs2();
    exports.protobufPackage = "ibc.core.commitment.v1";
    var baseMerkleRoot = {};
    exports.MerkleRoot = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMerkleRoot);
        message.hash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMerkleRoot);
        message.hash = object.hash !== void 0 && object.hash !== null ? bytesFromBase64(object.hash) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseMerkleRoot);
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var baseMerklePrefix = {};
    exports.MerklePrefix = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.keyPrefix.length !== 0) {
          writer.uint32(10).bytes(message.keyPrefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMerklePrefix);
        message.keyPrefix = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPrefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMerklePrefix);
        message.keyPrefix = object.keyPrefix !== void 0 && object.keyPrefix !== null ? bytesFromBase64(object.keyPrefix) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.keyPrefix !== void 0 && (obj.keyPrefix = base64FromBytes(message.keyPrefix !== void 0 ? message.keyPrefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseMerklePrefix);
        message.keyPrefix = (_a = object.keyPrefix) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var baseMerklePath = { keyPath: "" };
    exports.MerklePath = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.keyPath) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMerklePath);
        message.keyPath = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPath.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseMerklePath);
        message.keyPath = ((_a = object.keyPath) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.keyPath) {
          obj.keyPath = message.keyPath.map((e) => e);
        } else {
          obj.keyPath = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseMerklePath);
        message.keyPath = ((_a = object.keyPath) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    var baseMerkleProof = {};
    exports.MerkleProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.proofs) {
          proofs_1.CommitmentProof.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMerkleProof);
        message.proofs = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proofs.push(proofs_1.CommitmentProof.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseMerkleProof);
        message.proofs = ((_a = object.proofs) !== null && _a !== void 0 ? _a : []).map((e) => proofs_1.CommitmentProof.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.proofs) {
          obj.proofs = message.proofs.map((e) => e ? proofs_1.CommitmentProof.toJSON(e) : void 0);
        } else {
          obj.proofs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseMerkleProof);
        message.proofs = ((_a = object.proofs) === null || _a === void 0 ? void 0 : _a.map((e) => proofs_1.CommitmentProof.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/connection/v1/connection.js
var require_connection = __commonJS({
  "node_modules/cosmjs-types/ibc/core/connection/v1/connection.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Version = exports.ConnectionPaths = exports.ClientPaths = exports.Counterparty = exports.IdentifiedConnection = exports.ConnectionEnd = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var commitment_1 = require_commitment();
    exports.protobufPackage = "ibc.core.connection.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State = exports.State || (exports.State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        default:
          return "UNKNOWN";
      }
    }
    exports.stateToJSON = stateToJSON;
    var baseConnectionEnd = { clientId: "", state: 0, delayPeriod: long_1.default.UZERO };
    exports.ConnectionEnd = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.versions) {
          exports.Version.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(24).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (!message.delayPeriod.isZero()) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConnectionEnd);
        message.versions = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.versions.push(exports.Version.decode(reader, reader.uint32()));
              break;
            case 3:
              message.state = reader.int32();
              break;
            case 4:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseConnectionEnd);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.versions = ((_a = object.versions) !== null && _a !== void 0 ? _a : []).map((e) => exports.Version.fromJSON(e));
        message.state = object.state !== void 0 && object.state !== null ? stateFromJSON(object.state) : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports.Counterparty.fromJSON(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromString(object.delayPeriod) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseConnectionEnd);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.versions = ((_b = object.versions) === null || _b === void 0 ? void 0 : _b.map((e) => exports.Version.fromPartial(e))) || [];
        message.state = (_c = object.state) !== null && _c !== void 0 ? _c : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports.Counterparty.fromPartial(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO;
        return message;
      }
    };
    var baseIdentifiedConnection = { id: "", clientId: "", state: 0, delayPeriod: long_1.default.UZERO };
    exports.IdentifiedConnection = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        for (const v of message.versions) {
          exports.Version.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(32).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();
        }
        if (!message.delayPeriod.isZero()) {
          writer.uint32(48).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseIdentifiedConnection);
        message.versions = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.versions.push(exports.Version.decode(reader, reader.uint32()));
              break;
            case 4:
              message.state = reader.int32();
              break;
            case 5:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 6:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseIdentifiedConnection);
        message.id = object.id !== void 0 && object.id !== null ? String(object.id) : "";
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.versions = ((_a = object.versions) !== null && _a !== void 0 ? _a : []).map((e) => exports.Version.fromJSON(e));
        message.state = object.state !== void 0 && object.state !== null ? stateFromJSON(object.state) : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports.Counterparty.fromJSON(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromString(object.delayPeriod) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseIdentifiedConnection);
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.clientId = (_b = object.clientId) !== null && _b !== void 0 ? _b : "";
        message.versions = ((_c = object.versions) === null || _c === void 0 ? void 0 : _c.map((e) => exports.Version.fromPartial(e))) || [];
        message.state = (_d = object.state) !== null && _d !== void 0 ? _d : 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? exports.Counterparty.fromPartial(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO;
        return message;
      }
    };
    var baseCounterparty = { clientId: "", connectionId: "" };
    exports.Counterparty = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.connectionId !== "") {
          writer.uint32(18).string(message.connectionId);
        }
        if (message.prefix !== void 0) {
          commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCounterparty);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.connectionId = reader.string();
              break;
            case 3:
              message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCounterparty);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.connectionId = object.connectionId !== void 0 && object.connectionId !== null ? String(object.connectionId) : "";
        message.prefix = object.prefix !== void 0 && object.prefix !== null ? commitment_1.MerklePrefix.fromJSON(object.prefix) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.prefix !== void 0 && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseCounterparty);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.connectionId = (_b = object.connectionId) !== null && _b !== void 0 ? _b : "";
        message.prefix = object.prefix !== void 0 && object.prefix !== null ? commitment_1.MerklePrefix.fromPartial(object.prefix) : void 0;
        return message;
      }
    };
    var baseClientPaths = { paths: "" };
    exports.ClientPaths = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.paths) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientPaths);
        message.paths = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseClientPaths);
        message.paths = ((_a = object.paths) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseClientPaths);
        message.paths = ((_a = object.paths) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    var baseConnectionPaths = { clientId: "", paths: "" };
    exports.ConnectionPaths = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v of message.paths) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConnectionPaths);
        message.paths = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseConnectionPaths);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.paths = ((_a = object.paths) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseConnectionPaths);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.paths = ((_b = object.paths) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    var baseVersion = { identifier: "", features: "" };
    exports.Version = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.identifier !== "") {
          writer.uint32(10).string(message.identifier);
        }
        for (const v of message.features) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVersion);
        message.features = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            case 2:
              message.features.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseVersion);
        message.identifier = object.identifier !== void 0 && object.identifier !== null ? String(object.identifier) : "";
        message.features = ((_a = object.features) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.identifier !== void 0 && (obj.identifier = message.identifier);
        if (message.features) {
          obj.features = message.features.map((e) => e);
        } else {
          obj.features = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseVersion);
        message.identifier = (_a = object.identifier) !== null && _a !== void 0 ? _a : "";
        message.features = ((_b = object.features) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/connection/v1/query.js
var require_query8 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/connection/v1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryConnectionConsensusStateResponse = exports.QueryConnectionConsensusStateRequest = exports.QueryConnectionClientStateResponse = exports.QueryConnectionClientStateRequest = exports.QueryClientConnectionsResponse = exports.QueryClientConnectionsRequest = exports.QueryConnectionsResponse = exports.QueryConnectionsRequest = exports.QueryConnectionResponse = exports.QueryConnectionRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var connection_1 = require_connection();
    var client_1 = require_client();
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    exports.protobufPackage = "ibc.core.connection.v1";
    var baseQueryConnectionRequest = { connectionId: "" };
    exports.QueryConnectionRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConnectionRequest);
        message.connectionId = object.connectionId !== void 0 && object.connectionId !== null ? String(object.connectionId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionRequest);
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryConnectionResponse = {};
    exports.QueryConnectionResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connection !== void 0) {
          connection_1.ConnectionEnd.encode(message.connection, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = connection_1.ConnectionEnd.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConnectionResponse);
        message.connection = object.connection !== void 0 && object.connection !== null ? connection_1.ConnectionEnd.fromJSON(object.connection) : void 0;
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection ? connection_1.ConnectionEnd.toJSON(message.connection) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionResponse);
        message.connection = object.connection !== void 0 && object.connection !== null ? connection_1.ConnectionEnd.fromPartial(object.connection) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryConnectionsRequest = {};
    exports.QueryConnectionsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConnectionsRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryConnectionsRequest);
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryConnectionsResponse = {};
    exports.QueryConnectionsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.connections) {
          connection_1.IdentifiedConnection.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionsResponse);
        message.connections = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connections.push(connection_1.IdentifiedConnection.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionsResponse);
        message.connections = ((_a = object.connections) !== null && _a !== void 0 ? _a : []).map((e) => connection_1.IdentifiedConnection.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromJSON(object.height) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.connections) {
          obj.connections = message.connections.map((e) => e ? connection_1.IdentifiedConnection.toJSON(e) : void 0);
        } else {
          obj.connections = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionsResponse);
        message.connections = ((_a = object.connections) === null || _a === void 0 ? void 0 : _a.map((e) => connection_1.IdentifiedConnection.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? client_1.Height.fromPartial(object.height) : void 0;
        return message;
      }
    };
    var baseQueryClientConnectionsRequest = { clientId: "" };
    exports.QueryClientConnectionsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryClientConnectionsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryClientConnectionsRequest);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryClientConnectionsRequest);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryClientConnectionsResponse = { connectionPaths: "" };
    exports.QueryClientConnectionsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.connectionPaths) {
          writer.uint32(10).string(v);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryClientConnectionsResponse);
        message.connectionPaths = [];
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionPaths.push(reader.string());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryClientConnectionsResponse);
        message.connectionPaths = ((_a = object.connectionPaths) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.connectionPaths) {
          obj.connectionPaths = message.connectionPaths.map((e) => e);
        } else {
          obj.connectionPaths = [];
        }
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryClientConnectionsResponse);
        message.connectionPaths = ((_a = object.connectionPaths) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryConnectionClientStateRequest = { connectionId: "" };
    exports.QueryConnectionClientStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionClientStateRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConnectionClientStateRequest);
        message.connectionId = object.connectionId !== void 0 && object.connectionId !== null ? String(object.connectionId) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionClientStateRequest);
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryConnectionClientStateResponse = {};
    exports.QueryConnectionClientStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionClientStateResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConnectionClientStateResponse);
        message.identifiedClientState = object.identifiedClientState !== void 0 && object.identifiedClientState !== null ? client_1.IdentifiedClientState.fromJSON(object.identifiedClientState) : void 0;
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionClientStateResponse);
        message.identifiedClientState = object.identifiedClientState !== void 0 && object.identifiedClientState !== null ? client_1.IdentifiedClientState.fromPartial(object.identifiedClientState) : void 0;
        message.proof = (_a = object.proof) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var baseQueryConnectionConsensusStateRequest = {
      connectionId: "",
      revisionNumber: long_1.default.UZERO,
      revisionHeight: long_1.default.UZERO
    };
    exports.QueryConnectionConsensusStateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (!message.revisionNumber.isZero()) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (!message.revisionHeight.isZero()) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionConsensusStateRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConnectionConsensusStateRequest);
        message.connectionId = object.connectionId !== void 0 && object.connectionId !== null ? String(object.connectionId) : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromString(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromString(object.revisionHeight) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryConnectionConsensusStateRequest);
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        message.revisionNumber = object.revisionNumber !== void 0 && object.revisionNumber !== null ? long_1.default.fromValue(object.revisionNumber) : long_1.default.UZERO;
        message.revisionHeight = object.revisionHeight !== void 0 && object.revisionHeight !== null ? long_1.default.fromValue(object.revisionHeight) : long_1.default.UZERO;
        return message;
      }
    };
    var baseQueryConnectionConsensusStateResponse = { clientId: "" };
    exports.QueryConnectionConsensusStateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryConnectionConsensusStateResponse);
        message.proof = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryConnectionConsensusStateResponse);
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromJSON(object.consensusState) : void 0;
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.proof = object.proof !== void 0 && object.proof !== null ? bytesFromBase64(object.proof) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = base64FromBytes(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryConnectionConsensusStateResponse);
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.proof = (_b = object.proof) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Connection = this.Connection.bind(this);
        this.Connections = this.Connections.bind(this);
        this.ClientConnections = this.ClientConnections.bind(this);
        this.ConnectionClientState = this.ConnectionClientState.bind(this);
        this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this);
      }
      Connection(request) {
        const data = exports.QueryConnectionRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connection", data);
        return promise.then((data2) => exports.QueryConnectionResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Connections(request) {
        const data = exports.QueryConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connections", data);
        return promise.then((data2) => exports.QueryConnectionsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ClientConnections(request) {
        const data = exports.QueryClientConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", data);
        return promise.then((data2) => exports.QueryClientConnectionsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionClientState(request) {
        const data = exports.QueryConnectionClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", data);
        return promise.then((data2) => exports.QueryConnectionClientStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionConsensusState(request) {
        const data = exports.QueryConnectionConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", data);
        return promise.then((data2) => exports.QueryConnectionConsensusStateResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/tendermint/crypto/proof.js
var require_proof = __commonJS({
  "node_modules/cosmjs-types/tendermint/crypto/proof.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "tendermint.crypto";
    var baseProof = { total: long_1.default.ZERO, index: long_1.default.ZERO };
    exports.Proof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.total.isZero()) {
          writer.uint32(8).int64(message.total);
        }
        if (!message.index.isZero()) {
          writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
          writer.uint32(26).bytes(message.leafHash);
        }
        for (const v of message.aunts) {
          writer.uint32(34).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseProof);
        message.aunts = [];
        message.leafHash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.int64();
              break;
            case 2:
              message.index = reader.int64();
              break;
            case 3:
              message.leafHash = reader.bytes();
              break;
            case 4:
              message.aunts.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseProof);
        message.total = object.total !== void 0 && object.total !== null ? long_1.default.fromString(object.total) : long_1.default.ZERO;
        message.index = object.index !== void 0 && object.index !== null ? long_1.default.fromString(object.index) : long_1.default.ZERO;
        message.leafHash = object.leafHash !== void 0 && object.leafHash !== null ? bytesFromBase64(object.leafHash) : new Uint8Array();
        message.aunts = ((_a = object.aunts) !== null && _a !== void 0 ? _a : []).map((e) => bytesFromBase64(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = (message.total || long_1.default.ZERO).toString());
        message.index !== void 0 && (obj.index = (message.index || long_1.default.ZERO).toString());
        message.leafHash !== void 0 && (obj.leafHash = base64FromBytes(message.leafHash !== void 0 ? message.leafHash : new Uint8Array()));
        if (message.aunts) {
          obj.aunts = message.aunts.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.aunts = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseProof);
        message.total = object.total !== void 0 && object.total !== null ? long_1.default.fromValue(object.total) : long_1.default.ZERO;
        message.index = object.index !== void 0 && object.index !== null ? long_1.default.fromValue(object.index) : long_1.default.ZERO;
        message.leafHash = (_a = object.leafHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.aunts = ((_b = object.aunts) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
      }
    };
    var baseValueOp = {};
    exports.ValueOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== void 0) {
          exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValueOp);
        message.key = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.proof = exports.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseValueOp);
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? exports.Proof.fromJSON(object.proof) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValueOp);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? exports.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    var baseDominoOp = { key: "", input: "", output: "" };
    exports.DominoOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
          writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
          writer.uint32(26).string(message.output);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDominoOp);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.input = reader.string();
              break;
            case 3:
              message.output = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDominoOp);
        message.key = object.key !== void 0 && object.key !== null ? String(object.key) : "";
        message.input = object.input !== void 0 && object.input !== null ? String(object.input) : "";
        message.output = object.output !== void 0 && object.output !== null ? String(object.output) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.input !== void 0 && (obj.input = message.input);
        message.output !== void 0 && (obj.output = message.output);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseDominoOp);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.input = (_b = object.input) !== null && _b !== void 0 ? _b : "";
        message.output = (_c = object.output) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseProofOp = { type: "" };
    exports.ProofOp = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
          writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseProofOp);
        message.key = new Uint8Array();
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.key = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseProofOp);
        message.type = object.type !== void 0 && object.type !== null ? String(object.type) : "";
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseProofOp);
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : "";
        message.key = (_b = object.key) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var baseProofOps = {};
    exports.ProofOps = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.ops) {
          exports.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseProofOps);
        message.ops = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseProofOps);
        message.ops = ((_a = object.ops) !== null && _a !== void 0 ? _a : []).map((e) => exports.ProofOp.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.ops) {
          obj.ops = message.ops.map((e) => e ? exports.ProofOp.toJSON(e) : void 0);
        } else {
          obj.ops = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseProofOps);
        message.ops = ((_a = object.ops) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ProofOp.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/tendermint/version/types.js
var require_types = __commonJS({
  "node_modules/cosmjs-types/tendermint/version/types.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Consensus = exports.App = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "tendermint.version";
    var baseApp = { protocol: long_1.default.UZERO, software: "" };
    exports.App = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.protocol.isZero()) {
          writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
          writer.uint32(18).string(message.software);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseApp);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = reader.uint64();
              break;
            case 2:
              message.software = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseApp);
        message.protocol = object.protocol !== void 0 && object.protocol !== null ? long_1.default.fromString(object.protocol) : long_1.default.UZERO;
        message.software = object.software !== void 0 && object.software !== null ? String(object.software) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = (message.protocol || long_1.default.UZERO).toString());
        message.software !== void 0 && (obj.software = message.software);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseApp);
        message.protocol = object.protocol !== void 0 && object.protocol !== null ? long_1.default.fromValue(object.protocol) : long_1.default.UZERO;
        message.software = (_a = object.software) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseConsensus = { block: long_1.default.UZERO, app: long_1.default.UZERO };
    exports.Consensus = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.block.isZero()) {
          writer.uint32(8).uint64(message.block);
        }
        if (!message.app.isZero()) {
          writer.uint32(16).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConsensus);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = reader.uint64();
              break;
            case 2:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseConsensus);
        message.block = object.block !== void 0 && object.block !== null ? long_1.default.fromString(object.block) : long_1.default.UZERO;
        message.app = object.app !== void 0 && object.app !== null ? long_1.default.fromString(object.app) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = (message.block || long_1.default.UZERO).toString());
        message.app !== void 0 && (obj.app = (message.app || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseConsensus);
        message.block = object.block !== void 0 && object.block !== null ? long_1.default.fromValue(object.block) : long_1.default.UZERO;
        message.app = object.app !== void 0 && object.app !== null ? long_1.default.fromValue(object.app) : long_1.default.UZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/tendermint/crypto/keys.js
var require_keys = __commonJS({
  "node_modules/cosmjs-types/tendermint/crypto/keys.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PublicKey = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "tendermint.crypto";
    var basePublicKey = {};
    exports.PublicKey = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ed25519 !== void 0) {
          writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== void 0) {
          writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePublicKey);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ed25519 = reader.bytes();
              break;
            case 2:
              message.secp256k1 = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePublicKey);
        message.ed25519 = object.ed25519 !== void 0 && object.ed25519 !== null ? bytesFromBase64(object.ed25519) : void 0;
        message.secp256k1 = object.secp256k1 !== void 0 && object.secp256k1 !== null ? bytesFromBase64(object.secp256k1) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.ed25519 !== void 0 && (obj.ed25519 = message.ed25519 !== void 0 ? base64FromBytes(message.ed25519) : void 0);
        message.secp256k1 !== void 0 && (obj.secp256k1 = message.secp256k1 !== void 0 ? base64FromBytes(message.secp256k1) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, basePublicKey);
        message.ed25519 = (_a = object.ed25519) !== null && _a !== void 0 ? _a : void 0;
        message.secp256k1 = (_b = object.secp256k1) !== null && _b !== void 0 ? _b : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/tendermint/types/validator.js
var require_validator = __commonJS({
  "node_modules/cosmjs-types/tendermint/types/validator.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleValidator = exports.Validator = exports.ValidatorSet = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var keys_1 = require_keys();
    exports.protobufPackage = "tendermint.types";
    var baseValidatorSet = { totalVotingPower: long_1.default.ZERO };
    exports.ValidatorSet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          exports.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== void 0) {
          exports.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (!message.totalVotingPower.isZero()) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorSet);
        message.validators = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(exports.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.proposer = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseValidatorSet);
        message.validators = ((_a = object.validators) !== null && _a !== void 0 ? _a : []).map((e) => exports.Validator.fromJSON(e));
        message.proposer = object.proposer !== void 0 && object.proposer !== null ? exports.Validator.fromJSON(object.proposer) : void 0;
        message.totalVotingPower = object.totalVotingPower !== void 0 && object.totalVotingPower !== null ? long_1.default.fromString(object.totalVotingPower) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer ? exports.Validator.toJSON(message.proposer) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidatorSet);
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Validator.fromPartial(e))) || [];
        message.proposer = object.proposer !== void 0 && object.proposer !== null ? exports.Validator.fromPartial(object.proposer) : void 0;
        message.totalVotingPower = object.totalVotingPower !== void 0 && object.totalVotingPower !== null ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO;
        return message;
      }
    };
    var baseValidator = { votingPower: long_1.default.ZERO, proposerPriority: long_1.default.ZERO };
    exports.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (!message.votingPower.isZero()) {
          writer.uint32(24).int64(message.votingPower);
        }
        if (!message.proposerPriority.isZero()) {
          writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidator);
        message.address = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 2:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPower = reader.int64();
              break;
            case 4:
              message.proposerPriority = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseValidator);
        message.address = object.address !== void 0 && object.address !== null ? bytesFromBase64(object.address) : new Uint8Array();
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromJSON(object.pubKey) : void 0;
        message.votingPower = object.votingPower !== void 0 && object.votingPower !== null ? long_1.default.fromString(object.votingPower) : long_1.default.ZERO;
        message.proposerPriority = object.proposerPriority !== void 0 && object.proposerPriority !== null ? long_1.default.fromString(object.proposerPriority) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = base64FromBytes(message.address !== void 0 ? message.address : new Uint8Array()));
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || long_1.default.ZERO).toString());
        message.proposerPriority !== void 0 && (obj.proposerPriority = (message.proposerPriority || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidator);
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : void 0;
        message.votingPower = object.votingPower !== void 0 && object.votingPower !== null ? long_1.default.fromValue(object.votingPower) : long_1.default.ZERO;
        message.proposerPriority = object.proposerPriority !== void 0 && object.proposerPriority !== null ? long_1.default.fromValue(object.proposerPriority) : long_1.default.ZERO;
        return message;
      }
    };
    var baseSimpleValidator = { votingPower: long_1.default.ZERO };
    exports.SimpleValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (!message.votingPower.isZero()) {
          writer.uint32(16).int64(message.votingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSimpleValidator);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.votingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseSimpleValidator);
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromJSON(object.pubKey) : void 0;
        message.votingPower = object.votingPower !== void 0 && object.votingPower !== null ? long_1.default.fromString(object.votingPower) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseSimpleValidator);
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : void 0;
        message.votingPower = object.votingPower !== void 0 && object.votingPower !== null ? long_1.default.fromValue(object.votingPower) : long_1.default.ZERO;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/tendermint/types/types.js
var require_types2 = __commonJS({
  "node_modules/cosmjs-types/tendermint/types/types.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TxProof = exports.BlockMeta = exports.LightBlock = exports.SignedHeader = exports.Proposal = exports.CommitSig = exports.Commit = exports.Vote = exports.Data = exports.Header = exports.BlockID = exports.Part = exports.PartSetHeader = exports.signedMsgTypeToJSON = exports.signedMsgTypeFromJSON = exports.SignedMsgType = exports.blockIDFlagToJSON = exports.blockIDFlagFromJSON = exports.BlockIDFlag = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var proof_1 = require_proof();
    var types_1 = require_types();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    exports.protobufPackage = "tendermint.types";
    var BlockIDFlag;
    (function(BlockIDFlag2) {
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
      BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BlockIDFlag = exports.BlockIDFlag || (exports.BlockIDFlag = {}));
    function blockIDFlagFromJSON(object) {
      switch (object) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
          return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
          return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
          return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
          return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BlockIDFlag.UNRECOGNIZED;
      }
    }
    exports.blockIDFlagFromJSON = blockIDFlagFromJSON;
    function blockIDFlagToJSON(object) {
      switch (object) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
          return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
          return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
          return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
          return "BLOCK_ID_FLAG_NIL";
        default:
          return "UNKNOWN";
      }
    }
    exports.blockIDFlagToJSON = blockIDFlagToJSON;
    var SignedMsgType;
    (function(SignedMsgType2) {
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
      SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignedMsgType = exports.SignedMsgType || (exports.SignedMsgType = {}));
    function signedMsgTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
          return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
          return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
          return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
          return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignedMsgType.UNRECOGNIZED;
      }
    }
    exports.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
    function signedMsgTypeToJSON(object) {
      switch (object) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
          return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
          return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
          return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
          return "SIGNED_MSG_TYPE_PROPOSAL";
        default:
          return "UNKNOWN";
      }
    }
    exports.signedMsgTypeToJSON = signedMsgTypeToJSON;
    var basePartSetHeader = { total: 0 };
    exports.PartSetHeader = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.total !== 0) {
          writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
          writer.uint32(18).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePartSetHeader);
        message.hash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.uint32();
              break;
            case 2:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePartSetHeader);
        message.total = object.total !== void 0 && object.total !== null ? Number(object.total) : 0;
        message.hash = object.hash !== void 0 && object.hash !== null ? bytesFromBase64(object.hash) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = message.total);
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, basePartSetHeader);
        message.total = (_a = object.total) !== null && _a !== void 0 ? _a : 0;
        message.hash = (_b = object.hash) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var basePart = { index: 0 };
    exports.Part = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
          writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePart);
        message.bytes = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.bytes = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePart);
        message.index = object.index !== void 0 && object.index !== null ? Number(object.index) : 0;
        message.bytes = object.bytes !== void 0 && object.bytes !== null ? bytesFromBase64(object.bytes) : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? proof_1.Proof.fromJSON(object.proof) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = message.index);
        message.bytes !== void 0 && (obj.bytes = base64FromBytes(message.bytes !== void 0 ? message.bytes : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, basePart);
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.bytes = (_b = object.bytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? proof_1.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    var baseBlockID = {};
    exports.BlockID = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== void 0) {
          exports.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBlockID);
        message.hash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.partSetHeader = exports.PartSetHeader.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseBlockID);
        message.hash = object.hash !== void 0 && object.hash !== null ? bytesFromBase64(object.hash) : new Uint8Array();
        message.partSetHeader = object.partSetHeader !== void 0 && object.partSetHeader !== null ? exports.PartSetHeader.fromJSON(object.partSetHeader) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.partSetHeader !== void 0 && (obj.partSetHeader = message.partSetHeader ? exports.PartSetHeader.toJSON(message.partSetHeader) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseBlockID);
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.partSetHeader = object.partSetHeader !== void 0 && object.partSetHeader !== null ? exports.PartSetHeader.fromPartial(object.partSetHeader) : void 0;
        return message;
      }
    };
    var baseHeader = { chainId: "", height: long_1.default.ZERO };
    exports.Header = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.version !== void 0) {
          types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (!message.height.isZero()) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== void 0) {
          exports.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
          writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
          writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
          writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
          writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
          writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
          writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHeader);
        message.lastCommitHash = new Uint8Array();
        message.dataHash = new Uint8Array();
        message.validatorsHash = new Uint8Array();
        message.nextValidatorsHash = new Uint8Array();
        message.consensusHash = new Uint8Array();
        message.appHash = new Uint8Array();
        message.lastResultsHash = new Uint8Array();
        message.evidenceHash = new Uint8Array();
        message.proposerAddress = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = types_1.Consensus.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.lastBlockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.lastCommitHash = reader.bytes();
              break;
            case 7:
              message.dataHash = reader.bytes();
              break;
            case 8:
              message.validatorsHash = reader.bytes();
              break;
            case 9:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 10:
              message.consensusHash = reader.bytes();
              break;
            case 11:
              message.appHash = reader.bytes();
              break;
            case 12:
              message.lastResultsHash = reader.bytes();
              break;
            case 13:
              message.evidenceHash = reader.bytes();
              break;
            case 14:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseHeader);
        message.version = object.version !== void 0 && object.version !== null ? types_1.Consensus.fromJSON(object.version) : void 0;
        message.chainId = object.chainId !== void 0 && object.chainId !== null ? String(object.chainId) : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.time = object.time !== void 0 && object.time !== null ? fromJsonTimestamp(object.time) : void 0;
        message.lastBlockId = object.lastBlockId !== void 0 && object.lastBlockId !== null ? exports.BlockID.fromJSON(object.lastBlockId) : void 0;
        message.lastCommitHash = object.lastCommitHash !== void 0 && object.lastCommitHash !== null ? bytesFromBase64(object.lastCommitHash) : new Uint8Array();
        message.dataHash = object.dataHash !== void 0 && object.dataHash !== null ? bytesFromBase64(object.dataHash) : new Uint8Array();
        message.validatorsHash = object.validatorsHash !== void 0 && object.validatorsHash !== null ? bytesFromBase64(object.validatorsHash) : new Uint8Array();
        message.nextValidatorsHash = object.nextValidatorsHash !== void 0 && object.nextValidatorsHash !== null ? bytesFromBase64(object.nextValidatorsHash) : new Uint8Array();
        message.consensusHash = object.consensusHash !== void 0 && object.consensusHash !== null ? bytesFromBase64(object.consensusHash) : new Uint8Array();
        message.appHash = object.appHash !== void 0 && object.appHash !== null ? bytesFromBase64(object.appHash) : new Uint8Array();
        message.lastResultsHash = object.lastResultsHash !== void 0 && object.lastResultsHash !== null ? bytesFromBase64(object.lastResultsHash) : new Uint8Array();
        message.evidenceHash = object.evidenceHash !== void 0 && object.evidenceHash !== null ? bytesFromBase64(object.evidenceHash) : new Uint8Array();
        message.proposerAddress = object.proposerAddress !== void 0 && object.proposerAddress !== null ? bytesFromBase64(object.proposerAddress) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.time !== void 0 && (obj.time = fromTimestamp(message.time).toISOString());
        message.lastBlockId !== void 0 && (obj.lastBlockId = message.lastBlockId ? exports.BlockID.toJSON(message.lastBlockId) : void 0);
        message.lastCommitHash !== void 0 && (obj.lastCommitHash = base64FromBytes(message.lastCommitHash !== void 0 ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== void 0 && (obj.dataHash = base64FromBytes(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== void 0 && (obj.validatorsHash = base64FromBytes(message.validatorsHash !== void 0 ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = base64FromBytes(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== void 0 && (obj.consensusHash = base64FromBytes(message.consensusHash !== void 0 ? message.consensusHash : new Uint8Array()));
        message.appHash !== void 0 && (obj.appHash = base64FromBytes(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== void 0 && (obj.lastResultsHash = base64FromBytes(message.lastResultsHash !== void 0 ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== void 0 && (obj.evidenceHash = base64FromBytes(message.evidenceHash !== void 0 ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = base64FromBytes(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const message = Object.assign({}, baseHeader);
        message.version = object.version !== void 0 && object.version !== null ? types_1.Consensus.fromPartial(object.version) : void 0;
        message.chainId = (_a = object.chainId) !== null && _a !== void 0 ? _a : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.time = object.time !== void 0 && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : void 0;
        message.lastBlockId = object.lastBlockId !== void 0 && object.lastBlockId !== null ? exports.BlockID.fromPartial(object.lastBlockId) : void 0;
        message.lastCommitHash = (_b = object.lastCommitHash) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.dataHash = (_c = object.dataHash) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.validatorsHash = (_d = object.validatorsHash) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.nextValidatorsHash = (_e = object.nextValidatorsHash) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.consensusHash = (_f = object.consensusHash) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.appHash = (_g = object.appHash) !== null && _g !== void 0 ? _g : new Uint8Array();
        message.lastResultsHash = (_h = object.lastResultsHash) !== null && _h !== void 0 ? _h : new Uint8Array();
        message.evidenceHash = (_j = object.evidenceHash) !== null && _j !== void 0 ? _j : new Uint8Array();
        message.proposerAddress = (_k = object.proposerAddress) !== null && _k !== void 0 ? _k : new Uint8Array();
        return message;
      }
    };
    var baseData = {};
    exports.Data = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.txs) {
          writer.uint32(10).bytes(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseData);
        message.txs = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseData);
        message.txs = ((_a = object.txs) !== null && _a !== void 0 ? _a : []).map((e) => bytesFromBase64(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => base64FromBytes(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseData);
        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    var baseVote = { type: 0, height: long_1.default.ZERO, round: 0, validatorIndex: 0 };
    exports.Vote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (!message.height.isZero()) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
          writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
          writer.uint32(66).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVote);
        message.validatorAddress = new Uint8Array();
        message.signature = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.validatorAddress = reader.bytes();
              break;
            case 7:
              message.validatorIndex = reader.int32();
              break;
            case 8:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseVote);
        message.type = object.type !== void 0 && object.type !== null ? signedMsgTypeFromJSON(object.type) : 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.round = object.round !== void 0 && object.round !== null ? Number(object.round) : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports.BlockID.fromJSON(object.blockId) : void 0;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? fromJsonTimestamp(object.timestamp) : void 0;
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? bytesFromBase64(object.validatorAddress) : new Uint8Array();
        message.validatorIndex = object.validatorIndex !== void 0 && object.validatorIndex !== null ? Number(object.validatorIndex) : 0;
        message.signature = object.signature !== void 0 && object.signature !== null ? bytesFromBase64(object.signature) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.round !== void 0 && (obj.round = message.round);
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        message.validatorAddress !== void 0 && (obj.validatorAddress = base64FromBytes(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== void 0 && (obj.validatorIndex = message.validatorIndex);
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseVote);
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.round = (_b = object.round) !== null && _b !== void 0 ? _b : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports.BlockID.fromPartial(object.blockId) : void 0;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.validatorIndex = (_d = object.validatorIndex) !== null && _d !== void 0 ? _d : 0;
        message.signature = (_e = object.signature) !== null && _e !== void 0 ? _e : new Uint8Array();
        return message;
      }
    };
    var baseCommit = { height: long_1.default.ZERO, round: 0 };
    exports.Commit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.signatures) {
          exports.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCommit);
        message.signatures = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.signatures.push(exports.CommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseCommit);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.round = object.round !== void 0 && object.round !== null ? Number(object.round) : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports.BlockID.fromJSON(object.blockId) : void 0;
        message.signatures = ((_a = object.signatures) !== null && _a !== void 0 ? _a : []).map((e) => exports.CommitSig.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.round !== void 0 && (obj.round = message.round);
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports.CommitSig.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseCommit);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.round = (_a = object.round) !== null && _a !== void 0 ? _a : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports.BlockID.fromPartial(object.blockId) : void 0;
        message.signatures = ((_b = object.signatures) === null || _b === void 0 ? void 0 : _b.map((e) => exports.CommitSig.fromPartial(e))) || [];
        return message;
      }
    };
    var baseCommitSig = { blockIdFlag: 0 };
    exports.CommitSig = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCommitSig);
        message.validatorAddress = new Uint8Array();
        message.signature = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCommitSig);
        message.blockIdFlag = object.blockIdFlag !== void 0 && object.blockIdFlag !== null ? blockIDFlagFromJSON(object.blockIdFlag) : 0;
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? bytesFromBase64(object.validatorAddress) : new Uint8Array();
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? fromJsonTimestamp(object.timestamp) : void 0;
        message.signature = object.signature !== void 0 && object.signature !== null ? bytesFromBase64(object.signature) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = base64FromBytes(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseCommitSig);
        message.blockIdFlag = (_a = object.blockIdFlag) !== null && _a !== void 0 ? _a : 0;
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        message.signature = (_c = object.signature) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var baseProposal = { type: 0, height: long_1.default.ZERO, round: 0, polRound: 0 };
    exports.Proposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (!message.height.isZero()) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
          writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(58).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseProposal);
        message.signature = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.polRound = reader.int32();
              break;
            case 5:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseProposal);
        message.type = object.type !== void 0 && object.type !== null ? signedMsgTypeFromJSON(object.type) : 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.round = object.round !== void 0 && object.round !== null ? Number(object.round) : 0;
        message.polRound = object.polRound !== void 0 && object.polRound !== null ? Number(object.polRound) : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports.BlockID.fromJSON(object.blockId) : void 0;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? fromJsonTimestamp(object.timestamp) : void 0;
        message.signature = object.signature !== void 0 && object.signature !== null ? bytesFromBase64(object.signature) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.round !== void 0 && (obj.round = message.round);
        message.polRound !== void 0 && (obj.polRound = message.polRound);
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = base64FromBytes(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseProposal);
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.round = (_b = object.round) !== null && _b !== void 0 ? _b : 0;
        message.polRound = (_c = object.polRound) !== null && _c !== void 0 ? _c : 0;
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports.BlockID.fromPartial(object.blockId) : void 0;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        message.signature = (_d = object.signature) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    var baseSignedHeader = {};
    exports.SignedHeader = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          exports.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSignedHeader);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = exports.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.commit = exports.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseSignedHeader);
        message.header = object.header !== void 0 && object.header !== null ? exports.Header.fromJSON(object.header) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports.Commit.fromJSON(object.commit) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? exports.Header.toJSON(message.header) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.Commit.toJSON(message.commit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseSignedHeader);
        message.header = object.header !== void 0 && object.header !== null ? exports.Header.fromPartial(object.header) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports.Commit.fromPartial(object.commit) : void 0;
        return message;
      }
    };
    var baseLightBlock = {};
    exports.LightBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signedHeader !== void 0) {
          exports.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseLightBlock);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = exports.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseLightBlock);
        message.signedHeader = object.signedHeader !== void 0 && object.signedHeader !== null ? exports.SignedHeader.fromJSON(object.signedHeader) : void 0;
        message.validatorSet = object.validatorSet !== void 0 && object.validatorSet !== null ? validator_1.ValidatorSet.fromJSON(object.validatorSet) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? exports.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseLightBlock);
        message.signedHeader = object.signedHeader !== void 0 && object.signedHeader !== null ? exports.SignedHeader.fromPartial(object.signedHeader) : void 0;
        message.validatorSet = object.validatorSet !== void 0 && object.validatorSet !== null ? validator_1.ValidatorSet.fromPartial(object.validatorSet) : void 0;
        return message;
      }
    };
    var baseBlockMeta = { blockSize: long_1.default.ZERO, numTxs: long_1.default.ZERO };
    exports.BlockMeta = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (!message.blockSize.isZero()) {
          writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== void 0) {
          exports.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (!message.numTxs.isZero()) {
          writer.uint32(32).int64(message.numTxs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBlockMeta);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 2:
              message.blockSize = reader.int64();
              break;
            case 3:
              message.header = exports.Header.decode(reader, reader.uint32());
              break;
            case 4:
              message.numTxs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseBlockMeta);
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports.BlockID.fromJSON(object.blockId) : void 0;
        message.blockSize = object.blockSize !== void 0 && object.blockSize !== null ? long_1.default.fromString(object.blockSize) : long_1.default.ZERO;
        message.header = object.header !== void 0 && object.header !== null ? exports.Header.fromJSON(object.header) : void 0;
        message.numTxs = object.numTxs !== void 0 && object.numTxs !== null ? long_1.default.fromString(object.numTxs) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.blockSize !== void 0 && (obj.blockSize = (message.blockSize || long_1.default.ZERO).toString());
        message.header !== void 0 && (obj.header = message.header ? exports.Header.toJSON(message.header) : void 0);
        message.numTxs !== void 0 && (obj.numTxs = (message.numTxs || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseBlockMeta);
        message.blockId = object.blockId !== void 0 && object.blockId !== null ? exports.BlockID.fromPartial(object.blockId) : void 0;
        message.blockSize = object.blockSize !== void 0 && object.blockSize !== null ? long_1.default.fromValue(object.blockSize) : long_1.default.ZERO;
        message.header = object.header !== void 0 && object.header !== null ? exports.Header.fromPartial(object.header) : void 0;
        message.numTxs = object.numTxs !== void 0 && object.numTxs !== null ? long_1.default.fromValue(object.numTxs) : long_1.default.ZERO;
        return message;
      }
    };
    var baseTxProof = {};
    exports.TxProof = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rootHash.length !== 0) {
          writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTxProof);
        message.rootHash = new Uint8Array();
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rootHash = reader.bytes();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseTxProof);
        message.rootHash = object.rootHash !== void 0 && object.rootHash !== null ? bytesFromBase64(object.rootHash) : new Uint8Array();
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? proof_1.Proof.fromJSON(object.proof) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.rootHash !== void 0 && (obj.rootHash = base64FromBytes(message.rootHash !== void 0 ? message.rootHash : new Uint8Array()));
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseTxProof);
        message.rootHash = (_a = object.rootHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proof = object.proof !== void 0 && object.proof !== null ? proof_1.Proof.fromPartial(object.proof) : void 0;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js
var require_tendermint = __commonJS({
  "node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Fraction = exports.Header = exports.Misbehaviour = exports.ConsensusState = exports.ClientState = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var duration_1 = require_duration();
    var client_1 = require_client();
    var timestamp_1 = require_timestamp();
    var commitment_1 = require_commitment();
    var types_1 = require_types2();
    var validator_1 = require_validator();
    var proofs_1 = require_proofs2();
    exports.protobufPackage = "ibc.lightclients.tendermint.v1";
    var baseClientState = {
      chainId: "",
      upgradePath: "",
      allowUpdateAfterExpiry: false,
      allowUpdateAfterMisbehaviour: false
    };
    exports.ClientState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chainId !== "") {
          writer.uint32(10).string(message.chainId);
        }
        if (message.trustLevel !== void 0) {
          exports.Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustingPeriod !== void 0) {
          duration_1.Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.unbondingPeriod !== void 0) {
          duration_1.Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
        }
        if (message.maxClockDrift !== void 0) {
          duration_1.Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
        }
        if (message.frozenHeight !== void 0) {
          client_1.Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.latestHeight !== void 0) {
          client_1.Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
        }
        for (const v of message.proofSpecs) {
          proofs_1.ProofSpec.encode(v, writer.uint32(66).fork()).ldelim();
        }
        for (const v of message.upgradePath) {
          writer.uint32(74).string(v);
        }
        if (message.allowUpdateAfterExpiry === true) {
          writer.uint32(80).bool(message.allowUpdateAfterExpiry);
        }
        if (message.allowUpdateAfterMisbehaviour === true) {
          writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientState);
        message.proofSpecs = [];
        message.upgradePath = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chainId = reader.string();
              break;
            case 2:
              message.trustLevel = exports.Fraction.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.unbondingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 5:
              message.maxClockDrift = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 6:
              message.frozenHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.latestHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofSpecs.push(proofs_1.ProofSpec.decode(reader, reader.uint32()));
              break;
            case 9:
              message.upgradePath.push(reader.string());
              break;
            case 10:
              message.allowUpdateAfterExpiry = reader.bool();
              break;
            case 11:
              message.allowUpdateAfterMisbehaviour = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a, _b;
        const message = Object.assign({}, baseClientState);
        message.chainId = object.chainId !== void 0 && object.chainId !== null ? String(object.chainId) : "";
        message.trustLevel = object.trustLevel !== void 0 && object.trustLevel !== null ? exports.Fraction.fromJSON(object.trustLevel) : void 0;
        message.trustingPeriod = object.trustingPeriod !== void 0 && object.trustingPeriod !== null ? duration_1.Duration.fromJSON(object.trustingPeriod) : void 0;
        message.unbondingPeriod = object.unbondingPeriod !== void 0 && object.unbondingPeriod !== null ? duration_1.Duration.fromJSON(object.unbondingPeriod) : void 0;
        message.maxClockDrift = object.maxClockDrift !== void 0 && object.maxClockDrift !== null ? duration_1.Duration.fromJSON(object.maxClockDrift) : void 0;
        message.frozenHeight = object.frozenHeight !== void 0 && object.frozenHeight !== null ? client_1.Height.fromJSON(object.frozenHeight) : void 0;
        message.latestHeight = object.latestHeight !== void 0 && object.latestHeight !== null ? client_1.Height.fromJSON(object.latestHeight) : void 0;
        message.proofSpecs = ((_a = object.proofSpecs) !== null && _a !== void 0 ? _a : []).map((e) => proofs_1.ProofSpec.fromJSON(e));
        message.upgradePath = ((_b = object.upgradePath) !== null && _b !== void 0 ? _b : []).map((e) => String(e));
        message.allowUpdateAfterExpiry = object.allowUpdateAfterExpiry !== void 0 && object.allowUpdateAfterExpiry !== null ? Boolean(object.allowUpdateAfterExpiry) : false;
        message.allowUpdateAfterMisbehaviour = object.allowUpdateAfterMisbehaviour !== void 0 && object.allowUpdateAfterMisbehaviour !== null ? Boolean(object.allowUpdateAfterMisbehaviour) : false;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.trustLevel !== void 0 && (obj.trustLevel = message.trustLevel ? exports.Fraction.toJSON(message.trustLevel) : void 0);
        message.trustingPeriod !== void 0 && (obj.trustingPeriod = message.trustingPeriod ? duration_1.Duration.toJSON(message.trustingPeriod) : void 0);
        message.unbondingPeriod !== void 0 && (obj.unbondingPeriod = message.unbondingPeriod ? duration_1.Duration.toJSON(message.unbondingPeriod) : void 0);
        message.maxClockDrift !== void 0 && (obj.maxClockDrift = message.maxClockDrift ? duration_1.Duration.toJSON(message.maxClockDrift) : void 0);
        message.frozenHeight !== void 0 && (obj.frozenHeight = message.frozenHeight ? client_1.Height.toJSON(message.frozenHeight) : void 0);
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight ? client_1.Height.toJSON(message.latestHeight) : void 0);
        if (message.proofSpecs) {
          obj.proofSpecs = message.proofSpecs.map((e) => e ? proofs_1.ProofSpec.toJSON(e) : void 0);
        } else {
          obj.proofSpecs = [];
        }
        if (message.upgradePath) {
          obj.upgradePath = message.upgradePath.map((e) => e);
        } else {
          obj.upgradePath = [];
        }
        message.allowUpdateAfterExpiry !== void 0 && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
        message.allowUpdateAfterMisbehaviour !== void 0 && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseClientState);
        message.chainId = (_a = object.chainId) !== null && _a !== void 0 ? _a : "";
        message.trustLevel = object.trustLevel !== void 0 && object.trustLevel !== null ? exports.Fraction.fromPartial(object.trustLevel) : void 0;
        message.trustingPeriod = object.trustingPeriod !== void 0 && object.trustingPeriod !== null ? duration_1.Duration.fromPartial(object.trustingPeriod) : void 0;
        message.unbondingPeriod = object.unbondingPeriod !== void 0 && object.unbondingPeriod !== null ? duration_1.Duration.fromPartial(object.unbondingPeriod) : void 0;
        message.maxClockDrift = object.maxClockDrift !== void 0 && object.maxClockDrift !== null ? duration_1.Duration.fromPartial(object.maxClockDrift) : void 0;
        message.frozenHeight = object.frozenHeight !== void 0 && object.frozenHeight !== null ? client_1.Height.fromPartial(object.frozenHeight) : void 0;
        message.latestHeight = object.latestHeight !== void 0 && object.latestHeight !== null ? client_1.Height.fromPartial(object.latestHeight) : void 0;
        message.proofSpecs = ((_b = object.proofSpecs) === null || _b === void 0 ? void 0 : _b.map((e) => proofs_1.ProofSpec.fromPartial(e))) || [];
        message.upgradePath = ((_c = object.upgradePath) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.allowUpdateAfterExpiry = (_d = object.allowUpdateAfterExpiry) !== null && _d !== void 0 ? _d : false;
        message.allowUpdateAfterMisbehaviour = (_e = object.allowUpdateAfterMisbehaviour) !== null && _e !== void 0 ? _e : false;
        return message;
      }
    };
    var baseConsensusState = {};
    exports.ConsensusState = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(10).fork()).ldelim();
        }
        if (message.root !== void 0) {
          commitment_1.MerkleRoot.encode(message.root, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(26).bytes(message.nextValidatorsHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConsensusState);
        message.nextValidatorsHash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.root = commitment_1.MerkleRoot.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextValidatorsHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseConsensusState);
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? fromJsonTimestamp(object.timestamp) : void 0;
        message.root = object.root !== void 0 && object.root !== null ? commitment_1.MerkleRoot.fromJSON(object.root) : void 0;
        message.nextValidatorsHash = object.nextValidatorsHash !== void 0 && object.nextValidatorsHash !== null ? bytesFromBase64(object.nextValidatorsHash) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.timestamp !== void 0 && (obj.timestamp = fromTimestamp(message.timestamp).toISOString());
        message.root !== void 0 && (obj.root = message.root ? commitment_1.MerkleRoot.toJSON(message.root) : void 0);
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = base64FromBytes(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseConsensusState);
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? timestamp_1.Timestamp.fromPartial(object.timestamp) : void 0;
        message.root = object.root !== void 0 && object.root !== null ? commitment_1.MerkleRoot.fromPartial(object.root) : void 0;
        message.nextValidatorsHash = (_a = object.nextValidatorsHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var baseMisbehaviour = { clientId: "" };
    exports.Misbehaviour = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.header1 !== void 0) {
          exports.Header.encode(message.header1, writer.uint32(18).fork()).ldelim();
        }
        if (message.header2 !== void 0) {
          exports.Header.encode(message.header2, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMisbehaviour);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.header1 = exports.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.header2 = exports.Header.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMisbehaviour);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.header1 = object.header1 !== void 0 && object.header1 !== null ? exports.Header.fromJSON(object.header1) : void 0;
        message.header2 = object.header2 !== void 0 && object.header2 !== null ? exports.Header.fromJSON(object.header2) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header1 !== void 0 && (obj.header1 = message.header1 ? exports.Header.toJSON(message.header1) : void 0);
        message.header2 !== void 0 && (obj.header2 = message.header2 ? exports.Header.toJSON(message.header2) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseMisbehaviour);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.header1 = object.header1 !== void 0 && object.header1 !== null ? exports.Header.fromPartial(object.header1) : void 0;
        message.header2 = object.header2 !== void 0 && object.header2 !== null ? exports.Header.fromPartial(object.header2) : void 0;
        return message;
      }
    };
    var baseHeader = {};
    exports.Header = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signedHeader !== void 0) {
          types_1.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustedHeight !== void 0) {
          client_1.Height.encode(message.trustedHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.trustedValidators !== void 0) {
          validator_1.ValidatorSet.encode(message.trustedValidators, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHeader);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = types_1.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustedHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.trustedValidators = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseHeader);
        message.signedHeader = object.signedHeader !== void 0 && object.signedHeader !== null ? types_1.SignedHeader.fromJSON(object.signedHeader) : void 0;
        message.validatorSet = object.validatorSet !== void 0 && object.validatorSet !== null ? validator_1.ValidatorSet.fromJSON(object.validatorSet) : void 0;
        message.trustedHeight = object.trustedHeight !== void 0 && object.trustedHeight !== null ? client_1.Height.fromJSON(object.trustedHeight) : void 0;
        message.trustedValidators = object.trustedValidators !== void 0 && object.trustedValidators !== null ? validator_1.ValidatorSet.fromJSON(object.trustedValidators) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? types_1.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        message.trustedHeight !== void 0 && (obj.trustedHeight = message.trustedHeight ? client_1.Height.toJSON(message.trustedHeight) : void 0);
        message.trustedValidators !== void 0 && (obj.trustedValidators = message.trustedValidators ? validator_1.ValidatorSet.toJSON(message.trustedValidators) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseHeader);
        message.signedHeader = object.signedHeader !== void 0 && object.signedHeader !== null ? types_1.SignedHeader.fromPartial(object.signedHeader) : void 0;
        message.validatorSet = object.validatorSet !== void 0 && object.validatorSet !== null ? validator_1.ValidatorSet.fromPartial(object.validatorSet) : void 0;
        message.trustedHeight = object.trustedHeight !== void 0 && object.trustedHeight !== null ? client_1.Height.fromPartial(object.trustedHeight) : void 0;
        message.trustedValidators = object.trustedValidators !== void 0 && object.trustedValidators !== null ? validator_1.ValidatorSet.fromPartial(object.trustedValidators) : void 0;
        return message;
      }
    };
    var baseFraction = { numerator: long_1.default.UZERO, denominator: long_1.default.UZERO };
    exports.Fraction = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.numerator.isZero()) {
          writer.uint32(8).uint64(message.numerator);
        }
        if (!message.denominator.isZero()) {
          writer.uint32(16).uint64(message.denominator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseFraction);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.numerator = reader.uint64();
              break;
            case 2:
              message.denominator = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseFraction);
        message.numerator = object.numerator !== void 0 && object.numerator !== null ? long_1.default.fromString(object.numerator) : long_1.default.UZERO;
        message.denominator = object.denominator !== void 0 && object.denominator !== null ? long_1.default.fromString(object.denominator) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.numerator !== void 0 && (obj.numerator = (message.numerator || long_1.default.UZERO).toString());
        message.denominator !== void 0 && (obj.denominator = (message.denominator || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseFraction);
        message.numerator = object.numerator !== void 0 && object.numerator !== null ? long_1.default.fromValue(object.numerator) : long_1.default.UZERO;
        message.denominator = object.denominator !== void 0 && object.denominator !== null ? long_1.default.fromValue(object.denominator) : long_1.default.UZERO;
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/queries/ibc.js
var require_ibc = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/ibc.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupIbcExtension = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build3();
    var query_1 = require_query5();
    var channel_1 = require_channel();
    var query_2 = require_query6();
    var query_3 = require_query7();
    var query_4 = require_query8();
    var tendermint_1 = require_tendermint();
    var long_1 = __importDefault(require_long());
    var utils_1 = require_utils2();
    function decodeTendermintClientStateAny(clientState) {
      if ((clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ClientState.decode(clientState.value);
    }
    function decodeTendermintConsensusStateAny(clientState) {
      if ((clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl) !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState === null || clientState === void 0 ? void 0 : clientState.typeUrl}`);
      }
      return tendermint_1.ConsensusState.decode(clientState.value);
    }
    function setupIbcExtension(base) {
      const rpc = (0, utils_1.createProtobufRpcClient)(base);
      const channelQueryService = new query_2.QueryClientImpl(rpc);
      const clientQueryService = new query_3.QueryClientImpl(rpc);
      const connectionQueryService = new query_4.QueryClientImpl(rpc);
      const transferQueryService = new query_1.QueryClientImpl(rpc);
      return {
        ibc: {
          channel: {
            channel: async (portId, channelId) => channelQueryService.Channel({
              portId,
              channelId
            }),
            channels: async (paginationKey) => channelQueryService.Channels({
              pagination: (0, utils_1.createPagination)(paginationKey)
            }),
            allChannels: async () => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.Channels({
                  pagination: (0, utils_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                channels,
                height: response.height
              };
            },
            connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({
              connection,
              pagination: (0, utils_1.createPagination)(paginationKey)
            }),
            allConnectionChannels: async (connection) => {
              var _a;
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.ConnectionChannels({
                  connection,
                  pagination: (0, utils_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                channels,
                height: response.height
              };
            },
            clientState: async (portId, channelId) => channelQueryService.ChannelClientState({
              portId,
              channelId
            }),
            consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({
              portId,
              channelId,
              revisionNumber: long_1.default.fromNumber(revisionNumber, true),
              revisionHeight: long_1.default.fromNumber(revisionHeight, true)
            }),
            packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({
              portId,
              channelId,
              sequence
            }),
            packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({
              channelId,
              portId,
              pagination: (0, utils_1.createPagination)(paginationKey)
            }),
            allPacketCommitments: async (portId, channelId) => {
              var _a;
              const commitments = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketCommitments({
                  channelId,
                  portId,
                  pagination: (0, utils_1.createPagination)(key)
                });
                commitments.push(...response.commitments);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                commitments,
                height: response.height
              };
            },
            packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({
              portId,
              channelId,
              sequence: long_1.default.fromNumber(sequence, true)
            }),
            packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({
              portId,
              channelId,
              sequence: long_1.default.fromNumber(sequence, true)
            }),
            packetAcknowledgements: async (portId, channelId, paginationKey) => channelQueryService.PacketAcknowledgements({
              portId,
              channelId,
              pagination: (0, utils_1.createPagination)(paginationKey)
            }),
            allPacketAcknowledgements: async (portId, channelId) => {
              var _a;
              const acknowledgements = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketAcknowledgements({
                  channelId,
                  portId,
                  pagination: (0, utils_1.createPagination)(key)
                });
                acknowledgements.push(...response.acknowledgements);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                acknowledgements,
                height: response.height
              };
            },
            unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({
              portId,
              channelId,
              packetCommitmentSequences: packetCommitmentSequences.map((s) => long_1.default.fromNumber(s, true))
            }),
            unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({
              portId,
              channelId,
              packetAckSequences: packetAckSequences.map((s) => long_1.default.fromNumber(s, true))
            }),
            nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({
              portId,
              channelId
            })
          },
          client: {
            state: async (clientId) => clientQueryService.ClientState({ clientId }),
            states: async (paginationKey) => clientQueryService.ClientStates({
              pagination: (0, utils_1.createPagination)(paginationKey)
            }),
            allStates: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, utils_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                clientStates
              };
            },
            consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
              clientId,
              revisionHeight: consensusHeight !== void 0 ? long_1.default.fromNumber(consensusHeight, true) : void 0,
              latestHeight: consensusHeight === void 0
            })),
            consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({
              clientId,
              pagination: (0, utils_1.createPagination)(paginationKey)
            }),
            allConsensusStates: async (clientId) => {
              var _a;
              const consensusStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ConsensusStates({
                  clientId,
                  pagination: (0, utils_1.createPagination)(key)
                });
                consensusStates.push(...response.consensusStates);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                consensusStates
              };
            },
            params: async () => clientQueryService.ClientParams({}),
            stateTm: async (clientId) => {
              const response = await clientQueryService.ClientState({ clientId });
              return decodeTendermintClientStateAny(response.clientState);
            },
            statesTm: async (paginationKey) => {
              const { clientStates } = await clientQueryService.ClientStates({
                pagination: (0, utils_1.createPagination)(paginationKey)
              });
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            allStatesTm: async () => {
              var _a;
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, utils_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            consensusStateTm: async (clientId, consensusHeight) => {
              const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                clientId,
                revisionHeight: consensusHeight === null || consensusHeight === void 0 ? void 0 : consensusHeight.revisionHeight,
                revisionNumber: consensusHeight === null || consensusHeight === void 0 ? void 0 : consensusHeight.revisionNumber,
                latestHeight: consensusHeight === void 0
              }));
              return decodeTendermintConsensusStateAny(response.consensusState);
            }
          },
          connection: {
            connection: async (connectionId) => connectionQueryService.Connection({
              connectionId
            }),
            connections: async (paginationKey) => connectionQueryService.Connections({
              pagination: (0, utils_1.createPagination)(paginationKey)
            }),
            allConnections: async () => {
              var _a;
              const connections = [];
              let response;
              let key;
              do {
                response = await connectionQueryService.Connections({
                  pagination: (0, utils_1.createPagination)(key)
                });
                connections.push(...response.connections);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                connections,
                height: response.height
              };
            },
            clientConnections: async (clientId) => connectionQueryService.ClientConnections({
              clientId
            }),
            clientState: async (connectionId) => connectionQueryService.ConnectionClientState({
              connectionId
            }),
            consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
              connectionId,
              revisionHeight: long_1.default.fromNumber(revisionHeight, true)
            }))
          },
          transfer: {
            denomTrace: async (hash) => transferQueryService.DenomTrace({ hash }),
            denomTraces: async (paginationKey) => transferQueryService.DenomTraces({
              pagination: (0, utils_1.createPagination)(paginationKey)
            }),
            allDenomTraces: async () => {
              var _a;
              const denomTraces = [];
              let response;
              let key;
              do {
                response = await transferQueryService.DenomTraces({
                  pagination: (0, utils_1.createPagination)(key)
                });
                denomTraces.push(...response.denomTraces);
                key = (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.nextKey;
              } while (key && key.length);
              return {
                denomTraces
              };
            },
            params: async () => transferQueryService.Params({})
          },
          verified: {
            channel: {
              channel: async (portId, channelId) => {
                const key = (0, encoding_1.toAscii)(`channelEnds/ports/${portId}/channels/${channelId}`);
                const responseData = await base.queryVerified("ibc", key);
                return responseData.length ? channel_1.Channel.decode(responseData) : null;
              },
              packetCommitment: async (portId, channelId, sequence) => {
                const key = (0, encoding_1.toAscii)(`commitments/ports/${portId}/channels/${channelId}/packets/${sequence}`);
                const responseData = await base.queryVerified("ibc", key);
                return responseData;
              },
              packetAcknowledgement: async (portId, channelId, sequence) => {
                const key = (0, encoding_1.toAscii)(`acks/ports/${portId}/channels/${channelId}/acknowledgements/${sequence}`);
                const responseData = await base.queryVerified("ibc", key);
                return responseData;
              },
              nextSequenceReceive: async (portId, channelId) => {
                const key = (0, encoding_1.toAscii)(`seqAcks/ports/${portId}/channels/${channelId}/nextSequenceAck`);
                const responseData = await base.queryVerified("ibc", key);
                return responseData.length ? math_1.Uint64.fromBytes(responseData).toNumber() : null;
              }
            }
          }
        }
      };
    }
    exports.setupIbcExtension = setupIbcExtension;
  }
});

// node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js
var require_mint = __commonJS({
  "node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Minter = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    exports.protobufPackage = "cosmos.mint.v1beta1";
    var baseMinter = { inflation: "", annualProvisions: "" };
    exports.Minter = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inflation !== "") {
          writer.uint32(10).string(message.inflation);
        }
        if (message.annualProvisions !== "") {
          writer.uint32(18).string(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMinter);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.string();
              break;
            case 2:
              message.annualProvisions = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMinter);
        message.inflation = object.inflation !== void 0 && object.inflation !== null ? String(object.inflation) : "";
        message.annualProvisions = object.annualProvisions !== void 0 && object.annualProvisions !== null ? String(object.annualProvisions) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = message.inflation);
        message.annualProvisions !== void 0 && (obj.annualProvisions = message.annualProvisions);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMinter);
        message.inflation = (_a = object.inflation) !== null && _a !== void 0 ? _a : "";
        message.annualProvisions = (_b = object.annualProvisions) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseParams = {
      mintDenom: "",
      inflationRateChange: "",
      inflationMax: "",
      inflationMin: "",
      goalBonded: "",
      blocksPerYear: long_1.default.UZERO
    };
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mintDenom !== "") {
          writer.uint32(10).string(message.mintDenom);
        }
        if (message.inflationRateChange !== "") {
          writer.uint32(18).string(message.inflationRateChange);
        }
        if (message.inflationMax !== "") {
          writer.uint32(26).string(message.inflationMax);
        }
        if (message.inflationMin !== "") {
          writer.uint32(34).string(message.inflationMin);
        }
        if (message.goalBonded !== "") {
          writer.uint32(42).string(message.goalBonded);
        }
        if (!message.blocksPerYear.isZero()) {
          writer.uint32(48).uint64(message.blocksPerYear);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mintDenom = reader.string();
              break;
            case 2:
              message.inflationRateChange = reader.string();
              break;
            case 3:
              message.inflationMax = reader.string();
              break;
            case 4:
              message.inflationMin = reader.string();
              break;
            case 5:
              message.goalBonded = reader.string();
              break;
            case 6:
              message.blocksPerYear = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseParams);
        message.mintDenom = object.mintDenom !== void 0 && object.mintDenom !== null ? String(object.mintDenom) : "";
        message.inflationRateChange = object.inflationRateChange !== void 0 && object.inflationRateChange !== null ? String(object.inflationRateChange) : "";
        message.inflationMax = object.inflationMax !== void 0 && object.inflationMax !== null ? String(object.inflationMax) : "";
        message.inflationMin = object.inflationMin !== void 0 && object.inflationMin !== null ? String(object.inflationMin) : "";
        message.goalBonded = object.goalBonded !== void 0 && object.goalBonded !== null ? String(object.goalBonded) : "";
        message.blocksPerYear = object.blocksPerYear !== void 0 && object.blocksPerYear !== null ? long_1.default.fromString(object.blocksPerYear) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.mintDenom !== void 0 && (obj.mintDenom = message.mintDenom);
        message.inflationRateChange !== void 0 && (obj.inflationRateChange = message.inflationRateChange);
        message.inflationMax !== void 0 && (obj.inflationMax = message.inflationMax);
        message.inflationMin !== void 0 && (obj.inflationMin = message.inflationMin);
        message.goalBonded !== void 0 && (obj.goalBonded = message.goalBonded);
        message.blocksPerYear !== void 0 && (obj.blocksPerYear = (message.blocksPerYear || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseParams);
        message.mintDenom = (_a = object.mintDenom) !== null && _a !== void 0 ? _a : "";
        message.inflationRateChange = (_b = object.inflationRateChange) !== null && _b !== void 0 ? _b : "";
        message.inflationMax = (_c = object.inflationMax) !== null && _c !== void 0 ? _c : "";
        message.inflationMin = (_d = object.inflationMin) !== null && _d !== void 0 ? _d : "";
        message.goalBonded = (_e = object.goalBonded) !== null && _e !== void 0 ? _e : "";
        message.blocksPerYear = object.blocksPerYear !== void 0 && object.blocksPerYear !== null ? long_1.default.fromValue(object.blocksPerYear) : long_1.default.UZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js
var require_query9 = __commonJS({
  "node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryAnnualProvisionsResponse = exports.QueryAnnualProvisionsRequest = exports.QueryInflationResponse = exports.QueryInflationRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var mint_1 = require_mint();
    exports.protobufPackage = "cosmos.mint.v1beta1";
    var baseQueryParamsRequest = {};
    exports.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      }
    };
    var baseQueryParamsResponse = {};
    exports.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          mint_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = mint_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? mint_1.Params.fromJSON(object.params) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? mint_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? mint_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var baseQueryInflationRequest = {};
    exports.QueryInflationRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryInflationRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryInflationRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryInflationRequest);
        return message;
      }
    };
    var baseQueryInflationResponse = {};
    exports.QueryInflationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inflation.length !== 0) {
          writer.uint32(10).bytes(message.inflation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryInflationResponse);
        message.inflation = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryInflationResponse);
        message.inflation = object.inflation !== void 0 && object.inflation !== null ? bytesFromBase64(object.inflation) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = base64FromBytes(message.inflation !== void 0 ? message.inflation : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryInflationResponse);
        message.inflation = (_a = object.inflation) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var baseQueryAnnualProvisionsRequest = {};
    exports.QueryAnnualProvisionsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAnnualProvisionsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryAnnualProvisionsRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryAnnualProvisionsRequest);
        return message;
      }
    };
    var baseQueryAnnualProvisionsResponse = {};
    exports.QueryAnnualProvisionsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.annualProvisions.length !== 0) {
          writer.uint32(10).bytes(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAnnualProvisionsResponse);
        message.annualProvisions = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.annualProvisions = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryAnnualProvisionsResponse);
        message.annualProvisions = object.annualProvisions !== void 0 && object.annualProvisions !== null ? bytesFromBase64(object.annualProvisions) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.annualProvisions !== void 0 && (obj.annualProvisions = base64FromBytes(message.annualProvisions !== void 0 ? message.annualProvisions : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryAnnualProvisionsResponse);
        message.annualProvisions = (_a = object.annualProvisions) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Inflation = this.Inflation.bind(this);
        this.AnnualProvisions = this.AnnualProvisions.bind(this);
      }
      Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Inflation(request) {
        const data = exports.QueryInflationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", data);
        return promise.then((data2) => exports.QueryInflationResponse.decode(new minimal_1.default.Reader(data2)));
      }
      AnnualProvisions(request) {
        const data = exports.QueryAnnualProvisionsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", data);
        return promise.then((data2) => exports.QueryAnnualProvisionsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/queries/mint.js
var require_mint2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/mint.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupMintExtension = void 0;
    var utils_1 = require_build2();
    var query_1 = require_query9();
    var __1 = require_build12();
    var utils_2 = require_utils2();
    function setupMintExtension(base) {
      const rpc = (0, __1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        mint: {
          params: async () => {
            const { params } = await queryService.Params({});
            (0, utils_1.assert)(params);
            return {
              blocksPerYear: params.blocksPerYear,
              goalBonded: (0, utils_2.decodeCosmosSdkDecFromProto)(params.goalBonded),
              inflationMin: (0, utils_2.decodeCosmosSdkDecFromProto)(params.inflationMin),
              inflationMax: (0, utils_2.decodeCosmosSdkDecFromProto)(params.inflationMax),
              inflationRateChange: (0, utils_2.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
              mintDenom: params.mintDenom
            };
          },
          inflation: async () => {
            const { inflation } = await queryService.Inflation({});
            return (0, utils_2.decodeCosmosSdkDecFromProto)(inflation);
          },
          annualProvisions: async () => {
            const { annualProvisions } = await queryService.AnnualProvisions({});
            return (0, utils_2.decodeCosmosSdkDecFromProto)(annualProvisions);
          }
        }
      };
    }
    exports.setupMintExtension = setupMintExtension;
  }
});

// node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js
var require_staking = __commonJS({
  "node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Pool = exports.RedelegationResponse = exports.RedelegationEntryResponse = exports.DelegationResponse = exports.Params = exports.Redelegation = exports.RedelegationEntry = exports.UnbondingDelegationEntry = exports.UnbondingDelegation = exports.Delegation = exports.DVVTriplets = exports.DVVTriplet = exports.DVPairs = exports.DVPair = exports.ValAddresses = exports.Validator = exports.Description = exports.Commission = exports.CommissionRates = exports.HistoricalInfo = exports.bondStatusToJSON = exports.bondStatusFromJSON = exports.BondStatus = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var types_1 = require_types2();
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var duration_1 = require_duration();
    var coin_1 = require_coin();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    var BondStatus;
    (function(BondStatus2) {
      BondStatus2[BondStatus2["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
      BondStatus2[BondStatus2["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
      BondStatus2[BondStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BondStatus = exports.BondStatus || (exports.BondStatus = {}));
    function bondStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
          return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
          return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
          return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
          return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BondStatus.UNRECOGNIZED;
      }
    }
    exports.bondStatusFromJSON = bondStatusFromJSON;
    function bondStatusToJSON(object) {
      switch (object) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
          return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
          return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
          return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
          return "BOND_STATUS_BONDED";
        default:
          return "UNKNOWN";
      }
    }
    exports.bondStatusToJSON = bondStatusToJSON;
    var baseHistoricalInfo = {};
    exports.HistoricalInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.valset) {
          exports.Validator.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHistoricalInfo);
        message.valset = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.valset.push(exports.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseHistoricalInfo);
        message.header = object.header !== void 0 && object.header !== null ? types_1.Header.fromJSON(object.header) : void 0;
        message.valset = ((_a = object.valset) !== null && _a !== void 0 ? _a : []).map((e) => exports.Validator.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        if (message.valset) {
          obj.valset = message.valset.map((e) => e ? exports.Validator.toJSON(e) : void 0);
        } else {
          obj.valset = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseHistoricalInfo);
        message.header = object.header !== void 0 && object.header !== null ? types_1.Header.fromPartial(object.header) : void 0;
        message.valset = ((_a = object.valset) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Validator.fromPartial(e))) || [];
        return message;
      }
    };
    var baseCommissionRates = { rate: "", maxRate: "", maxChangeRate: "" };
    exports.CommissionRates = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.rate !== "") {
          writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
          writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
          writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCommissionRates);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rate = reader.string();
              break;
            case 2:
              message.maxRate = reader.string();
              break;
            case 3:
              message.maxChangeRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCommissionRates);
        message.rate = object.rate !== void 0 && object.rate !== null ? String(object.rate) : "";
        message.maxRate = object.maxRate !== void 0 && object.maxRate !== null ? String(object.maxRate) : "";
        message.maxChangeRate = object.maxChangeRate !== void 0 && object.maxChangeRate !== null ? String(object.maxChangeRate) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.rate !== void 0 && (obj.rate = message.rate);
        message.maxRate !== void 0 && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== void 0 && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseCommissionRates);
        message.rate = (_a = object.rate) !== null && _a !== void 0 ? _a : "";
        message.maxRate = (_b = object.maxRate) !== null && _b !== void 0 ? _b : "";
        message.maxChangeRate = (_c = object.maxChangeRate) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseCommission = {};
    exports.Commission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.commissionRates !== void 0) {
          exports.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== void 0) {
          timestamp_1.Timestamp.encode(message.updateTime, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCommission);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commissionRates = exports.CommissionRates.decode(reader, reader.uint32());
              break;
            case 2:
              message.updateTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseCommission);
        message.commissionRates = object.commissionRates !== void 0 && object.commissionRates !== null ? exports.CommissionRates.fromJSON(object.commissionRates) : void 0;
        message.updateTime = object.updateTime !== void 0 && object.updateTime !== null ? fromJsonTimestamp(object.updateTime) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.commissionRates !== void 0 && (obj.commissionRates = message.commissionRates ? exports.CommissionRates.toJSON(message.commissionRates) : void 0);
        message.updateTime !== void 0 && (obj.updateTime = fromTimestamp(message.updateTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseCommission);
        message.commissionRates = object.commissionRates !== void 0 && object.commissionRates !== null ? exports.CommissionRates.fromPartial(object.commissionRates) : void 0;
        message.updateTime = object.updateTime !== void 0 && object.updateTime !== null ? timestamp_1.Timestamp.fromPartial(object.updateTime) : void 0;
        return message;
      }
    };
    var baseDescription = { moniker: "", identity: "", website: "", securityContact: "", details: "" };
    exports.Description = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.moniker !== "") {
          writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
          writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
          writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
          writer.uint32(42).string(message.details);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDescription);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moniker = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.website = reader.string();
              break;
            case 4:
              message.securityContact = reader.string();
              break;
            case 5:
              message.details = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDescription);
        message.moniker = object.moniker !== void 0 && object.moniker !== null ? String(object.moniker) : "";
        message.identity = object.identity !== void 0 && object.identity !== null ? String(object.identity) : "";
        message.website = object.website !== void 0 && object.website !== null ? String(object.website) : "";
        message.securityContact = object.securityContact !== void 0 && object.securityContact !== null ? String(object.securityContact) : "";
        message.details = object.details !== void 0 && object.details !== null ? String(object.details) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.moniker !== void 0 && (obj.moniker = message.moniker);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.website !== void 0 && (obj.website = message.website);
        message.securityContact !== void 0 && (obj.securityContact = message.securityContact);
        message.details !== void 0 && (obj.details = message.details);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseDescription);
        message.moniker = (_a = object.moniker) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.website = (_c = object.website) !== null && _c !== void 0 ? _c : "";
        message.securityContact = (_d = object.securityContact) !== null && _d !== void 0 ? _d : "";
        message.details = (_e = object.details) !== null && _e !== void 0 ? _e : "";
        return message;
      }
    };
    var baseValidator = {
      operatorAddress: "",
      jailed: false,
      status: 0,
      tokens: "",
      delegatorShares: "",
      unbondingHeight: long_1.default.ZERO,
      minSelfDelegation: ""
    };
    exports.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== void 0) {
          any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
          writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
          writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
          writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
          writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== void 0) {
          exports.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (!message.unbondingHeight.isZero()) {
          writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== void 0) {
          timestamp_1.Timestamp.encode(message.unbondingTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          exports.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(90).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidator);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.jailed = reader.bool();
              break;
            case 4:
              message.status = reader.int32();
              break;
            case 5:
              message.tokens = reader.string();
              break;
            case 6:
              message.delegatorShares = reader.string();
              break;
            case 7:
              message.description = exports.Description.decode(reader, reader.uint32());
              break;
            case 8:
              message.unbondingHeight = reader.int64();
              break;
            case 9:
              message.unbondingTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.commission = exports.Commission.decode(reader, reader.uint32());
              break;
            case 11:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseValidator);
        message.operatorAddress = object.operatorAddress !== void 0 && object.operatorAddress !== null ? String(object.operatorAddress) : "";
        message.consensusPubkey = object.consensusPubkey !== void 0 && object.consensusPubkey !== null ? any_1.Any.fromJSON(object.consensusPubkey) : void 0;
        message.jailed = object.jailed !== void 0 && object.jailed !== null ? Boolean(object.jailed) : false;
        message.status = object.status !== void 0 && object.status !== null ? bondStatusFromJSON(object.status) : 0;
        message.tokens = object.tokens !== void 0 && object.tokens !== null ? String(object.tokens) : "";
        message.delegatorShares = object.delegatorShares !== void 0 && object.delegatorShares !== null ? String(object.delegatorShares) : "";
        message.description = object.description !== void 0 && object.description !== null ? exports.Description.fromJSON(object.description) : void 0;
        message.unbondingHeight = object.unbondingHeight !== void 0 && object.unbondingHeight !== null ? long_1.default.fromString(object.unbondingHeight) : long_1.default.ZERO;
        message.unbondingTime = object.unbondingTime !== void 0 && object.unbondingTime !== null ? fromJsonTimestamp(object.unbondingTime) : void 0;
        message.commission = object.commission !== void 0 && object.commission !== null ? exports.Commission.fromJSON(object.commission) : void 0;
        message.minSelfDelegation = object.minSelfDelegation !== void 0 && object.minSelfDelegation !== null ? String(object.minSelfDelegation) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== void 0 && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : void 0);
        message.jailed !== void 0 && (obj.jailed = message.jailed);
        message.status !== void 0 && (obj.status = bondStatusToJSON(message.status));
        message.tokens !== void 0 && (obj.tokens = message.tokens);
        message.delegatorShares !== void 0 && (obj.delegatorShares = message.delegatorShares);
        message.description !== void 0 && (obj.description = message.description ? exports.Description.toJSON(message.description) : void 0);
        message.unbondingHeight !== void 0 && (obj.unbondingHeight = (message.unbondingHeight || long_1.default.ZERO).toString());
        message.unbondingTime !== void 0 && (obj.unbondingTime = fromTimestamp(message.unbondingTime).toISOString());
        message.commission !== void 0 && (obj.commission = message.commission ? exports.Commission.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = Object.assign({}, baseValidator);
        message.operatorAddress = (_a = object.operatorAddress) !== null && _a !== void 0 ? _a : "";
        message.consensusPubkey = object.consensusPubkey !== void 0 && object.consensusPubkey !== null ? any_1.Any.fromPartial(object.consensusPubkey) : void 0;
        message.jailed = (_b = object.jailed) !== null && _b !== void 0 ? _b : false;
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : 0;
        message.tokens = (_d = object.tokens) !== null && _d !== void 0 ? _d : "";
        message.delegatorShares = (_e = object.delegatorShares) !== null && _e !== void 0 ? _e : "";
        message.description = object.description !== void 0 && object.description !== null ? exports.Description.fromPartial(object.description) : void 0;
        message.unbondingHeight = object.unbondingHeight !== void 0 && object.unbondingHeight !== null ? long_1.default.fromValue(object.unbondingHeight) : long_1.default.ZERO;
        message.unbondingTime = object.unbondingTime !== void 0 && object.unbondingTime !== null ? timestamp_1.Timestamp.fromPartial(object.unbondingTime) : void 0;
        message.commission = object.commission !== void 0 && object.commission !== null ? exports.Commission.fromPartial(object.commission) : void 0;
        message.minSelfDelegation = (_f = object.minSelfDelegation) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    var baseValAddresses = { addresses: "" };
    exports.ValAddresses = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.addresses) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValAddresses);
        message.addresses = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseValAddresses);
        message.addresses = ((_a = object.addresses) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValAddresses);
        message.addresses = ((_a = object.addresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    var baseDVPair = { delegatorAddress: "", validatorAddress: "" };
    exports.DVPair = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDVPair);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDVPair);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseDVPair);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseDVPairs = {};
    exports.DVPairs = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.pairs) {
          exports.DVPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDVPairs);
        message.pairs = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pairs.push(exports.DVPair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseDVPairs);
        message.pairs = ((_a = object.pairs) !== null && _a !== void 0 ? _a : []).map((e) => exports.DVPair.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.pairs) {
          obj.pairs = message.pairs.map((e) => e ? exports.DVPair.toJSON(e) : void 0);
        } else {
          obj.pairs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseDVPairs);
        message.pairs = ((_a = object.pairs) === null || _a === void 0 ? void 0 : _a.map((e) => exports.DVPair.fromPartial(e))) || [];
        return message;
      }
    };
    var baseDVVTriplet = { delegatorAddress: "", validatorSrcAddress: "", validatorDstAddress: "" };
    exports.DVVTriplet = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDVVTriplet);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDVVTriplet);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorSrcAddress = object.validatorSrcAddress !== void 0 && object.validatorSrcAddress !== null ? String(object.validatorSrcAddress) : "";
        message.validatorDstAddress = object.validatorDstAddress !== void 0 && object.validatorDstAddress !== null ? String(object.validatorDstAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseDVVTriplet);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseDVVTriplets = {};
    exports.DVVTriplets = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.triplets) {
          exports.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDVVTriplets);
        message.triplets = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.triplets.push(exports.DVVTriplet.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseDVVTriplets);
        message.triplets = ((_a = object.triplets) !== null && _a !== void 0 ? _a : []).map((e) => exports.DVVTriplet.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.triplets) {
          obj.triplets = message.triplets.map((e) => e ? exports.DVVTriplet.toJSON(e) : void 0);
        } else {
          obj.triplets = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseDVVTriplets);
        message.triplets = ((_a = object.triplets) === null || _a === void 0 ? void 0 : _a.map((e) => exports.DVVTriplet.fromPartial(e))) || [];
        return message;
      }
    };
    var baseDelegation = { delegatorAddress: "", validatorAddress: "", shares: "" };
    exports.Delegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
          writer.uint32(26).string(message.shares);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDelegation);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.shares = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDelegation);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        message.shares = object.shares !== void 0 && object.shares !== null ? String(object.shares) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.shares !== void 0 && (obj.shares = message.shares);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseDelegation);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.shares = (_c = object.shares) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseUnbondingDelegation = { delegatorAddress: "", validatorAddress: "" };
    exports.UnbondingDelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.entries) {
          exports.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUnbondingDelegation);
        message.entries = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.entries.push(exports.UnbondingDelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseUnbondingDelegation);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        message.entries = ((_a = object.entries) !== null && _a !== void 0 ? _a : []).map((e) => exports.UnbondingDelegationEntry.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.UnbondingDelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseUnbondingDelegation);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.entries = ((_c = object.entries) === null || _c === void 0 ? void 0 : _c.map((e) => exports.UnbondingDelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    var baseUnbondingDelegationEntry = { creationHeight: long_1.default.ZERO, initialBalance: "", balance: "" };
    exports.UnbondingDelegationEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.creationHeight.isZero()) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUnbondingDelegationEntry);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseUnbondingDelegationEntry);
        message.creationHeight = object.creationHeight !== void 0 && object.creationHeight !== null ? long_1.default.fromString(object.creationHeight) : long_1.default.ZERO;
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? fromJsonTimestamp(object.completionTime) : void 0;
        message.initialBalance = object.initialBalance !== void 0 && object.initialBalance !== null ? String(object.initialBalance) : "";
        message.balance = object.balance !== void 0 && object.balance !== null ? String(object.balance) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || long_1.default.ZERO).toString());
        message.completionTime !== void 0 && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseUnbondingDelegationEntry);
        message.creationHeight = object.creationHeight !== void 0 && object.creationHeight !== null ? long_1.default.fromValue(object.creationHeight) : long_1.default.ZERO;
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : void 0;
        message.initialBalance = (_a = object.initialBalance) !== null && _a !== void 0 ? _a : "";
        message.balance = (_b = object.balance) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseRedelegationEntry = { creationHeight: long_1.default.ZERO, initialBalance: "", sharesDst: "" };
    exports.RedelegationEntry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.creationHeight.isZero()) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
          writer.uint32(34).string(message.sharesDst);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRedelegationEntry);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.sharesDst = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRedelegationEntry);
        message.creationHeight = object.creationHeight !== void 0 && object.creationHeight !== null ? long_1.default.fromString(object.creationHeight) : long_1.default.ZERO;
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? fromJsonTimestamp(object.completionTime) : void 0;
        message.initialBalance = object.initialBalance !== void 0 && object.initialBalance !== null ? String(object.initialBalance) : "";
        message.sharesDst = object.sharesDst !== void 0 && object.sharesDst !== null ? String(object.sharesDst) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || long_1.default.ZERO).toString());
        message.completionTime !== void 0 && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== void 0 && (obj.sharesDst = message.sharesDst);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseRedelegationEntry);
        message.creationHeight = object.creationHeight !== void 0 && object.creationHeight !== null ? long_1.default.fromValue(object.creationHeight) : long_1.default.ZERO;
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : void 0;
        message.initialBalance = (_a = object.initialBalance) !== null && _a !== void 0 ? _a : "";
        message.sharesDst = (_b = object.sharesDst) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseRedelegation = { delegatorAddress: "", validatorSrcAddress: "", validatorDstAddress: "" };
    exports.Redelegation = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v of message.entries) {
          exports.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRedelegation);
        message.entries = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.entries.push(exports.RedelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseRedelegation);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorSrcAddress = object.validatorSrcAddress !== void 0 && object.validatorSrcAddress !== null ? String(object.validatorSrcAddress) : "";
        message.validatorDstAddress = object.validatorDstAddress !== void 0 && object.validatorDstAddress !== null ? String(object.validatorDstAddress) : "";
        message.entries = ((_a = object.entries) !== null && _a !== void 0 ? _a : []).map((e) => exports.RedelegationEntry.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.RedelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseRedelegation);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        message.entries = ((_d = object.entries) === null || _d === void 0 ? void 0 : _d.map((e) => exports.RedelegationEntry.fromPartial(e))) || [];
        return message;
      }
    };
    var baseParams = { maxValidators: 0, maxEntries: 0, historicalEntries: 0, bondDenom: "" };
    exports.Params = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbondingTime !== void 0) {
          duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
          writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
          writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
          writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
          writer.uint32(42).string(message.bondDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.maxValidators = reader.uint32();
              break;
            case 3:
              message.maxEntries = reader.uint32();
              break;
            case 4:
              message.historicalEntries = reader.uint32();
              break;
            case 5:
              message.bondDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseParams);
        message.unbondingTime = object.unbondingTime !== void 0 && object.unbondingTime !== null ? duration_1.Duration.fromJSON(object.unbondingTime) : void 0;
        message.maxValidators = object.maxValidators !== void 0 && object.maxValidators !== null ? Number(object.maxValidators) : 0;
        message.maxEntries = object.maxEntries !== void 0 && object.maxEntries !== null ? Number(object.maxEntries) : 0;
        message.historicalEntries = object.historicalEntries !== void 0 && object.historicalEntries !== null ? Number(object.historicalEntries) : 0;
        message.bondDenom = object.bondDenom !== void 0 && object.bondDenom !== null ? String(object.bondDenom) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : void 0);
        message.maxValidators !== void 0 && (obj.maxValidators = message.maxValidators);
        message.maxEntries !== void 0 && (obj.maxEntries = message.maxEntries);
        message.historicalEntries !== void 0 && (obj.historicalEntries = message.historicalEntries);
        message.bondDenom !== void 0 && (obj.bondDenom = message.bondDenom);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseParams);
        message.unbondingTime = object.unbondingTime !== void 0 && object.unbondingTime !== null ? duration_1.Duration.fromPartial(object.unbondingTime) : void 0;
        message.maxValidators = (_a = object.maxValidators) !== null && _a !== void 0 ? _a : 0;
        message.maxEntries = (_b = object.maxEntries) !== null && _b !== void 0 ? _b : 0;
        message.historicalEntries = (_c = object.historicalEntries) !== null && _c !== void 0 ? _c : 0;
        message.bondDenom = (_d = object.bondDenom) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    var baseDelegationResponse = {};
    exports.DelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegation !== void 0) {
          exports.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDelegationResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegation = exports.Delegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseDelegationResponse);
        message.delegation = object.delegation !== void 0 && object.delegation !== null ? exports.Delegation.fromJSON(object.delegation) : void 0;
        message.balance = object.balance !== void 0 && object.balance !== null ? coin_1.Coin.fromJSON(object.balance) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegation !== void 0 && (obj.delegation = message.delegation ? exports.Delegation.toJSON(message.delegation) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseDelegationResponse);
        message.delegation = object.delegation !== void 0 && object.delegation !== null ? exports.Delegation.fromPartial(object.delegation) : void 0;
        message.balance = object.balance !== void 0 && object.balance !== null ? coin_1.Coin.fromPartial(object.balance) : void 0;
        return message;
      }
    };
    var baseRedelegationEntryResponse = { balance: "" };
    exports.RedelegationEntryResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redelegationEntry !== void 0) {
          exports.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRedelegationEntryResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationEntry = exports.RedelegationEntry.decode(reader, reader.uint32());
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRedelegationEntryResponse);
        message.redelegationEntry = object.redelegationEntry !== void 0 && object.redelegationEntry !== null ? exports.RedelegationEntry.fromJSON(object.redelegationEntry) : void 0;
        message.balance = object.balance !== void 0 && object.balance !== null ? String(object.balance) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.redelegationEntry !== void 0 && (obj.redelegationEntry = message.redelegationEntry ? exports.RedelegationEntry.toJSON(message.redelegationEntry) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseRedelegationEntryResponse);
        message.redelegationEntry = object.redelegationEntry !== void 0 && object.redelegationEntry !== null ? exports.RedelegationEntry.fromPartial(object.redelegationEntry) : void 0;
        message.balance = (_a = object.balance) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseRedelegationResponse = {};
    exports.RedelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redelegation !== void 0) {
          exports.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.entries) {
          exports.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRedelegationResponse);
        message.entries = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegation = exports.Redelegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.entries.push(exports.RedelegationEntryResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseRedelegationResponse);
        message.redelegation = object.redelegation !== void 0 && object.redelegation !== null ? exports.Redelegation.fromJSON(object.redelegation) : void 0;
        message.entries = ((_a = object.entries) !== null && _a !== void 0 ? _a : []).map((e) => exports.RedelegationEntryResponse.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.redelegation !== void 0 && (obj.redelegation = message.redelegation ? exports.Redelegation.toJSON(message.redelegation) : void 0);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.RedelegationEntryResponse.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseRedelegationResponse);
        message.redelegation = object.redelegation !== void 0 && object.redelegation !== null ? exports.Redelegation.fromPartial(object.redelegation) : void 0;
        message.entries = ((_a = object.entries) === null || _a === void 0 ? void 0 : _a.map((e) => exports.RedelegationEntryResponse.fromPartial(e))) || [];
        return message;
      }
    };
    var basePool = { notBondedTokens: "", bondedTokens: "" };
    exports.Pool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.notBondedTokens !== "") {
          writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
          writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePool);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.notBondedTokens = reader.string();
              break;
            case 2:
              message.bondedTokens = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, basePool);
        message.notBondedTokens = object.notBondedTokens !== void 0 && object.notBondedTokens !== null ? String(object.notBondedTokens) : "";
        message.bondedTokens = object.bondedTokens !== void 0 && object.bondedTokens !== null ? String(object.bondedTokens) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.notBondedTokens !== void 0 && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== void 0 && (obj.bondedTokens = message.bondedTokens);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, basePool);
        message.notBondedTokens = (_a = object.notBondedTokens) !== null && _a !== void 0 ? _a : "";
        message.bondedTokens = (_b = object.bondedTokens) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js
var require_query10 = __commonJS({
  "node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryPoolResponse = exports.QueryPoolRequest = exports.QueryHistoricalInfoResponse = exports.QueryHistoricalInfoRequest = exports.QueryDelegatorValidatorResponse = exports.QueryDelegatorValidatorRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryRedelegationsResponse = exports.QueryRedelegationsRequest = exports.QueryDelegatorUnbondingDelegationsResponse = exports.QueryDelegatorUnbondingDelegationsRequest = exports.QueryDelegatorDelegationsResponse = exports.QueryDelegatorDelegationsRequest = exports.QueryUnbondingDelegationResponse = exports.QueryUnbondingDelegationRequest = exports.QueryDelegationResponse = exports.QueryDelegationRequest = exports.QueryValidatorUnbondingDelegationsResponse = exports.QueryValidatorUnbondingDelegationsRequest = exports.QueryValidatorDelegationsResponse = exports.QueryValidatorDelegationsRequest = exports.QueryValidatorResponse = exports.QueryValidatorRequest = exports.QueryValidatorsResponse = exports.QueryValidatorsRequest = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var pagination_1 = require_pagination();
    var staking_1 = require_staking();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    var baseQueryValidatorsRequest = { status: "" };
    exports.QueryValidatorsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorsRequest);
        message.status = object.status !== void 0 && object.status !== null ? String(object.status) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorsRequest);
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryValidatorsResponse = {};
    exports.QueryValidatorsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorsResponse);
        message.validators = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorsResponse);
        message.validators = ((_a = object.validators) !== null && _a !== void 0 ? _a : []).map((e) => staking_1.Validator.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorsResponse);
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.Validator.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryValidatorRequest = { validatorAddr: "" };
    exports.QueryValidatorRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorRequest);
        message.validatorAddr = object.validatorAddr !== void 0 && object.validatorAddr !== null ? String(object.validatorAddr) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorRequest);
        message.validatorAddr = (_a = object.validatorAddr) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseQueryValidatorResponse = {};
    exports.QueryValidatorResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorResponse);
        message.validator = object.validator !== void 0 && object.validator !== null ? staking_1.Validator.fromJSON(object.validator) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryValidatorResponse);
        message.validator = object.validator !== void 0 && object.validator !== null ? staking_1.Validator.fromPartial(object.validator) : void 0;
        return message;
      }
    };
    var baseQueryValidatorDelegationsRequest = { validatorAddr: "" };
    exports.QueryValidatorDelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorDelegationsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorDelegationsRequest);
        message.validatorAddr = object.validatorAddr !== void 0 && object.validatorAddr !== null ? String(object.validatorAddr) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorDelegationsRequest);
        message.validatorAddr = (_a = object.validatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryValidatorDelegationsResponse = {};
    exports.QueryValidatorDelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorDelegationsResponse);
        message.delegationResponses = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorDelegationsResponse);
        message.delegationResponses = ((_a = object.delegationResponses) !== null && _a !== void 0 ? _a : []).map((e) => staking_1.DelegationResponse.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorDelegationsResponse);
        message.delegationResponses = ((_a = object.delegationResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.DelegationResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryValidatorUnbondingDelegationsRequest = { validatorAddr: "" };
    exports.QueryValidatorUnbondingDelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorUnbondingDelegationsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryValidatorUnbondingDelegationsRequest);
        message.validatorAddr = object.validatorAddr !== void 0 && object.validatorAddr !== null ? String(object.validatorAddr) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorUnbondingDelegationsRequest);
        message.validatorAddr = (_a = object.validatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryValidatorUnbondingDelegationsResponse = {};
    exports.QueryValidatorUnbondingDelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryValidatorUnbondingDelegationsResponse);
        message.unbondingResponses = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorUnbondingDelegationsResponse);
        message.unbondingResponses = ((_a = object.unbondingResponses) !== null && _a !== void 0 ? _a : []).map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryValidatorUnbondingDelegationsResponse);
        message.unbondingResponses = ((_a = object.unbondingResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.UnbondingDelegation.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDelegationRequest = { delegatorAddr: "", validatorAddr: "" };
    exports.QueryDelegationRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegationRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegationRequest);
        message.delegatorAddr = object.delegatorAddr !== void 0 && object.delegatorAddr !== null ? String(object.delegatorAddr) : "";
        message.validatorAddr = object.validatorAddr !== void 0 && object.validatorAddr !== null ? String(object.validatorAddr) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryDelegationRequest);
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.validatorAddr = (_b = object.validatorAddr) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseQueryDelegationResponse = {};
    exports.QueryDelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegationResponse !== void 0) {
          staking_1.DelegationResponse.encode(message.delegationResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegationResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponse = staking_1.DelegationResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegationResponse);
        message.delegationResponse = object.delegationResponse !== void 0 && object.delegationResponse !== null ? staking_1.DelegationResponse.fromJSON(object.delegationResponse) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegationResponse !== void 0 && (obj.delegationResponse = message.delegationResponse ? staking_1.DelegationResponse.toJSON(message.delegationResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryDelegationResponse);
        message.delegationResponse = object.delegationResponse !== void 0 && object.delegationResponse !== null ? staking_1.DelegationResponse.fromPartial(object.delegationResponse) : void 0;
        return message;
      }
    };
    var baseQueryUnbondingDelegationRequest = { delegatorAddr: "", validatorAddr: "" };
    exports.QueryUnbondingDelegationRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryUnbondingDelegationRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryUnbondingDelegationRequest);
        message.delegatorAddr = object.delegatorAddr !== void 0 && object.delegatorAddr !== null ? String(object.delegatorAddr) : "";
        message.validatorAddr = object.validatorAddr !== void 0 && object.validatorAddr !== null ? String(object.validatorAddr) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryUnbondingDelegationRequest);
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.validatorAddr = (_b = object.validatorAddr) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseQueryUnbondingDelegationResponse = {};
    exports.QueryUnbondingDelegationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.unbond !== void 0) {
          staking_1.UnbondingDelegation.encode(message.unbond, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryUnbondingDelegationResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbond = staking_1.UnbondingDelegation.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryUnbondingDelegationResponse);
        message.unbond = object.unbond !== void 0 && object.unbond !== null ? staking_1.UnbondingDelegation.fromJSON(object.unbond) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.unbond !== void 0 && (obj.unbond = message.unbond ? staking_1.UnbondingDelegation.toJSON(message.unbond) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryUnbondingDelegationResponse);
        message.unbond = object.unbond !== void 0 && object.unbond !== null ? staking_1.UnbondingDelegation.fromPartial(object.unbond) : void 0;
        return message;
      }
    };
    var baseQueryDelegatorDelegationsRequest = { delegatorAddr: "" };
    exports.QueryDelegatorDelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorDelegationsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegatorDelegationsRequest);
        message.delegatorAddr = object.delegatorAddr !== void 0 && object.delegatorAddr !== null ? String(object.delegatorAddr) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorDelegationsRequest);
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDelegatorDelegationsResponse = {};
    exports.QueryDelegatorDelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorDelegationsResponse);
        message.delegationResponses = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorDelegationsResponse);
        message.delegationResponses = ((_a = object.delegationResponses) !== null && _a !== void 0 ? _a : []).map((e) => staking_1.DelegationResponse.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorDelegationsResponse);
        message.delegationResponses = ((_a = object.delegationResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.DelegationResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDelegatorUnbondingDelegationsRequest = { delegatorAddr: "" };
    exports.QueryDelegatorUnbondingDelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorUnbondingDelegationsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegatorUnbondingDelegationsRequest);
        message.delegatorAddr = object.delegatorAddr !== void 0 && object.delegatorAddr !== null ? String(object.delegatorAddr) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorUnbondingDelegationsRequest);
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDelegatorUnbondingDelegationsResponse = {};
    exports.QueryDelegatorUnbondingDelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorUnbondingDelegationsResponse);
        message.unbondingResponses = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorUnbondingDelegationsResponse);
        message.unbondingResponses = ((_a = object.unbondingResponses) !== null && _a !== void 0 ? _a : []).map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorUnbondingDelegationsResponse);
        message.unbondingResponses = ((_a = object.unbondingResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.UnbondingDelegation.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryRedelegationsRequest = {
      delegatorAddr: "",
      srcValidatorAddr: "",
      dstValidatorAddr: ""
    };
    exports.QueryRedelegationsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.srcValidatorAddr !== "") {
          writer.uint32(18).string(message.srcValidatorAddr);
        }
        if (message.dstValidatorAddr !== "") {
          writer.uint32(26).string(message.dstValidatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryRedelegationsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.srcValidatorAddr = reader.string();
              break;
            case 3:
              message.dstValidatorAddr = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryRedelegationsRequest);
        message.delegatorAddr = object.delegatorAddr !== void 0 && object.delegatorAddr !== null ? String(object.delegatorAddr) : "";
        message.srcValidatorAddr = object.srcValidatorAddr !== void 0 && object.srcValidatorAddr !== null ? String(object.srcValidatorAddr) : "";
        message.dstValidatorAddr = object.dstValidatorAddr !== void 0 && object.dstValidatorAddr !== null ? String(object.dstValidatorAddr) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.srcValidatorAddr !== void 0 && (obj.srcValidatorAddr = message.srcValidatorAddr);
        message.dstValidatorAddr !== void 0 && (obj.dstValidatorAddr = message.dstValidatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseQueryRedelegationsRequest);
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.srcValidatorAddr = (_b = object.srcValidatorAddr) !== null && _b !== void 0 ? _b : "";
        message.dstValidatorAddr = (_c = object.dstValidatorAddr) !== null && _c !== void 0 ? _c : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryRedelegationsResponse = {};
    exports.QueryRedelegationsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.redelegationResponses) {
          staking_1.RedelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryRedelegationsResponse);
        message.redelegationResponses = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationResponses.push(staking_1.RedelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryRedelegationsResponse);
        message.redelegationResponses = ((_a = object.redelegationResponses) !== null && _a !== void 0 ? _a : []).map((e) => staking_1.RedelegationResponse.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.redelegationResponses) {
          obj.redelegationResponses = message.redelegationResponses.map((e) => e ? staking_1.RedelegationResponse.toJSON(e) : void 0);
        } else {
          obj.redelegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryRedelegationsResponse);
        message.redelegationResponses = ((_a = object.redelegationResponses) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.RedelegationResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDelegatorValidatorsRequest = { delegatorAddr: "" };
    exports.QueryDelegatorValidatorsRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorValidatorsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegatorValidatorsRequest);
        message.delegatorAddr = object.delegatorAddr !== void 0 && object.delegatorAddr !== null ? String(object.delegatorAddr) : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorValidatorsRequest);
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDelegatorValidatorsResponse = {};
    exports.QueryDelegatorValidatorsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validators) {
          staking_1.Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorValidatorsResponse);
        message.validators = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorValidatorsResponse);
        message.validators = ((_a = object.validators) !== null && _a !== void 0 ? _a : []).map((e) => staking_1.Validator.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseQueryDelegatorValidatorsResponse);
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => staking_1.Validator.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseQueryDelegatorValidatorRequest = { delegatorAddr: "", validatorAddr: "" };
    exports.QueryDelegatorValidatorRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorValidatorRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegatorValidatorRequest);
        message.delegatorAddr = object.delegatorAddr !== void 0 && object.delegatorAddr !== null ? String(object.delegatorAddr) : "";
        message.validatorAddr = object.validatorAddr !== void 0 && object.validatorAddr !== null ? String(object.validatorAddr) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseQueryDelegatorValidatorRequest);
        message.delegatorAddr = (_a = object.delegatorAddr) !== null && _a !== void 0 ? _a : "";
        message.validatorAddr = (_b = object.validatorAddr) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseQueryDelegatorValidatorResponse = {};
    exports.QueryDelegatorValidatorResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryDelegatorValidatorResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryDelegatorValidatorResponse);
        message.validator = object.validator !== void 0 && object.validator !== null ? staking_1.Validator.fromJSON(object.validator) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryDelegatorValidatorResponse);
        message.validator = object.validator !== void 0 && object.validator !== null ? staking_1.Validator.fromPartial(object.validator) : void 0;
        return message;
      }
    };
    var baseQueryHistoricalInfoRequest = { height: long_1.default.ZERO };
    exports.QueryHistoricalInfoRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryHistoricalInfoRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryHistoricalInfoRequest);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryHistoricalInfoRequest);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        return message;
      }
    };
    var baseQueryHistoricalInfoResponse = {};
    exports.QueryHistoricalInfoResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hist !== void 0) {
          staking_1.HistoricalInfo.encode(message.hist, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryHistoricalInfoResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hist = staking_1.HistoricalInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryHistoricalInfoResponse);
        message.hist = object.hist !== void 0 && object.hist !== null ? staking_1.HistoricalInfo.fromJSON(object.hist) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.hist !== void 0 && (obj.hist = message.hist ? staking_1.HistoricalInfo.toJSON(message.hist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryHistoricalInfoResponse);
        message.hist = object.hist !== void 0 && object.hist !== null ? staking_1.HistoricalInfo.fromPartial(object.hist) : void 0;
        return message;
      }
    };
    var baseQueryPoolRequest = {};
    exports.QueryPoolRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPoolRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryPoolRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryPoolRequest);
        return message;
      }
    };
    var baseQueryPoolResponse = {};
    exports.QueryPoolResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pool !== void 0) {
          staking_1.Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryPoolResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool = staking_1.Pool.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryPoolResponse);
        message.pool = object.pool !== void 0 && object.pool !== null ? staking_1.Pool.fromJSON(object.pool) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pool !== void 0 && (obj.pool = message.pool ? staking_1.Pool.toJSON(message.pool) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryPoolResponse);
        message.pool = object.pool !== void 0 && object.pool !== null ? staking_1.Pool.fromPartial(object.pool) : void 0;
        return message;
      }
    };
    var baseQueryParamsRequest = {};
    exports.QueryParamsRequest = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
      }
    };
    var baseQueryParamsResponse = {};
    exports.QueryParamsResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? staking_1.Params.fromJSON(object.params) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        message.params = object.params !== void 0 && object.params !== null ? staking_1.Params.fromPartial(object.params) : void 0;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Validators = this.Validators.bind(this);
        this.Validator = this.Validator.bind(this);
        this.ValidatorDelegations = this.ValidatorDelegations.bind(this);
        this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this);
        this.Delegation = this.Delegation.bind(this);
        this.UnbondingDelegation = this.UnbondingDelegation.bind(this);
        this.DelegatorDelegations = this.DelegatorDelegations.bind(this);
        this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this);
        this.Redelegations = this.Redelegations.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorValidator = this.DelegatorValidator.bind(this);
        this.HistoricalInfo = this.HistoricalInfo.bind(this);
        this.Pool = this.Pool.bind(this);
        this.Params = this.Params.bind(this);
      }
      Validators(request) {
        const data = exports.QueryValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", data);
        return promise.then((data2) => exports.QueryValidatorsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Validator(request) {
        const data = exports.QueryValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", data);
        return promise.then((data2) => exports.QueryValidatorResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorDelegations(request) {
        const data = exports.QueryValidatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", data);
        return promise.then((data2) => exports.QueryValidatorDelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ValidatorUnbondingDelegations(request) {
        const data = exports.QueryValidatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", data);
        return promise.then((data2) => exports.QueryValidatorUnbondingDelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Delegation(request) {
        const data = exports.QueryDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", data);
        return promise.then((data2) => exports.QueryDelegationResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UnbondingDelegation(request) {
        const data = exports.QueryUnbondingDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", data);
        return promise.then((data2) => exports.QueryUnbondingDelegationResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorDelegations(request) {
        const data = exports.QueryDelegatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", data);
        return promise.then((data2) => exports.QueryDelegatorDelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorUnbondingDelegations(request) {
        const data = exports.QueryDelegatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", data);
        return promise.then((data2) => exports.QueryDelegatorUnbondingDelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Redelegations(request) {
        const data = exports.QueryRedelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", data);
        return promise.then((data2) => exports.QueryRedelegationsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorValidators(request) {
        const data = exports.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", data);
        return promise.then((data2) => exports.QueryDelegatorValidatorsResponse.decode(new minimal_1.default.Reader(data2)));
      }
      DelegatorValidator(request) {
        const data = exports.QueryDelegatorValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", data);
        return promise.then((data2) => exports.QueryDelegatorValidatorResponse.decode(new minimal_1.default.Reader(data2)));
      }
      HistoricalInfo(request) {
        const data = exports.QueryHistoricalInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", data);
        return promise.then((data2) => exports.QueryHistoricalInfoResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Pool(request) {
        const data = exports.QueryPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", data);
        return promise.then((data2) => exports.QueryPoolResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Params", data);
        return promise.then((data2) => exports.QueryParamsResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/queries/staking.js
var require_staking2 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/staking.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupStakingExtension = void 0;
    var query_1 = require_query10();
    var long_1 = __importDefault(require_long());
    var utils_1 = require_utils2();
    function setupStakingExtension(base) {
      const rpc = (0, utils_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        staking: {
          delegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.Delegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorUnbondingDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorUnbondingDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorValidator: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegatorValidator({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddr: delegatorAddress,
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          historicalInfo: async (height) => {
            const response = await queryService.HistoricalInfo({
              height: long_1.default.fromNumber(height, true)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          pool: async () => {
            const response = await queryService.Pool({});
            return response;
          },
          redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey) => {
            const response = await queryService.Redelegations({
              delegatorAddr: delegatorAddress,
              srcValidatorAddr: sourceValidatorAddress,
              dstValidatorAddr: destinationValidatorAddress,
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          unbondingDelegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.UnbondingDelegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          validator: async (validatorAddress) => {
            const response = await queryService.Validator({ validatorAddr: validatorAddress });
            return response;
          },
          validatorDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          validators: async (status, paginationKey) => {
            const response = await queryService.Validators({
              status,
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          },
          validatorUnbondingDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorUnbondingDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, utils_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
    exports.setupStakingExtension = setupStakingExtension;
  }
});

// node_modules/cosmjs-types/tendermint/types/params.js
var require_params = __commonJS({
  "node_modules/cosmjs-types/tendermint/types/params.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashedParams = exports.VersionParams = exports.ValidatorParams = exports.EvidenceParams = exports.BlockParams = exports.ConsensusParams = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var duration_1 = require_duration();
    exports.protobufPackage = "tendermint.types";
    var baseConsensusParams = {};
    exports.ConsensusParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.block !== void 0) {
          exports.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          exports.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== void 0) {
          exports.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== void 0) {
          exports.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConsensusParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = exports.BlockParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.evidence = exports.EvidenceParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.validator = exports.ValidatorParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.version = exports.VersionParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseConsensusParams);
        message.block = object.block !== void 0 && object.block !== null ? exports.BlockParams.fromJSON(object.block) : void 0;
        message.evidence = object.evidence !== void 0 && object.evidence !== null ? exports.EvidenceParams.fromJSON(object.evidence) : void 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? exports.ValidatorParams.fromJSON(object.validator) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? exports.VersionParams.fromJSON(object.version) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block ? exports.BlockParams.toJSON(message.block) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? exports.EvidenceParams.toJSON(message.evidence) : void 0);
        message.validator !== void 0 && (obj.validator = message.validator ? exports.ValidatorParams.toJSON(message.validator) : void 0);
        message.version !== void 0 && (obj.version = message.version ? exports.VersionParams.toJSON(message.version) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseConsensusParams);
        message.block = object.block !== void 0 && object.block !== null ? exports.BlockParams.fromPartial(object.block) : void 0;
        message.evidence = object.evidence !== void 0 && object.evidence !== null ? exports.EvidenceParams.fromPartial(object.evidence) : void 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? exports.ValidatorParams.fromPartial(object.validator) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? exports.VersionParams.fromPartial(object.version) : void 0;
        return message;
      }
    };
    var baseBlockParams = { maxBytes: long_1.default.ZERO, maxGas: long_1.default.ZERO, timeIotaMs: long_1.default.ZERO };
    exports.BlockParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxBytes.isZero()) {
          writer.uint32(8).int64(message.maxBytes);
        }
        if (!message.maxGas.isZero()) {
          writer.uint32(16).int64(message.maxGas);
        }
        if (!message.timeIotaMs.isZero()) {
          writer.uint32(24).int64(message.timeIotaMs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBlockParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxBytes = reader.int64();
              break;
            case 2:
              message.maxGas = reader.int64();
              break;
            case 3:
              message.timeIotaMs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseBlockParams);
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromString(object.maxBytes) : long_1.default.ZERO;
        message.maxGas = object.maxGas !== void 0 && object.maxGas !== null ? long_1.default.fromString(object.maxGas) : long_1.default.ZERO;
        message.timeIotaMs = object.timeIotaMs !== void 0 && object.timeIotaMs !== null ? long_1.default.fromString(object.timeIotaMs) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || long_1.default.ZERO).toString());
        message.maxGas !== void 0 && (obj.maxGas = (message.maxGas || long_1.default.ZERO).toString());
        message.timeIotaMs !== void 0 && (obj.timeIotaMs = (message.timeIotaMs || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseBlockParams);
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO;
        message.maxGas = object.maxGas !== void 0 && object.maxGas !== null ? long_1.default.fromValue(object.maxGas) : long_1.default.ZERO;
        message.timeIotaMs = object.timeIotaMs !== void 0 && object.timeIotaMs !== null ? long_1.default.fromValue(object.timeIotaMs) : long_1.default.ZERO;
        return message;
      }
    };
    var baseEvidenceParams = { maxAgeNumBlocks: long_1.default.ZERO, maxBytes: long_1.default.ZERO };
    exports.EvidenceParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxAgeNumBlocks.isZero()) {
          writer.uint32(8).int64(message.maxAgeNumBlocks);
        }
        if (message.maxAgeDuration !== void 0) {
          duration_1.Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
        }
        if (!message.maxBytes.isZero()) {
          writer.uint32(24).int64(message.maxBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseEvidenceParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxAgeNumBlocks = reader.int64();
              break;
            case 2:
              message.maxAgeDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxBytes = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseEvidenceParams);
        message.maxAgeNumBlocks = object.maxAgeNumBlocks !== void 0 && object.maxAgeNumBlocks !== null ? long_1.default.fromString(object.maxAgeNumBlocks) : long_1.default.ZERO;
        message.maxAgeDuration = object.maxAgeDuration !== void 0 && object.maxAgeDuration !== null ? duration_1.Duration.fromJSON(object.maxAgeDuration) : void 0;
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromString(object.maxBytes) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.maxAgeNumBlocks !== void 0 && (obj.maxAgeNumBlocks = (message.maxAgeNumBlocks || long_1.default.ZERO).toString());
        message.maxAgeDuration !== void 0 && (obj.maxAgeDuration = message.maxAgeDuration ? duration_1.Duration.toJSON(message.maxAgeDuration) : void 0);
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseEvidenceParams);
        message.maxAgeNumBlocks = object.maxAgeNumBlocks !== void 0 && object.maxAgeNumBlocks !== null ? long_1.default.fromValue(object.maxAgeNumBlocks) : long_1.default.ZERO;
        message.maxAgeDuration = object.maxAgeDuration !== void 0 && object.maxAgeDuration !== null ? duration_1.Duration.fromPartial(object.maxAgeDuration) : void 0;
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO;
        return message;
      }
    };
    var baseValidatorParams = { pubKeyTypes: "" };
    exports.ValidatorParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.pubKeyTypes) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorParams);
        message.pubKeyTypes = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKeyTypes.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseValidatorParams);
        message.pubKeyTypes = ((_a = object.pubKeyTypes) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.pubKeyTypes) {
          obj.pubKeyTypes = message.pubKeyTypes.map((e) => e);
        } else {
          obj.pubKeyTypes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidatorParams);
        message.pubKeyTypes = ((_a = object.pubKeyTypes) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
      }
    };
    var baseVersionParams = { appVersion: long_1.default.UZERO };
    exports.VersionParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.appVersion.isZero()) {
          writer.uint32(8).uint64(message.appVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVersionParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.appVersion = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseVersionParams);
        message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? long_1.default.fromString(object.appVersion) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.appVersion !== void 0 && (obj.appVersion = (message.appVersion || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseVersionParams);
        message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? long_1.default.fromValue(object.appVersion) : long_1.default.UZERO;
        return message;
      }
    };
    var baseHashedParams = { blockMaxBytes: long_1.default.ZERO, blockMaxGas: long_1.default.ZERO };
    exports.HashedParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.blockMaxBytes.isZero()) {
          writer.uint32(8).int64(message.blockMaxBytes);
        }
        if (!message.blockMaxGas.isZero()) {
          writer.uint32(16).int64(message.blockMaxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHashedParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockMaxBytes = reader.int64();
              break;
            case 2:
              message.blockMaxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseHashedParams);
        message.blockMaxBytes = object.blockMaxBytes !== void 0 && object.blockMaxBytes !== null ? long_1.default.fromString(object.blockMaxBytes) : long_1.default.ZERO;
        message.blockMaxGas = object.blockMaxGas !== void 0 && object.blockMaxGas !== null ? long_1.default.fromString(object.blockMaxGas) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.blockMaxBytes !== void 0 && (obj.blockMaxBytes = (message.blockMaxBytes || long_1.default.ZERO).toString());
        message.blockMaxGas !== void 0 && (obj.blockMaxGas = (message.blockMaxGas || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseHashedParams);
        message.blockMaxBytes = object.blockMaxBytes !== void 0 && object.blockMaxBytes !== null ? long_1.default.fromValue(object.blockMaxBytes) : long_1.default.ZERO;
        message.blockMaxGas = object.blockMaxGas !== void 0 && object.blockMaxGas !== null ? long_1.default.fromValue(object.blockMaxGas) : long_1.default.ZERO;
        return message;
      }
    };
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/tendermint/abci/types.js
var require_types3 = __commonJS({
  "node_modules/cosmjs-types/tendermint/abci/types.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Event = exports.LastCommitInfo = exports.BlockParams = exports.ConsensusParams = exports.ResponseApplySnapshotChunk = exports.ResponseLoadSnapshotChunk = exports.ResponseOfferSnapshot = exports.ResponseListSnapshots = exports.ResponseCommit = exports.ResponseEndBlock = exports.ResponseDeliverTx = exports.ResponseCheckTx = exports.ResponseBeginBlock = exports.ResponseQuery = exports.ResponseInitChain = exports.ResponseSetOption = exports.ResponseInfo = exports.ResponseFlush = exports.ResponseEcho = exports.ResponseException = exports.Response = exports.RequestApplySnapshotChunk = exports.RequestLoadSnapshotChunk = exports.RequestOfferSnapshot = exports.RequestListSnapshots = exports.RequestCommit = exports.RequestEndBlock = exports.RequestDeliverTx = exports.RequestCheckTx = exports.RequestBeginBlock = exports.RequestQuery = exports.RequestInitChain = exports.RequestSetOption = exports.RequestInfo = exports.RequestFlush = exports.RequestEcho = exports.Request = exports.responseApplySnapshotChunk_ResultToJSON = exports.responseApplySnapshotChunk_ResultFromJSON = exports.ResponseApplySnapshotChunk_Result = exports.responseOfferSnapshot_ResultToJSON = exports.responseOfferSnapshot_ResultFromJSON = exports.ResponseOfferSnapshot_Result = exports.evidenceTypeToJSON = exports.evidenceTypeFromJSON = exports.EvidenceType = exports.checkTxTypeToJSON = exports.checkTxTypeFromJSON = exports.CheckTxType = exports.protobufPackage = void 0;
    exports.ABCIApplicationClientImpl = exports.Snapshot = exports.Evidence = exports.VoteInfo = exports.ValidatorUpdate = exports.Validator = exports.TxResult = exports.EventAttribute = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var timestamp_1 = require_timestamp();
    var types_1 = require_types2();
    var proof_1 = require_proof();
    var params_1 = require_params();
    var keys_1 = require_keys();
    exports.protobufPackage = "tendermint.abci";
    var CheckTxType;
    (function(CheckTxType2) {
      CheckTxType2[CheckTxType2["NEW"] = 0] = "NEW";
      CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
      CheckTxType2[CheckTxType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CheckTxType = exports.CheckTxType || (exports.CheckTxType = {}));
    function checkTxTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "NEW":
          return CheckTxType.NEW;
        case 1:
        case "RECHECK":
          return CheckTxType.RECHECK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return CheckTxType.UNRECOGNIZED;
      }
    }
    exports.checkTxTypeFromJSON = checkTxTypeFromJSON;
    function checkTxTypeToJSON(object) {
      switch (object) {
        case CheckTxType.NEW:
          return "NEW";
        case CheckTxType.RECHECK:
          return "RECHECK";
        default:
          return "UNKNOWN";
      }
    }
    exports.checkTxTypeToJSON = checkTxTypeToJSON;
    var EvidenceType;
    (function(EvidenceType2) {
      EvidenceType2[EvidenceType2["UNKNOWN"] = 0] = "UNKNOWN";
      EvidenceType2[EvidenceType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
      EvidenceType2[EvidenceType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
      EvidenceType2[EvidenceType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EvidenceType = exports.EvidenceType || (exports.EvidenceType = {}));
    function evidenceTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return EvidenceType.UNKNOWN;
        case 1:
        case "DUPLICATE_VOTE":
          return EvidenceType.DUPLICATE_VOTE;
        case 2:
        case "LIGHT_CLIENT_ATTACK":
          return EvidenceType.LIGHT_CLIENT_ATTACK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return EvidenceType.UNRECOGNIZED;
      }
    }
    exports.evidenceTypeFromJSON = evidenceTypeFromJSON;
    function evidenceTypeToJSON(object) {
      switch (object) {
        case EvidenceType.UNKNOWN:
          return "UNKNOWN";
        case EvidenceType.DUPLICATE_VOTE:
          return "DUPLICATE_VOTE";
        case EvidenceType.LIGHT_CLIENT_ATTACK:
          return "LIGHT_CLIENT_ATTACK";
        default:
          return "UNKNOWN";
      }
    }
    exports.evidenceTypeToJSON = evidenceTypeToJSON;
    var ResponseOfferSnapshot_Result;
    (function(ResponseOfferSnapshot_Result2) {
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ABORT"] = 2] = "ABORT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT"] = 3] = "REJECT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseOfferSnapshot_Result = exports.ResponseOfferSnapshot_Result || (exports.ResponseOfferSnapshot_Result = {}));
    function responseOfferSnapshot_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseOfferSnapshot_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseOfferSnapshot_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseOfferSnapshot_Result.ABORT;
        case 3:
        case "REJECT":
          return ResponseOfferSnapshot_Result.REJECT;
        case 4:
        case "REJECT_FORMAT":
          return ResponseOfferSnapshot_Result.REJECT_FORMAT;
        case 5:
        case "REJECT_SENDER":
          return ResponseOfferSnapshot_Result.REJECT_SENDER;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseOfferSnapshot_Result.UNRECOGNIZED;
      }
    }
    exports.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;
    function responseOfferSnapshot_ResultToJSON(object) {
      switch (object) {
        case ResponseOfferSnapshot_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseOfferSnapshot_Result.ACCEPT:
          return "ACCEPT";
        case ResponseOfferSnapshot_Result.ABORT:
          return "ABORT";
        case ResponseOfferSnapshot_Result.REJECT:
          return "REJECT";
        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
          return "REJECT_FORMAT";
        case ResponseOfferSnapshot_Result.REJECT_SENDER:
          return "REJECT_SENDER";
        default:
          return "UNKNOWN";
      }
    }
    exports.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;
    var ResponseApplySnapshotChunk_Result;
    (function(ResponseApplySnapshotChunk_Result2) {
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ABORT"] = 2] = "ABORT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY"] = 3] = "RETRY";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseApplySnapshotChunk_Result = exports.ResponseApplySnapshotChunk_Result || (exports.ResponseApplySnapshotChunk_Result = {}));
    function responseApplySnapshotChunk_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseApplySnapshotChunk_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseApplySnapshotChunk_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseApplySnapshotChunk_Result.ABORT;
        case 3:
        case "RETRY":
          return ResponseApplySnapshotChunk_Result.RETRY;
        case 4:
        case "RETRY_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
        case 5:
        case "REJECT_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
      }
    }
    exports.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;
    function responseApplySnapshotChunk_ResultToJSON(object) {
      switch (object) {
        case ResponseApplySnapshotChunk_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseApplySnapshotChunk_Result.ACCEPT:
          return "ACCEPT";
        case ResponseApplySnapshotChunk_Result.ABORT:
          return "ABORT";
        case ResponseApplySnapshotChunk_Result.RETRY:
          return "RETRY";
        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
          return "RETRY_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
          return "REJECT_SNAPSHOT";
        default:
          return "UNKNOWN";
      }
    }
    exports.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;
    var baseRequest = {};
    exports.Request = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.echo !== void 0) {
          exports.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        if (message.setOption !== void 0) {
          exports.RequestSetOption.encode(message.setOption, writer.uint32(34).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
        }
        if (message.beginBlock !== void 0) {
          exports.RequestBeginBlock.encode(message.beginBlock, writer.uint32(58).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
        }
        if (message.deliverTx !== void 0) {
          exports.RequestDeliverTx.encode(message.deliverTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.endBlock !== void 0) {
          exports.RequestEndBlock.encode(message.endBlock, writer.uint32(82).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.echo = exports.RequestEcho.decode(reader, reader.uint32());
              break;
            case 2:
              message.flush = exports.RequestFlush.decode(reader, reader.uint32());
              break;
            case 3:
              message.info = exports.RequestInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.setOption = exports.RequestSetOption.decode(reader, reader.uint32());
              break;
            case 5:
              message.initChain = exports.RequestInitChain.decode(reader, reader.uint32());
              break;
            case 6:
              message.query = exports.RequestQuery.decode(reader, reader.uint32());
              break;
            case 7:
              message.beginBlock = exports.RequestBeginBlock.decode(reader, reader.uint32());
              break;
            case 8:
              message.checkTx = exports.RequestCheckTx.decode(reader, reader.uint32());
              break;
            case 9:
              message.deliverTx = exports.RequestDeliverTx.decode(reader, reader.uint32());
              break;
            case 10:
              message.endBlock = exports.RequestEndBlock.decode(reader, reader.uint32());
              break;
            case 11:
              message.commit = exports.RequestCommit.decode(reader, reader.uint32());
              break;
            case 12:
              message.listSnapshots = exports.RequestListSnapshots.decode(reader, reader.uint32());
              break;
            case 13:
              message.offerSnapshot = exports.RequestOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 14:
              message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 15:
              message.applySnapshotChunk = exports.RequestApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequest);
        message.echo = object.echo !== void 0 && object.echo !== null ? exports.RequestEcho.fromJSON(object.echo) : void 0;
        message.flush = object.flush !== void 0 && object.flush !== null ? exports.RequestFlush.fromJSON(object.flush) : void 0;
        message.info = object.info !== void 0 && object.info !== null ? exports.RequestInfo.fromJSON(object.info) : void 0;
        message.setOption = object.setOption !== void 0 && object.setOption !== null ? exports.RequestSetOption.fromJSON(object.setOption) : void 0;
        message.initChain = object.initChain !== void 0 && object.initChain !== null ? exports.RequestInitChain.fromJSON(object.initChain) : void 0;
        message.query = object.query !== void 0 && object.query !== null ? exports.RequestQuery.fromJSON(object.query) : void 0;
        message.beginBlock = object.beginBlock !== void 0 && object.beginBlock !== null ? exports.RequestBeginBlock.fromJSON(object.beginBlock) : void 0;
        message.checkTx = object.checkTx !== void 0 && object.checkTx !== null ? exports.RequestCheckTx.fromJSON(object.checkTx) : void 0;
        message.deliverTx = object.deliverTx !== void 0 && object.deliverTx !== null ? exports.RequestDeliverTx.fromJSON(object.deliverTx) : void 0;
        message.endBlock = object.endBlock !== void 0 && object.endBlock !== null ? exports.RequestEndBlock.fromJSON(object.endBlock) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports.RequestCommit.fromJSON(object.commit) : void 0;
        message.listSnapshots = object.listSnapshots !== void 0 && object.listSnapshots !== null ? exports.RequestListSnapshots.fromJSON(object.listSnapshots) : void 0;
        message.offerSnapshot = object.offerSnapshot !== void 0 && object.offerSnapshot !== null ? exports.RequestOfferSnapshot.fromJSON(object.offerSnapshot) : void 0;
        message.loadSnapshotChunk = object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null ? exports.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk) : void 0;
        message.applySnapshotChunk = object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null ? exports.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.echo !== void 0 && (obj.echo = message.echo ? exports.RequestEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports.RequestFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports.RequestInfo.toJSON(message.info) : void 0);
        message.setOption !== void 0 && (obj.setOption = message.setOption ? exports.RequestSetOption.toJSON(message.setOption) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports.RequestInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports.RequestQuery.toJSON(message.query) : void 0);
        message.beginBlock !== void 0 && (obj.beginBlock = message.beginBlock ? exports.RequestBeginBlock.toJSON(message.beginBlock) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports.RequestCheckTx.toJSON(message.checkTx) : void 0);
        message.deliverTx !== void 0 && (obj.deliverTx = message.deliverTx ? exports.RequestDeliverTx.toJSON(message.deliverTx) : void 0);
        message.endBlock !== void 0 && (obj.endBlock = message.endBlock ? exports.RequestEndBlock.toJSON(message.endBlock) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.RequestCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports.RequestListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports.RequestOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseRequest);
        message.echo = object.echo !== void 0 && object.echo !== null ? exports.RequestEcho.fromPartial(object.echo) : void 0;
        message.flush = object.flush !== void 0 && object.flush !== null ? exports.RequestFlush.fromPartial(object.flush) : void 0;
        message.info = object.info !== void 0 && object.info !== null ? exports.RequestInfo.fromPartial(object.info) : void 0;
        message.setOption = object.setOption !== void 0 && object.setOption !== null ? exports.RequestSetOption.fromPartial(object.setOption) : void 0;
        message.initChain = object.initChain !== void 0 && object.initChain !== null ? exports.RequestInitChain.fromPartial(object.initChain) : void 0;
        message.query = object.query !== void 0 && object.query !== null ? exports.RequestQuery.fromPartial(object.query) : void 0;
        message.beginBlock = object.beginBlock !== void 0 && object.beginBlock !== null ? exports.RequestBeginBlock.fromPartial(object.beginBlock) : void 0;
        message.checkTx = object.checkTx !== void 0 && object.checkTx !== null ? exports.RequestCheckTx.fromPartial(object.checkTx) : void 0;
        message.deliverTx = object.deliverTx !== void 0 && object.deliverTx !== null ? exports.RequestDeliverTx.fromPartial(object.deliverTx) : void 0;
        message.endBlock = object.endBlock !== void 0 && object.endBlock !== null ? exports.RequestEndBlock.fromPartial(object.endBlock) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports.RequestCommit.fromPartial(object.commit) : void 0;
        message.listSnapshots = object.listSnapshots !== void 0 && object.listSnapshots !== null ? exports.RequestListSnapshots.fromPartial(object.listSnapshots) : void 0;
        message.offerSnapshot = object.offerSnapshot !== void 0 && object.offerSnapshot !== null ? exports.RequestOfferSnapshot.fromPartial(object.offerSnapshot) : void 0;
        message.loadSnapshotChunk = object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null ? exports.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk) : void 0;
        message.applySnapshotChunk = object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null ? exports.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk) : void 0;
        return message;
      }
    };
    var baseRequestEcho = { message: "" };
    exports.RequestEcho = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestEcho);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestEcho);
        message.message = object.message !== void 0 && object.message !== null ? String(object.message) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseRequestEcho);
        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseRequestFlush = {};
    exports.RequestFlush = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestFlush);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseRequestFlush);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseRequestFlush);
        return message;
      }
    };
    var baseRequestInfo = { version: "", blockVersion: long_1.default.UZERO, p2pVersion: long_1.default.UZERO };
    exports.RequestInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (!message.blockVersion.isZero()) {
          writer.uint32(16).uint64(message.blockVersion);
        }
        if (!message.p2pVersion.isZero()) {
          writer.uint32(24).uint64(message.p2pVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestInfo);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.blockVersion = reader.uint64();
              break;
            case 3:
              message.p2pVersion = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestInfo);
        message.version = object.version !== void 0 && object.version !== null ? String(object.version) : "";
        message.blockVersion = object.blockVersion !== void 0 && object.blockVersion !== null ? long_1.default.fromString(object.blockVersion) : long_1.default.UZERO;
        message.p2pVersion = object.p2pVersion !== void 0 && object.p2pVersion !== null ? long_1.default.fromString(object.p2pVersion) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.blockVersion !== void 0 && (obj.blockVersion = (message.blockVersion || long_1.default.UZERO).toString());
        message.p2pVersion !== void 0 && (obj.p2pVersion = (message.p2pVersion || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseRequestInfo);
        message.version = (_a = object.version) !== null && _a !== void 0 ? _a : "";
        message.blockVersion = object.blockVersion !== void 0 && object.blockVersion !== null ? long_1.default.fromValue(object.blockVersion) : long_1.default.UZERO;
        message.p2pVersion = object.p2pVersion !== void 0 && object.p2pVersion !== null ? long_1.default.fromValue(object.p2pVersion) : long_1.default.UZERO;
        return message;
      }
    };
    var baseRequestSetOption = { key: "", value: "" };
    exports.RequestSetOption = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestSetOption);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestSetOption);
        message.key = object.key !== void 0 && object.key !== null ? String(object.key) : "";
        message.value = object.value !== void 0 && object.value !== null ? String(object.value) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseRequestSetOption);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseRequestInitChain = { chainId: "", initialHeight: long_1.default.ZERO };
    exports.RequestInitChain = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.consensusParams !== void 0) {
          exports.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports.ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.appStateBytes.length !== 0) {
          writer.uint32(42).bytes(message.appStateBytes);
        }
        if (!message.initialHeight.isZero()) {
          writer.uint32(48).int64(message.initialHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestInitChain);
        message.validators = [];
        message.appStateBytes = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.consensusParams = exports.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 5:
              message.appStateBytes = reader.bytes();
              break;
            case 6:
              message.initialHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseRequestInitChain);
        message.time = object.time !== void 0 && object.time !== null ? fromJsonTimestamp(object.time) : void 0;
        message.chainId = object.chainId !== void 0 && object.chainId !== null ? String(object.chainId) : "";
        message.consensusParams = object.consensusParams !== void 0 && object.consensusParams !== null ? exports.ConsensusParams.fromJSON(object.consensusParams) : void 0;
        message.validators = ((_a = object.validators) !== null && _a !== void 0 ? _a : []).map((e) => exports.ValidatorUpdate.fromJSON(e));
        message.appStateBytes = object.appStateBytes !== void 0 && object.appStateBytes !== null ? bytesFromBase64(object.appStateBytes) : new Uint8Array();
        message.initialHeight = object.initialHeight !== void 0 && object.initialHeight !== null ? long_1.default.fromString(object.initialHeight) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.time !== void 0 && (obj.time = fromTimestamp(message.time).toISOString());
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? exports.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appStateBytes !== void 0 && (obj.appStateBytes = base64FromBytes(message.appStateBytes !== void 0 ? message.appStateBytes : new Uint8Array()));
        message.initialHeight !== void 0 && (obj.initialHeight = (message.initialHeight || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseRequestInitChain);
        message.time = object.time !== void 0 && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : void 0;
        message.chainId = (_a = object.chainId) !== null && _a !== void 0 ? _a : "";
        message.consensusParams = object.consensusParams !== void 0 && object.consensusParams !== null ? exports.ConsensusParams.fromPartial(object.consensusParams) : void 0;
        message.validators = ((_b = object.validators) === null || _b === void 0 ? void 0 : _b.map((e) => exports.ValidatorUpdate.fromPartial(e))) || [];
        message.appStateBytes = (_c = object.appStateBytes) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.initialHeight = object.initialHeight !== void 0 && object.initialHeight !== null ? long_1.default.fromValue(object.initialHeight) : long_1.default.ZERO;
        return message;
      }
    };
    var baseRequestQuery = { path: "", height: long_1.default.ZERO, prove: false };
    exports.RequestQuery = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.path !== "") {
          writer.uint32(18).string(message.path);
        }
        if (!message.height.isZero()) {
          writer.uint32(24).int64(message.height);
        }
        if (message.prove === true) {
          writer.uint32(32).bool(message.prove);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestQuery);
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.path = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.prove = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestQuery);
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        message.path = object.path !== void 0 && object.path !== null ? String(object.path) : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.prove = object.prove !== void 0 && object.prove !== null ? Boolean(object.prove) : false;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.path !== void 0 && (obj.path = message.path);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.prove !== void 0 && (obj.prove = message.prove);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseRequestQuery);
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.path = (_b = object.path) !== null && _b !== void 0 ? _b : "";
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.prove = (_c = object.prove) !== null && _c !== void 0 ? _c : false;
        return message;
      }
    };
    var baseRequestBeginBlock = {};
    exports.RequestBeginBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(18).fork()).ldelim();
        }
        if (message.lastCommitInfo !== void 0) {
          exports.LastCommitInfo.encode(message.lastCommitInfo, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.byzantineValidators) {
          exports.Evidence.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestBeginBlock);
        message.byzantineValidators = [];
        message.hash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.lastCommitInfo = exports.LastCommitInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.byzantineValidators.push(exports.Evidence.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseRequestBeginBlock);
        message.hash = object.hash !== void 0 && object.hash !== null ? bytesFromBase64(object.hash) : new Uint8Array();
        message.header = object.header !== void 0 && object.header !== null ? types_1.Header.fromJSON(object.header) : void 0;
        message.lastCommitInfo = object.lastCommitInfo !== void 0 && object.lastCommitInfo !== null ? exports.LastCommitInfo.fromJSON(object.lastCommitInfo) : void 0;
        message.byzantineValidators = ((_a = object.byzantineValidators) !== null && _a !== void 0 ? _a : []).map((e) => exports.Evidence.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        message.lastCommitInfo !== void 0 && (obj.lastCommitInfo = message.lastCommitInfo ? exports.LastCommitInfo.toJSON(message.lastCommitInfo) : void 0);
        if (message.byzantineValidators) {
          obj.byzantineValidators = message.byzantineValidators.map((e) => e ? exports.Evidence.toJSON(e) : void 0);
        } else {
          obj.byzantineValidators = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseRequestBeginBlock);
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.header = object.header !== void 0 && object.header !== null ? types_1.Header.fromPartial(object.header) : void 0;
        message.lastCommitInfo = object.lastCommitInfo !== void 0 && object.lastCommitInfo !== null ? exports.LastCommitInfo.fromPartial(object.lastCommitInfo) : void 0;
        message.byzantineValidators = ((_b = object.byzantineValidators) === null || _b === void 0 ? void 0 : _b.map((e) => exports.Evidence.fromPartial(e))) || [];
        return message;
      }
    };
    var baseRequestCheckTx = { type: 0 };
    exports.RequestCheckTx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        if (message.type !== 0) {
          writer.uint32(16).int32(message.type);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestCheckTx);
        message.tx = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            case 2:
              message.type = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestCheckTx);
        message.tx = object.tx !== void 0 && object.tx !== null ? bytesFromBase64(object.tx) : new Uint8Array();
        message.type = object.type !== void 0 && object.type !== null ? checkTxTypeFromJSON(object.type) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = base64FromBytes(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.type !== void 0 && (obj.type = checkTxTypeToJSON(message.type));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseRequestCheckTx);
        message.tx = (_a = object.tx) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.type = (_b = object.type) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var baseRequestDeliverTx = {};
    exports.RequestDeliverTx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestDeliverTx);
        message.tx = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestDeliverTx);
        message.tx = object.tx !== void 0 && object.tx !== null ? bytesFromBase64(object.tx) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = base64FromBytes(message.tx !== void 0 ? message.tx : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseRequestDeliverTx);
        message.tx = (_a = object.tx) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var baseRequestEndBlock = { height: long_1.default.ZERO };
    exports.RequestEndBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestEndBlock);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestEndBlock);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseRequestEndBlock);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        return message;
      }
    };
    var baseRequestCommit = {};
    exports.RequestCommit = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestCommit);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseRequestCommit);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseRequestCommit);
        return message;
      }
    };
    var baseRequestListSnapshots = {};
    exports.RequestListSnapshots = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestListSnapshots);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseRequestListSnapshots);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseRequestListSnapshots);
        return message;
      }
    };
    var baseRequestOfferSnapshot = {};
    exports.RequestOfferSnapshot = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.snapshot !== void 0) {
          exports.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(18).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestOfferSnapshot);
        message.appHash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshot = exports.Snapshot.decode(reader, reader.uint32());
              break;
            case 2:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestOfferSnapshot);
        message.snapshot = object.snapshot !== void 0 && object.snapshot !== null ? exports.Snapshot.fromJSON(object.snapshot) : void 0;
        message.appHash = object.appHash !== void 0 && object.appHash !== null ? bytesFromBase64(object.appHash) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.snapshot !== void 0 && (obj.snapshot = message.snapshot ? exports.Snapshot.toJSON(message.snapshot) : void 0);
        message.appHash !== void 0 && (obj.appHash = base64FromBytes(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseRequestOfferSnapshot);
        message.snapshot = object.snapshot !== void 0 && object.snapshot !== null ? exports.Snapshot.fromPartial(object.snapshot) : void 0;
        message.appHash = (_a = object.appHash) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var baseRequestLoadSnapshotChunk = { height: long_1.default.UZERO, format: 0, chunk: 0 };
    exports.RequestLoadSnapshotChunk = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunk !== 0) {
          writer.uint32(24).uint32(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestLoadSnapshotChunk);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunk = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestLoadSnapshotChunk);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.UZERO;
        message.format = object.format !== void 0 && object.format !== null ? Number(object.format) : 0;
        message.chunk = object.chunk !== void 0 && object.chunk !== null ? Number(object.chunk) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.UZERO).toString());
        message.format !== void 0 && (obj.format = message.format);
        message.chunk !== void 0 && (obj.chunk = message.chunk);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseRequestLoadSnapshotChunk);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.UZERO;
        message.format = (_a = object.format) !== null && _a !== void 0 ? _a : 0;
        message.chunk = (_b = object.chunk) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var baseRequestApplySnapshotChunk = { index: 0, sender: "" };
    exports.RequestApplySnapshotChunk = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.chunk.length !== 0) {
          writer.uint32(18).bytes(message.chunk);
        }
        if (message.sender !== "") {
          writer.uint32(26).string(message.sender);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestApplySnapshotChunk);
        message.chunk = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.chunk = reader.bytes();
              break;
            case 3:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseRequestApplySnapshotChunk);
        message.index = object.index !== void 0 && object.index !== null ? Number(object.index) : 0;
        message.chunk = object.chunk !== void 0 && object.chunk !== null ? bytesFromBase64(object.chunk) : new Uint8Array();
        message.sender = object.sender !== void 0 && object.sender !== null ? String(object.sender) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = message.index);
        message.chunk !== void 0 && (obj.chunk = base64FromBytes(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        message.sender !== void 0 && (obj.sender = message.sender);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseRequestApplySnapshotChunk);
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.chunk = (_b = object.chunk) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.sender = (_c = object.sender) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseResponse = {};
    exports.Response = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exception !== void 0) {
          exports.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
        }
        if (message.echo !== void 0) {
          exports.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
        }
        if (message.setOption !== void 0) {
          exports.ResponseSetOption.encode(message.setOption, writer.uint32(42).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
        }
        if (message.beginBlock !== void 0) {
          exports.ResponseBeginBlock.encode(message.beginBlock, writer.uint32(66).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.deliverTx !== void 0) {
          exports.ResponseDeliverTx.encode(message.deliverTx, writer.uint32(82).fork()).ldelim();
        }
        if (message.endBlock !== void 0) {
          exports.ResponseEndBlock.encode(message.endBlock, writer.uint32(90).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exception = exports.ResponseException.decode(reader, reader.uint32());
              break;
            case 2:
              message.echo = exports.ResponseEcho.decode(reader, reader.uint32());
              break;
            case 3:
              message.flush = exports.ResponseFlush.decode(reader, reader.uint32());
              break;
            case 4:
              message.info = exports.ResponseInfo.decode(reader, reader.uint32());
              break;
            case 5:
              message.setOption = exports.ResponseSetOption.decode(reader, reader.uint32());
              break;
            case 6:
              message.initChain = exports.ResponseInitChain.decode(reader, reader.uint32());
              break;
            case 7:
              message.query = exports.ResponseQuery.decode(reader, reader.uint32());
              break;
            case 8:
              message.beginBlock = exports.ResponseBeginBlock.decode(reader, reader.uint32());
              break;
            case 9:
              message.checkTx = exports.ResponseCheckTx.decode(reader, reader.uint32());
              break;
            case 10:
              message.deliverTx = exports.ResponseDeliverTx.decode(reader, reader.uint32());
              break;
            case 11:
              message.endBlock = exports.ResponseEndBlock.decode(reader, reader.uint32());
              break;
            case 12:
              message.commit = exports.ResponseCommit.decode(reader, reader.uint32());
              break;
            case 13:
              message.listSnapshots = exports.ResponseListSnapshots.decode(reader, reader.uint32());
              break;
            case 14:
              message.offerSnapshot = exports.ResponseOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 15:
              message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponse);
        message.exception = object.exception !== void 0 && object.exception !== null ? exports.ResponseException.fromJSON(object.exception) : void 0;
        message.echo = object.echo !== void 0 && object.echo !== null ? exports.ResponseEcho.fromJSON(object.echo) : void 0;
        message.flush = object.flush !== void 0 && object.flush !== null ? exports.ResponseFlush.fromJSON(object.flush) : void 0;
        message.info = object.info !== void 0 && object.info !== null ? exports.ResponseInfo.fromJSON(object.info) : void 0;
        message.setOption = object.setOption !== void 0 && object.setOption !== null ? exports.ResponseSetOption.fromJSON(object.setOption) : void 0;
        message.initChain = object.initChain !== void 0 && object.initChain !== null ? exports.ResponseInitChain.fromJSON(object.initChain) : void 0;
        message.query = object.query !== void 0 && object.query !== null ? exports.ResponseQuery.fromJSON(object.query) : void 0;
        message.beginBlock = object.beginBlock !== void 0 && object.beginBlock !== null ? exports.ResponseBeginBlock.fromJSON(object.beginBlock) : void 0;
        message.checkTx = object.checkTx !== void 0 && object.checkTx !== null ? exports.ResponseCheckTx.fromJSON(object.checkTx) : void 0;
        message.deliverTx = object.deliverTx !== void 0 && object.deliverTx !== null ? exports.ResponseDeliverTx.fromJSON(object.deliverTx) : void 0;
        message.endBlock = object.endBlock !== void 0 && object.endBlock !== null ? exports.ResponseEndBlock.fromJSON(object.endBlock) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports.ResponseCommit.fromJSON(object.commit) : void 0;
        message.listSnapshots = object.listSnapshots !== void 0 && object.listSnapshots !== null ? exports.ResponseListSnapshots.fromJSON(object.listSnapshots) : void 0;
        message.offerSnapshot = object.offerSnapshot !== void 0 && object.offerSnapshot !== null ? exports.ResponseOfferSnapshot.fromJSON(object.offerSnapshot) : void 0;
        message.loadSnapshotChunk = object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null ? exports.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk) : void 0;
        message.applySnapshotChunk = object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null ? exports.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.exception !== void 0 && (obj.exception = message.exception ? exports.ResponseException.toJSON(message.exception) : void 0);
        message.echo !== void 0 && (obj.echo = message.echo ? exports.ResponseEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports.ResponseFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports.ResponseInfo.toJSON(message.info) : void 0);
        message.setOption !== void 0 && (obj.setOption = message.setOption ? exports.ResponseSetOption.toJSON(message.setOption) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports.ResponseInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports.ResponseQuery.toJSON(message.query) : void 0);
        message.beginBlock !== void 0 && (obj.beginBlock = message.beginBlock ? exports.ResponseBeginBlock.toJSON(message.beginBlock) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports.ResponseCheckTx.toJSON(message.checkTx) : void 0);
        message.deliverTx !== void 0 && (obj.deliverTx = message.deliverTx ? exports.ResponseDeliverTx.toJSON(message.deliverTx) : void 0);
        message.endBlock !== void 0 && (obj.endBlock = message.endBlock ? exports.ResponseEndBlock.toJSON(message.endBlock) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.ResponseCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports.ResponseListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseResponse);
        message.exception = object.exception !== void 0 && object.exception !== null ? exports.ResponseException.fromPartial(object.exception) : void 0;
        message.echo = object.echo !== void 0 && object.echo !== null ? exports.ResponseEcho.fromPartial(object.echo) : void 0;
        message.flush = object.flush !== void 0 && object.flush !== null ? exports.ResponseFlush.fromPartial(object.flush) : void 0;
        message.info = object.info !== void 0 && object.info !== null ? exports.ResponseInfo.fromPartial(object.info) : void 0;
        message.setOption = object.setOption !== void 0 && object.setOption !== null ? exports.ResponseSetOption.fromPartial(object.setOption) : void 0;
        message.initChain = object.initChain !== void 0 && object.initChain !== null ? exports.ResponseInitChain.fromPartial(object.initChain) : void 0;
        message.query = object.query !== void 0 && object.query !== null ? exports.ResponseQuery.fromPartial(object.query) : void 0;
        message.beginBlock = object.beginBlock !== void 0 && object.beginBlock !== null ? exports.ResponseBeginBlock.fromPartial(object.beginBlock) : void 0;
        message.checkTx = object.checkTx !== void 0 && object.checkTx !== null ? exports.ResponseCheckTx.fromPartial(object.checkTx) : void 0;
        message.deliverTx = object.deliverTx !== void 0 && object.deliverTx !== null ? exports.ResponseDeliverTx.fromPartial(object.deliverTx) : void 0;
        message.endBlock = object.endBlock !== void 0 && object.endBlock !== null ? exports.ResponseEndBlock.fromPartial(object.endBlock) : void 0;
        message.commit = object.commit !== void 0 && object.commit !== null ? exports.ResponseCommit.fromPartial(object.commit) : void 0;
        message.listSnapshots = object.listSnapshots !== void 0 && object.listSnapshots !== null ? exports.ResponseListSnapshots.fromPartial(object.listSnapshots) : void 0;
        message.offerSnapshot = object.offerSnapshot !== void 0 && object.offerSnapshot !== null ? exports.ResponseOfferSnapshot.fromPartial(object.offerSnapshot) : void 0;
        message.loadSnapshotChunk = object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null ? exports.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk) : void 0;
        message.applySnapshotChunk = object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null ? exports.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk) : void 0;
        return message;
      }
    };
    var baseResponseException = { error: "" };
    exports.ResponseException = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.error !== "") {
          writer.uint32(10).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseException);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponseException);
        message.error = object.error !== void 0 && object.error !== null ? String(object.error) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseResponseException);
        message.error = (_a = object.error) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseResponseEcho = { message: "" };
    exports.ResponseEcho = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseEcho);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponseEcho);
        message.message = object.message !== void 0 && object.message !== null ? String(object.message) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseResponseEcho);
        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseResponseFlush = {};
    exports.ResponseFlush = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseFlush);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseResponseFlush);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseResponseFlush);
        return message;
      }
    };
    var baseResponseInfo = {
      data: "",
      version: "",
      appVersion: long_1.default.UZERO,
      lastBlockHeight: long_1.default.ZERO
    };
    exports.ResponseInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data !== "") {
          writer.uint32(10).string(message.data);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        if (!message.appVersion.isZero()) {
          writer.uint32(24).uint64(message.appVersion);
        }
        if (!message.lastBlockHeight.isZero()) {
          writer.uint32(32).int64(message.lastBlockHeight);
        }
        if (message.lastBlockAppHash.length !== 0) {
          writer.uint32(42).bytes(message.lastBlockAppHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseInfo);
        message.lastBlockAppHash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            case 3:
              message.appVersion = reader.uint64();
              break;
            case 4:
              message.lastBlockHeight = reader.int64();
              break;
            case 5:
              message.lastBlockAppHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponseInfo);
        message.data = object.data !== void 0 && object.data !== null ? String(object.data) : "";
        message.version = object.version !== void 0 && object.version !== null ? String(object.version) : "";
        message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? long_1.default.fromString(object.appVersion) : long_1.default.UZERO;
        message.lastBlockHeight = object.lastBlockHeight !== void 0 && object.lastBlockHeight !== null ? long_1.default.fromString(object.lastBlockHeight) : long_1.default.ZERO;
        message.lastBlockAppHash = object.lastBlockAppHash !== void 0 && object.lastBlockAppHash !== null ? bytesFromBase64(object.lastBlockAppHash) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = message.data);
        message.version !== void 0 && (obj.version = message.version);
        message.appVersion !== void 0 && (obj.appVersion = (message.appVersion || long_1.default.UZERO).toString());
        message.lastBlockHeight !== void 0 && (obj.lastBlockHeight = (message.lastBlockHeight || long_1.default.ZERO).toString());
        message.lastBlockAppHash !== void 0 && (obj.lastBlockAppHash = base64FromBytes(message.lastBlockAppHash !== void 0 ? message.lastBlockAppHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseResponseInfo);
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : "";
        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : "";
        message.appVersion = object.appVersion !== void 0 && object.appVersion !== null ? long_1.default.fromValue(object.appVersion) : long_1.default.UZERO;
        message.lastBlockHeight = object.lastBlockHeight !== void 0 && object.lastBlockHeight !== null ? long_1.default.fromValue(object.lastBlockHeight) : long_1.default.ZERO;
        message.lastBlockAppHash = (_c = object.lastBlockAppHash) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
      }
    };
    var baseResponseSetOption = { code: 0, log: "", info: "" };
    exports.ResponseSetOption = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseSetOption);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponseSetOption);
        message.code = object.code !== void 0 && object.code !== null ? Number(object.code) : 0;
        message.log = object.log !== void 0 && object.log !== null ? String(object.log) : "";
        message.info = object.info !== void 0 && object.info !== null ? String(object.info) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = message.code);
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseResponseSetOption);
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.log = (_b = object.log) !== null && _b !== void 0 ? _b : "";
        message.info = (_c = object.info) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseResponseInitChain = {};
    exports.ResponseInitChain = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.consensusParams !== void 0) {
          exports.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.validators) {
          exports.ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(26).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseInitChain);
        message.validators = [];
        message.appHash = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusParams = exports.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 3:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseResponseInitChain);
        message.consensusParams = object.consensusParams !== void 0 && object.consensusParams !== null ? exports.ConsensusParams.fromJSON(object.consensusParams) : void 0;
        message.validators = ((_a = object.validators) !== null && _a !== void 0 ? _a : []).map((e) => exports.ValidatorUpdate.fromJSON(e));
        message.appHash = object.appHash !== void 0 && object.appHash !== null ? bytesFromBase64(object.appHash) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? exports.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appHash !== void 0 && (obj.appHash = base64FromBytes(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseResponseInitChain);
        message.consensusParams = object.consensusParams !== void 0 && object.consensusParams !== null ? exports.ConsensusParams.fromPartial(object.consensusParams) : void 0;
        message.validators = ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ValidatorUpdate.fromPartial(e))) || [];
        message.appHash = (_b = object.appHash) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var baseResponseQuery = {
      code: 0,
      log: "",
      info: "",
      index: long_1.default.ZERO,
      height: long_1.default.ZERO,
      codespace: ""
    };
    exports.ResponseQuery = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (!message.index.isZero()) {
          writer.uint32(40).int64(message.index);
        }
        if (message.key.length !== 0) {
          writer.uint32(50).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(58).bytes(message.value);
        }
        if (message.proofOps !== void 0) {
          proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
        }
        if (!message.height.isZero()) {
          writer.uint32(72).int64(message.height);
        }
        if (message.codespace !== "") {
          writer.uint32(82).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseQuery);
        message.key = new Uint8Array();
        message.value = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.index = reader.int64();
              break;
            case 6:
              message.key = reader.bytes();
              break;
            case 7:
              message.value = reader.bytes();
              break;
            case 8:
              message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());
              break;
            case 9:
              message.height = reader.int64();
              break;
            case 10:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponseQuery);
        message.code = object.code !== void 0 && object.code !== null ? Number(object.code) : 0;
        message.log = object.log !== void 0 && object.log !== null ? String(object.log) : "";
        message.info = object.info !== void 0 && object.info !== null ? String(object.info) : "";
        message.index = object.index !== void 0 && object.index !== null ? long_1.default.fromString(object.index) : long_1.default.ZERO;
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.value = object.value !== void 0 && object.value !== null ? bytesFromBase64(object.value) : new Uint8Array();
        message.proofOps = object.proofOps !== void 0 && object.proofOps !== null ? proof_1.ProofOps.fromJSON(object.proofOps) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.codespace = object.codespace !== void 0 && object.codespace !== null ? String(object.codespace) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = message.code);
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.index !== void 0 && (obj.index = (message.index || long_1.default.ZERO).toString());
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        message.proofOps !== void 0 && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : void 0);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = Object.assign({}, baseResponseQuery);
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.log = (_b = object.log) !== null && _b !== void 0 ? _b : "";
        message.info = (_c = object.info) !== null && _c !== void 0 ? _c : "";
        message.index = object.index !== void 0 && object.index !== null ? long_1.default.fromValue(object.index) : long_1.default.ZERO;
        message.key = (_d = object.key) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.value = (_e = object.value) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.proofOps = object.proofOps !== void 0 && object.proofOps !== null ? proof_1.ProofOps.fromPartial(object.proofOps) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.codespace = (_f = object.codespace) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    var baseResponseBeginBlock = {};
    exports.ResponseBeginBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.events) {
          exports.Event.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseBeginBlock);
        message.events = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseResponseBeginBlock);
        message.events = ((_a = object.events) !== null && _a !== void 0 ? _a : []).map((e) => exports.Event.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseResponseBeginBlock);
        message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Event.fromPartial(e))) || [];
        return message;
      }
    };
    var baseResponseCheckTx = {
      code: 0,
      log: "",
      info: "",
      gasWanted: long_1.default.ZERO,
      gasUsed: long_1.default.ZERO,
      codespace: ""
    };
    exports.ResponseCheckTx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (!message.gasWanted.isZero()) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (!message.gasUsed.isZero()) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseCheckTx);
        message.events = [];
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseResponseCheckTx);
        message.code = object.code !== void 0 && object.code !== null ? Number(object.code) : 0;
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        message.log = object.log !== void 0 && object.log !== null ? String(object.log) : "";
        message.info = object.info !== void 0 && object.info !== null ? String(object.info) : "";
        message.gasWanted = object.gas_wanted !== void 0 && object.gas_wanted !== null ? long_1.default.fromString(object.gas_wanted) : long_1.default.ZERO;
        message.gasUsed = object.gas_used !== void 0 && object.gas_used !== null ? long_1.default.fromString(object.gas_used) : long_1.default.ZERO;
        message.events = ((_a = object.events) !== null && _a !== void 0 ? _a : []).map((e) => exports.Event.fromJSON(e));
        message.codespace = object.codespace !== void 0 && object.codespace !== null ? String(object.codespace) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = message.code);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || long_1.default.ZERO).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || long_1.default.ZERO).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = Object.assign({}, baseResponseCheckTx);
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.log = (_c = object.log) !== null && _c !== void 0 ? _c : "";
        message.info = (_d = object.info) !== null && _d !== void 0 ? _d : "";
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromValue(object.gasWanted) : long_1.default.ZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromValue(object.gasUsed) : long_1.default.ZERO;
        message.events = ((_e = object.events) === null || _e === void 0 ? void 0 : _e.map((e) => exports.Event.fromPartial(e))) || [];
        message.codespace = (_f = object.codespace) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    var baseResponseDeliverTx = {
      code: 0,
      log: "",
      info: "",
      gasWanted: long_1.default.ZERO,
      gasUsed: long_1.default.ZERO,
      codespace: ""
    };
    exports.ResponseDeliverTx = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (!message.gasWanted.isZero()) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (!message.gasUsed.isZero()) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
          exports.Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseDeliverTx);
        message.events = [];
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseResponseDeliverTx);
        message.code = object.code !== void 0 && object.code !== null ? Number(object.code) : 0;
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        message.log = object.log !== void 0 && object.log !== null ? String(object.log) : "";
        message.info = object.info !== void 0 && object.info !== null ? String(object.info) : "";
        message.gasWanted = object.gas_wanted !== void 0 && object.gas_wanted !== null ? long_1.default.fromString(object.gas_wanted) : long_1.default.ZERO;
        message.gasUsed = object.gas_used !== void 0 && object.gas_used !== null ? long_1.default.fromString(object.gas_used) : long_1.default.ZERO;
        message.events = ((_a = object.events) !== null && _a !== void 0 ? _a : []).map((e) => exports.Event.fromJSON(e));
        message.codespace = object.codespace !== void 0 && object.codespace !== null ? String(object.codespace) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = message.code);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || long_1.default.ZERO).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || long_1.default.ZERO).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = Object.assign({}, baseResponseDeliverTx);
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.log = (_c = object.log) !== null && _c !== void 0 ? _c : "";
        message.info = (_d = object.info) !== null && _d !== void 0 ? _d : "";
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromValue(object.gasWanted) : long_1.default.ZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromValue(object.gasUsed) : long_1.default.ZERO;
        message.events = ((_e = object.events) === null || _e === void 0 ? void 0 : _e.map((e) => exports.Event.fromPartial(e))) || [];
        message.codespace = (_f = object.codespace) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    var baseResponseEndBlock = {};
    exports.ResponseEndBlock = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validatorUpdates) {
          exports.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusParamUpdates !== void 0) {
          exports.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.events) {
          exports.Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseEndBlock);
        message.validatorUpdates = [];
        message.events = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorUpdates.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 2:
              message.consensusParamUpdates = exports.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a, _b;
        const message = Object.assign({}, baseResponseEndBlock);
        message.validatorUpdates = ((_a = object.validatorUpdates) !== null && _a !== void 0 ? _a : []).map((e) => exports.ValidatorUpdate.fromJSON(e));
        message.consensusParamUpdates = object.consensusParamUpdates !== void 0 && object.consensusParamUpdates !== null ? exports.ConsensusParams.fromJSON(object.consensusParamUpdates) : void 0;
        message.events = ((_b = object.events) !== null && _b !== void 0 ? _b : []).map((e) => exports.Event.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorUpdates) {
          obj.validatorUpdates = message.validatorUpdates.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validatorUpdates = [];
        }
        message.consensusParamUpdates !== void 0 && (obj.consensusParamUpdates = message.consensusParamUpdates ? exports.ConsensusParams.toJSON(message.consensusParamUpdates) : void 0);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseResponseEndBlock);
        message.validatorUpdates = ((_a = object.validatorUpdates) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ValidatorUpdate.fromPartial(e))) || [];
        message.consensusParamUpdates = object.consensusParamUpdates !== void 0 && object.consensusParamUpdates !== null ? exports.ConsensusParams.fromPartial(object.consensusParamUpdates) : void 0;
        message.events = ((_b = object.events) === null || _b === void 0 ? void 0 : _b.map((e) => exports.Event.fromPartial(e))) || [];
        return message;
      }
    };
    var baseResponseCommit = { retainHeight: long_1.default.ZERO };
    exports.ResponseCommit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (!message.retainHeight.isZero()) {
          writer.uint32(24).int64(message.retainHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseCommit);
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.retainHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponseCommit);
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        message.retainHeight = object.retainHeight !== void 0 && object.retainHeight !== null ? long_1.default.fromString(object.retainHeight) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.retainHeight !== void 0 && (obj.retainHeight = (message.retainHeight || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseResponseCommit);
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.retainHeight = object.retainHeight !== void 0 && object.retainHeight !== null ? long_1.default.fromValue(object.retainHeight) : long_1.default.ZERO;
        return message;
      }
    };
    var baseResponseListSnapshots = {};
    exports.ResponseListSnapshots = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.snapshots) {
          exports.Snapshot.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseListSnapshots);
        message.snapshots = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshots.push(exports.Snapshot.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseResponseListSnapshots);
        message.snapshots = ((_a = object.snapshots) !== null && _a !== void 0 ? _a : []).map((e) => exports.Snapshot.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.snapshots) {
          obj.snapshots = message.snapshots.map((e) => e ? exports.Snapshot.toJSON(e) : void 0);
        } else {
          obj.snapshots = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseResponseListSnapshots);
        message.snapshots = ((_a = object.snapshots) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Snapshot.fromPartial(e))) || [];
        return message;
      }
    };
    var baseResponseOfferSnapshot = { result: 0 };
    exports.ResponseOfferSnapshot = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseOfferSnapshot);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponseOfferSnapshot);
        message.result = object.result !== void 0 && object.result !== null ? responseOfferSnapshot_ResultFromJSON(object.result) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseResponseOfferSnapshot);
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        return message;
      }
    };
    var baseResponseLoadSnapshotChunk = {};
    exports.ResponseLoadSnapshotChunk = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chunk.length !== 0) {
          writer.uint32(10).bytes(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseLoadSnapshotChunk);
        message.chunk = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chunk = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseResponseLoadSnapshotChunk);
        message.chunk = object.chunk !== void 0 && object.chunk !== null ? bytesFromBase64(object.chunk) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.chunk !== void 0 && (obj.chunk = base64FromBytes(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseResponseLoadSnapshotChunk);
        message.chunk = (_a = object.chunk) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var baseResponseApplySnapshotChunk = { result: 0, refetchChunks: 0, rejectSenders: "" };
    exports.ResponseApplySnapshotChunk = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        writer.uint32(18).fork();
        for (const v of message.refetchChunks) {
          writer.uint32(v);
        }
        writer.ldelim();
        for (const v of message.rejectSenders) {
          writer.uint32(26).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResponseApplySnapshotChunk);
        message.refetchChunks = [];
        message.rejectSenders = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.refetchChunks.push(reader.uint32());
                }
              } else {
                message.refetchChunks.push(reader.uint32());
              }
              break;
            case 3:
              message.rejectSenders.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a, _b;
        const message = Object.assign({}, baseResponseApplySnapshotChunk);
        message.result = object.result !== void 0 && object.result !== null ? responseApplySnapshotChunk_ResultFromJSON(object.result) : 0;
        message.refetchChunks = ((_a = object.refetchChunks) !== null && _a !== void 0 ? _a : []).map((e) => Number(e));
        message.rejectSenders = ((_b = object.rejectSenders) !== null && _b !== void 0 ? _b : []).map((e) => String(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));
        if (message.refetchChunks) {
          obj.refetchChunks = message.refetchChunks.map((e) => e);
        } else {
          obj.refetchChunks = [];
        }
        if (message.rejectSenders) {
          obj.rejectSenders = message.rejectSenders.map((e) => e);
        } else {
          obj.rejectSenders = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseResponseApplySnapshotChunk);
        message.result = (_a = object.result) !== null && _a !== void 0 ? _a : 0;
        message.refetchChunks = ((_b = object.refetchChunks) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.rejectSenders = ((_c = object.rejectSenders) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
      }
    };
    var baseConsensusParams = {};
    exports.ConsensusParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.block !== void 0) {
          exports.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          params_1.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== void 0) {
          params_1.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== void 0) {
          params_1.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseConsensusParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = exports.BlockParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.evidence = params_1.EvidenceParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.validator = params_1.ValidatorParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.version = params_1.VersionParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseConsensusParams);
        message.block = object.block !== void 0 && object.block !== null ? exports.BlockParams.fromJSON(object.block) : void 0;
        message.evidence = object.evidence !== void 0 && object.evidence !== null ? params_1.EvidenceParams.fromJSON(object.evidence) : void 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? params_1.ValidatorParams.fromJSON(object.validator) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? params_1.VersionParams.fromJSON(object.version) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block ? exports.BlockParams.toJSON(message.block) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? params_1.EvidenceParams.toJSON(message.evidence) : void 0);
        message.validator !== void 0 && (obj.validator = message.validator ? params_1.ValidatorParams.toJSON(message.validator) : void 0);
        message.version !== void 0 && (obj.version = message.version ? params_1.VersionParams.toJSON(message.version) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseConsensusParams);
        message.block = object.block !== void 0 && object.block !== null ? exports.BlockParams.fromPartial(object.block) : void 0;
        message.evidence = object.evidence !== void 0 && object.evidence !== null ? params_1.EvidenceParams.fromPartial(object.evidence) : void 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? params_1.ValidatorParams.fromPartial(object.validator) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? params_1.VersionParams.fromPartial(object.version) : void 0;
        return message;
      }
    };
    var baseBlockParams = { maxBytes: long_1.default.ZERO, maxGas: long_1.default.ZERO };
    exports.BlockParams = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maxBytes.isZero()) {
          writer.uint32(8).int64(message.maxBytes);
        }
        if (!message.maxGas.isZero()) {
          writer.uint32(16).int64(message.maxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBlockParams);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxBytes = reader.int64();
              break;
            case 2:
              message.maxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseBlockParams);
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromString(object.maxBytes) : long_1.default.ZERO;
        message.maxGas = object.maxGas !== void 0 && object.maxGas !== null ? long_1.default.fromString(object.maxGas) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || long_1.default.ZERO).toString());
        message.maxGas !== void 0 && (obj.maxGas = (message.maxGas || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseBlockParams);
        message.maxBytes = object.maxBytes !== void 0 && object.maxBytes !== null ? long_1.default.fromValue(object.maxBytes) : long_1.default.ZERO;
        message.maxGas = object.maxGas !== void 0 && object.maxGas !== null ? long_1.default.fromValue(object.maxGas) : long_1.default.ZERO;
        return message;
      }
    };
    var baseLastCommitInfo = { round: 0 };
    exports.LastCommitInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
          exports.VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseLastCommitInfo);
        message.votes = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports.VoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseLastCommitInfo);
        message.round = object.round !== void 0 && object.round !== null ? Number(object.round) : 0;
        message.votes = ((_a = object.votes) !== null && _a !== void 0 ? _a : []).map((e) => exports.VoteInfo.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = message.round);
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports.VoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseLastCommitInfo);
        message.round = (_a = object.round) !== null && _a !== void 0 ? _a : 0;
        message.votes = ((_b = object.votes) === null || _b === void 0 ? void 0 : _b.map((e) => exports.VoteInfo.fromPartial(e))) || [];
        return message;
      }
    };
    var baseEvent = { type: "" };
    exports.Event = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports.EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseEvent);
        message.attributes = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports.EventAttribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseEvent);
        message.type = object.type !== void 0 && object.type !== null ? String(object.type) : "";
        message.attributes = ((_a = object.attributes) !== null && _a !== void 0 ? _a : []).map((e) => exports.EventAttribute.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports.EventAttribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseEvent);
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : "";
        message.attributes = ((_b = object.attributes) === null || _b === void 0 ? void 0 : _b.map((e) => exports.EventAttribute.fromPartial(e))) || [];
        return message;
      }
    };
    var baseEventAttribute = { index: false };
    exports.EventAttribute = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.index === true) {
          writer.uint32(24).bool(message.index);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseEventAttribute);
        message.key = new Uint8Array();
        message.value = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.index = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseEventAttribute);
        message.key = object.key !== void 0 && object.key !== null ? bytesFromBase64(object.key) : new Uint8Array();
        message.value = object.value !== void 0 && object.value !== null ? bytesFromBase64(object.value) : new Uint8Array();
        message.index = object.index !== void 0 && object.index !== null ? Boolean(object.index) : false;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = base64FromBytes(message.value !== void 0 ? message.value : new Uint8Array()));
        message.index !== void 0 && (obj.index = message.index);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseEventAttribute);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.index = (_c = object.index) !== null && _c !== void 0 ? _c : false;
        return message;
      }
    };
    var baseTxResult = { height: long_1.default.ZERO, index: 0 };
    exports.TxResult = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        if (message.index !== 0) {
          writer.uint32(16).uint32(message.index);
        }
        if (message.tx.length !== 0) {
          writer.uint32(26).bytes(message.tx);
        }
        if (message.result !== void 0) {
          exports.ResponseDeliverTx.encode(message.result, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTxResult);
        message.tx = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.index = reader.uint32();
              break;
            case 3:
              message.tx = reader.bytes();
              break;
            case 4:
              message.result = exports.ResponseDeliverTx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseTxResult);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.index = object.index !== void 0 && object.index !== null ? Number(object.index) : 0;
        message.tx = object.tx !== void 0 && object.tx !== null ? bytesFromBase64(object.tx) : new Uint8Array();
        message.result = object.result !== void 0 && object.result !== null ? exports.ResponseDeliverTx.fromJSON(object.result) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.index !== void 0 && (obj.index = message.index);
        message.tx !== void 0 && (obj.tx = base64FromBytes(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.result !== void 0 && (obj.result = message.result ? exports.ResponseDeliverTx.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseTxResult);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;
        message.tx = (_b = object.tx) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.result = object.result !== void 0 && object.result !== null ? exports.ResponseDeliverTx.fromPartial(object.result) : void 0;
        return message;
      }
    };
    var baseValidator = { power: long_1.default.ZERO };
    exports.Validator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (!message.power.isZero()) {
          writer.uint32(24).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidator);
        message.address = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 3:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseValidator);
        message.address = object.address !== void 0 && object.address !== null ? bytesFromBase64(object.address) : new Uint8Array();
        message.power = object.power !== void 0 && object.power !== null ? long_1.default.fromString(object.power) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = base64FromBytes(message.address !== void 0 ? message.address : new Uint8Array()));
        message.power !== void 0 && (obj.power = (message.power || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseValidator);
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.power = object.power !== void 0 && object.power !== null ? long_1.default.fromValue(object.power) : long_1.default.ZERO;
        return message;
      }
    };
    var baseValidatorUpdate = { power: long_1.default.ZERO };
    exports.ValidatorUpdate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (!message.power.isZero()) {
          writer.uint32(16).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseValidatorUpdate);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseValidatorUpdate);
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromJSON(object.pubKey) : void 0;
        message.power = object.power !== void 0 && object.power !== null ? long_1.default.fromString(object.power) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.power !== void 0 && (obj.power = (message.power || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseValidatorUpdate);
        message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? keys_1.PublicKey.fromPartial(object.pubKey) : void 0;
        message.power = object.power !== void 0 && object.power !== null ? long_1.default.fromValue(object.power) : long_1.default.ZERO;
        return message;
      }
    };
    var baseVoteInfo = { signedLastBlock: false };
    exports.VoteInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validator !== void 0) {
          exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.signedLastBlock === true) {
          writer.uint32(16).bool(message.signedLastBlock);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseVoteInfo);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports.Validator.decode(reader, reader.uint32());
              break;
            case 2:
              message.signedLastBlock = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseVoteInfo);
        message.validator = object.validator !== void 0 && object.validator !== null ? exports.Validator.fromJSON(object.validator) : void 0;
        message.signedLastBlock = object.signedLastBlock !== void 0 && object.signedLastBlock !== null ? Boolean(object.signedLastBlock) : false;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : void 0);
        message.signedLastBlock !== void 0 && (obj.signedLastBlock = message.signedLastBlock);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseVoteInfo);
        message.validator = object.validator !== void 0 && object.validator !== null ? exports.Validator.fromPartial(object.validator) : void 0;
        message.signedLastBlock = (_a = object.signedLastBlock) !== null && _a !== void 0 ? _a : false;
        return message;
      }
    };
    var baseEvidence = { type: 0, height: long_1.default.ZERO, totalVotingPower: long_1.default.ZERO };
    exports.Evidence = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.validator !== void 0) {
          exports.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();
        }
        if (!message.height.isZero()) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (!message.totalVotingPower.isZero()) {
          writer.uint32(40).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseEvidence);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.validator = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseEvidence);
        message.type = object.type !== void 0 && object.type !== null ? evidenceTypeFromJSON(object.type) : 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? exports.Validator.fromJSON(object.validator) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.time = object.time !== void 0 && object.time !== null ? fromJsonTimestamp(object.time) : void 0;
        message.totalVotingPower = object.totalVotingPower !== void 0 && object.totalVotingPower !== null ? long_1.default.fromString(object.totalVotingPower) : long_1.default.ZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = evidenceTypeToJSON(message.type));
        message.validator !== void 0 && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : void 0);
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.time !== void 0 && (obj.time = fromTimestamp(message.time).toISOString());
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || long_1.default.ZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseEvidence);
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.validator = object.validator !== void 0 && object.validator !== null ? exports.Validator.fromPartial(object.validator) : void 0;
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.time = object.time !== void 0 && object.time !== null ? timestamp_1.Timestamp.fromPartial(object.time) : void 0;
        message.totalVotingPower = object.totalVotingPower !== void 0 && object.totalVotingPower !== null ? long_1.default.fromValue(object.totalVotingPower) : long_1.default.ZERO;
        return message;
      }
    };
    var baseSnapshot = { height: long_1.default.UZERO, format: 0, chunks: 0 };
    exports.Snapshot = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunks !== 0) {
          writer.uint32(24).uint32(message.chunks);
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.metadata.length !== 0) {
          writer.uint32(42).bytes(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSnapshot);
        message.hash = new Uint8Array();
        message.metadata = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunks = reader.uint32();
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.metadata = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseSnapshot);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.UZERO;
        message.format = object.format !== void 0 && object.format !== null ? Number(object.format) : 0;
        message.chunks = object.chunks !== void 0 && object.chunks !== null ? Number(object.chunks) : 0;
        message.hash = object.hash !== void 0 && object.hash !== null ? bytesFromBase64(object.hash) : new Uint8Array();
        message.metadata = object.metadata !== void 0 && object.metadata !== null ? bytesFromBase64(object.metadata) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.UZERO).toString());
        message.format !== void 0 && (obj.format = message.format);
        message.chunks !== void 0 && (obj.chunks = message.chunks);
        message.hash !== void 0 && (obj.hash = base64FromBytes(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.metadata !== void 0 && (obj.metadata = base64FromBytes(message.metadata !== void 0 ? message.metadata : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseSnapshot);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.UZERO;
        message.format = (_a = object.format) !== null && _a !== void 0 ? _a : 0;
        message.chunks = (_b = object.chunks) !== null && _b !== void 0 ? _b : 0;
        message.hash = (_c = object.hash) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
      }
    };
    var ABCIApplicationClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Echo = this.Echo.bind(this);
        this.Flush = this.Flush.bind(this);
        this.Info = this.Info.bind(this);
        this.SetOption = this.SetOption.bind(this);
        this.DeliverTx = this.DeliverTx.bind(this);
        this.CheckTx = this.CheckTx.bind(this);
        this.Query = this.Query.bind(this);
        this.Commit = this.Commit.bind(this);
        this.InitChain = this.InitChain.bind(this);
        this.BeginBlock = this.BeginBlock.bind(this);
        this.EndBlock = this.EndBlock.bind(this);
        this.ListSnapshots = this.ListSnapshots.bind(this);
        this.OfferSnapshot = this.OfferSnapshot.bind(this);
        this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this);
        this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this);
      }
      Echo(request) {
        const data = exports.RequestEcho.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Echo", data);
        return promise.then((data2) => exports.ResponseEcho.decode(new minimal_1.default.Reader(data2)));
      }
      Flush(request) {
        const data = exports.RequestFlush.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Flush", data);
        return promise.then((data2) => exports.ResponseFlush.decode(new minimal_1.default.Reader(data2)));
      }
      Info(request) {
        const data = exports.RequestInfo.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Info", data);
        return promise.then((data2) => exports.ResponseInfo.decode(new minimal_1.default.Reader(data2)));
      }
      SetOption(request) {
        const data = exports.RequestSetOption.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "SetOption", data);
        return promise.then((data2) => exports.ResponseSetOption.decode(new minimal_1.default.Reader(data2)));
      }
      DeliverTx(request) {
        const data = exports.RequestDeliverTx.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "DeliverTx", data);
        return promise.then((data2) => exports.ResponseDeliverTx.decode(new minimal_1.default.Reader(data2)));
      }
      CheckTx(request) {
        const data = exports.RequestCheckTx.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "CheckTx", data);
        return promise.then((data2) => exports.ResponseCheckTx.decode(new minimal_1.default.Reader(data2)));
      }
      Query(request) {
        const data = exports.RequestQuery.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Query", data);
        return promise.then((data2) => exports.ResponseQuery.decode(new minimal_1.default.Reader(data2)));
      }
      Commit(request) {
        const data = exports.RequestCommit.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "Commit", data);
        return promise.then((data2) => exports.ResponseCommit.decode(new minimal_1.default.Reader(data2)));
      }
      InitChain(request) {
        const data = exports.RequestInitChain.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "InitChain", data);
        return promise.then((data2) => exports.ResponseInitChain.decode(new minimal_1.default.Reader(data2)));
      }
      BeginBlock(request) {
        const data = exports.RequestBeginBlock.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "BeginBlock", data);
        return promise.then((data2) => exports.ResponseBeginBlock.decode(new minimal_1.default.Reader(data2)));
      }
      EndBlock(request) {
        const data = exports.RequestEndBlock.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "EndBlock", data);
        return promise.then((data2) => exports.ResponseEndBlock.decode(new minimal_1.default.Reader(data2)));
      }
      ListSnapshots(request) {
        const data = exports.RequestListSnapshots.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ListSnapshots", data);
        return promise.then((data2) => exports.ResponseListSnapshots.decode(new minimal_1.default.Reader(data2)));
      }
      OfferSnapshot(request) {
        const data = exports.RequestOfferSnapshot.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "OfferSnapshot", data);
        return promise.then((data2) => exports.ResponseOfferSnapshot.decode(new minimal_1.default.Reader(data2)));
      }
      LoadSnapshotChunk(request) {
        const data = exports.RequestLoadSnapshotChunk.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "LoadSnapshotChunk", data);
        return promise.then((data2) => exports.ResponseLoadSnapshotChunk.decode(new minimal_1.default.Reader(data2)));
      }
      ApplySnapshotChunk(request) {
        const data = exports.RequestApplySnapshotChunk.encode(request).finish();
        const promise = this.rpc.request("tendermint.abci.ABCIApplication", "ApplySnapshotChunk", data);
        return promise.then((data2) => exports.ResponseApplySnapshotChunk.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.ABCIApplicationClientImpl = ABCIApplicationClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js
var require_abci = __commonJS({
  "node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchTxsResult = exports.TxMsgData = exports.MsgData = exports.SimulationResponse = exports.Result = exports.GasInfo = exports.Attribute = exports.StringEvent = exports.ABCIMessageLog = exports.TxResponse = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    var types_1 = require_types3();
    exports.protobufPackage = "cosmos.base.abci.v1beta1";
    var baseTxResponse = {
      height: long_1.default.ZERO,
      txhash: "",
      codespace: "",
      code: 0,
      data: "",
      rawLog: "",
      info: "",
      gasWanted: long_1.default.ZERO,
      gasUsed: long_1.default.ZERO,
      timestamp: ""
    };
    exports.TxResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.height.isZero()) {
          writer.uint32(8).int64(message.height);
        }
        if (message.txhash !== "") {
          writer.uint32(18).string(message.txhash);
        }
        if (message.codespace !== "") {
          writer.uint32(26).string(message.codespace);
        }
        if (message.code !== 0) {
          writer.uint32(32).uint32(message.code);
        }
        if (message.data !== "") {
          writer.uint32(42).string(message.data);
        }
        if (message.rawLog !== "") {
          writer.uint32(50).string(message.rawLog);
        }
        for (const v of message.logs) {
          exports.ABCIMessageLog.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.info !== "") {
          writer.uint32(66).string(message.info);
        }
        if (!message.gasWanted.isZero()) {
          writer.uint32(72).int64(message.gasWanted);
        }
        if (!message.gasUsed.isZero()) {
          writer.uint32(80).int64(message.gasUsed);
        }
        if (message.tx !== void 0) {
          any_1.Any.encode(message.tx, writer.uint32(90).fork()).ldelim();
        }
        if (message.timestamp !== "") {
          writer.uint32(98).string(message.timestamp);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(106).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTxResponse);
        message.logs = [];
        message.events = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.txhash = reader.string();
              break;
            case 3:
              message.codespace = reader.string();
              break;
            case 4:
              message.code = reader.uint32();
              break;
            case 5:
              message.data = reader.string();
              break;
            case 6:
              message.rawLog = reader.string();
              break;
            case 7:
              message.logs.push(exports.ABCIMessageLog.decode(reader, reader.uint32()));
              break;
            case 8:
              message.info = reader.string();
              break;
            case 9:
              message.gasWanted = reader.int64();
              break;
            case 10:
              message.gasUsed = reader.int64();
              break;
            case 11:
              message.tx = any_1.Any.decode(reader, reader.uint32());
              break;
            case 12:
              message.timestamp = reader.string();
              break;
            case 13:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a, _b;
        const message = Object.assign({}, baseTxResponse);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromString(object.height) : long_1.default.ZERO;
        message.txhash = object.txhash !== void 0 && object.txhash !== null ? String(object.txhash) : "";
        message.codespace = object.codespace !== void 0 && object.codespace !== null ? String(object.codespace) : "";
        message.code = object.code !== void 0 && object.code !== null ? Number(object.code) : 0;
        message.data = object.data !== void 0 && object.data !== null ? String(object.data) : "";
        message.rawLog = object.rawLog !== void 0 && object.rawLog !== null ? String(object.rawLog) : "";
        message.logs = ((_a = object.logs) !== null && _a !== void 0 ? _a : []).map((e) => exports.ABCIMessageLog.fromJSON(e));
        message.info = object.info !== void 0 && object.info !== null ? String(object.info) : "";
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromString(object.gasWanted) : long_1.default.ZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromString(object.gasUsed) : long_1.default.ZERO;
        message.tx = object.tx !== void 0 && object.tx !== null ? any_1.Any.fromJSON(object.tx) : void 0;
        message.timestamp = object.timestamp !== void 0 && object.timestamp !== null ? String(object.timestamp) : "";
        message.events = ((_b = object.events) !== null && _b !== void 0 ? _b : []).map((e) => types_1.Event.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || long_1.default.ZERO).toString());
        message.txhash !== void 0 && (obj.txhash = message.txhash);
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        message.code !== void 0 && (obj.code = message.code);
        message.data !== void 0 && (obj.data = message.data);
        message.rawLog !== void 0 && (obj.rawLog = message.rawLog);
        if (message.logs) {
          obj.logs = message.logs.map((e) => e ? exports.ABCIMessageLog.toJSON(e) : void 0);
        } else {
          obj.logs = [];
        }
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || long_1.default.ZERO).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || long_1.default.ZERO).toString());
        message.tx !== void 0 && (obj.tx = message.tx ? any_1.Any.toJSON(message.tx) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = Object.assign({}, baseTxResponse);
        message.height = object.height !== void 0 && object.height !== null ? long_1.default.fromValue(object.height) : long_1.default.ZERO;
        message.txhash = (_a = object.txhash) !== null && _a !== void 0 ? _a : "";
        message.codespace = (_b = object.codespace) !== null && _b !== void 0 ? _b : "";
        message.code = (_c = object.code) !== null && _c !== void 0 ? _c : 0;
        message.data = (_d = object.data) !== null && _d !== void 0 ? _d : "";
        message.rawLog = (_e = object.rawLog) !== null && _e !== void 0 ? _e : "";
        message.logs = ((_f = object.logs) === null || _f === void 0 ? void 0 : _f.map((e) => exports.ABCIMessageLog.fromPartial(e))) || [];
        message.info = (_g = object.info) !== null && _g !== void 0 ? _g : "";
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromValue(object.gasWanted) : long_1.default.ZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromValue(object.gasUsed) : long_1.default.ZERO;
        message.tx = object.tx !== void 0 && object.tx !== null ? any_1.Any.fromPartial(object.tx) : void 0;
        message.timestamp = (_h = object.timestamp) !== null && _h !== void 0 ? _h : "";
        message.events = ((_j = object.events) === null || _j === void 0 ? void 0 : _j.map((e) => types_1.Event.fromPartial(e))) || [];
        return message;
      }
    };
    var baseABCIMessageLog = { msgIndex: 0, log: "" };
    exports.ABCIMessageLog = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.msgIndex !== 0) {
          writer.uint32(8).uint32(message.msgIndex);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          exports.StringEvent.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseABCIMessageLog);
        message.events = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgIndex = reader.uint32();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(exports.StringEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseABCIMessageLog);
        message.msgIndex = object.msgIndex !== void 0 && object.msgIndex !== null ? Number(object.msgIndex) : 0;
        message.log = object.log !== void 0 && object.log !== null ? String(object.log) : "";
        message.events = ((_a = object.events) !== null && _a !== void 0 ? _a : []).map((e) => exports.StringEvent.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.msgIndex !== void 0 && (obj.msgIndex = message.msgIndex);
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.StringEvent.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseABCIMessageLog);
        message.msgIndex = (_a = object.msgIndex) !== null && _a !== void 0 ? _a : 0;
        message.log = (_b = object.log) !== null && _b !== void 0 ? _b : "";
        message.events = ((_c = object.events) === null || _c === void 0 ? void 0 : _c.map((e) => exports.StringEvent.fromPartial(e))) || [];
        return message;
      }
    };
    var baseStringEvent = { type: "" };
    exports.StringEvent = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
          exports.Attribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseStringEvent);
        message.attributes = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports.Attribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseStringEvent);
        message.type = object.type !== void 0 && object.type !== null ? String(object.type) : "";
        message.attributes = ((_a = object.attributes) !== null && _a !== void 0 ? _a : []).map((e) => exports.Attribute.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports.Attribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseStringEvent);
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : "";
        message.attributes = ((_b = object.attributes) === null || _b === void 0 ? void 0 : _b.map((e) => exports.Attribute.fromPartial(e))) || [];
        return message;
      }
    };
    var baseAttribute = { key: "", value: "" };
    exports.Attribute = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAttribute);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseAttribute);
        message.key = object.key !== void 0 && object.key !== null ? String(object.key) : "";
        message.value = object.value !== void 0 && object.value !== null ? String(object.value) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseAttribute);
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseGasInfo = { gasWanted: long_1.default.UZERO, gasUsed: long_1.default.UZERO };
    exports.GasInfo = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.gasWanted.isZero()) {
          writer.uint32(8).uint64(message.gasWanted);
        }
        if (!message.gasUsed.isZero()) {
          writer.uint32(16).uint64(message.gasUsed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGasInfo);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasWanted = reader.uint64();
              break;
            case 2:
              message.gasUsed = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseGasInfo);
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromString(object.gasWanted) : long_1.default.UZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromString(object.gasUsed) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || long_1.default.UZERO).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseGasInfo);
        message.gasWanted = object.gasWanted !== void 0 && object.gasWanted !== null ? long_1.default.fromValue(object.gasWanted) : long_1.default.UZERO;
        message.gasUsed = object.gasUsed !== void 0 && object.gasUsed !== null ? long_1.default.fromValue(object.gasUsed) : long_1.default.UZERO;
        return message;
      }
    };
    var baseResult = { log: "" };
    exports.Result = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v of message.events) {
          types_1.Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseResult);
        message.events = [];
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseResult);
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        message.log = object.log !== void 0 && object.log !== null ? String(object.log) : "";
        message.events = ((_a = object.events) !== null && _a !== void 0 ? _a : []).map((e) => types_1.Event.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseResult);
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.log = (_b = object.log) !== null && _b !== void 0 ? _b : "";
        message.events = ((_c = object.events) === null || _c === void 0 ? void 0 : _c.map((e) => types_1.Event.fromPartial(e))) || [];
        return message;
      }
    };
    var baseSimulationResponse = {};
    exports.SimulationResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.gasInfo !== void 0) {
          exports.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          exports.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSimulationResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = exports.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = exports.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseSimulationResponse);
        message.gasInfo = object.gasInfo !== void 0 && object.gasInfo !== null ? exports.GasInfo.fromJSON(object.gasInfo) : void 0;
        message.result = object.result !== void 0 && object.result !== null ? exports.Result.fromJSON(object.result) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? exports.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? exports.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseSimulationResponse);
        message.gasInfo = object.gasInfo !== void 0 && object.gasInfo !== null ? exports.GasInfo.fromPartial(object.gasInfo) : void 0;
        message.result = object.result !== void 0 && object.result !== null ? exports.Result.fromPartial(object.result) : void 0;
        return message;
      }
    };
    var baseMsgData = { msgType: "" };
    exports.MsgData = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.msgType !== "") {
          writer.uint32(10).string(message.msgType);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgData);
        message.data = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgType = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgData);
        message.msgType = object.msgType !== void 0 && object.msgType !== null ? String(object.msgType) : "";
        message.data = object.data !== void 0 && object.data !== null ? bytesFromBase64(object.data) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.msgType !== void 0 && (obj.msgType = message.msgType);
        message.data !== void 0 && (obj.data = base64FromBytes(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgData);
        message.msgType = (_a = object.msgType) !== null && _a !== void 0 ? _a : "";
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
      }
    };
    var baseTxMsgData = {};
    exports.TxMsgData = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.data) {
          exports.MsgData.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTxMsgData);
        message.data = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data.push(exports.MsgData.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseTxMsgData);
        message.data = ((_a = object.data) !== null && _a !== void 0 ? _a : []).map((e) => exports.MsgData.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.data) {
          obj.data = message.data.map((e) => e ? exports.MsgData.toJSON(e) : void 0);
        } else {
          obj.data = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseTxMsgData);
        message.data = ((_a = object.data) === null || _a === void 0 ? void 0 : _a.map((e) => exports.MsgData.fromPartial(e))) || [];
        return message;
      }
    };
    var baseSearchTxsResult = {
      totalCount: long_1.default.UZERO,
      count: long_1.default.UZERO,
      pageNumber: long_1.default.UZERO,
      pageTotal: long_1.default.UZERO,
      limit: long_1.default.UZERO
    };
    exports.SearchTxsResult = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.totalCount.isZero()) {
          writer.uint32(8).uint64(message.totalCount);
        }
        if (!message.count.isZero()) {
          writer.uint32(16).uint64(message.count);
        }
        if (!message.pageNumber.isZero()) {
          writer.uint32(24).uint64(message.pageNumber);
        }
        if (!message.pageTotal.isZero()) {
          writer.uint32(32).uint64(message.pageTotal);
        }
        if (!message.limit.isZero()) {
          writer.uint32(40).uint64(message.limit);
        }
        for (const v of message.txs) {
          exports.TxResponse.encode(v, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSearchTxsResult);
        message.txs = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.uint64();
              break;
            case 2:
              message.count = reader.uint64();
              break;
            case 3:
              message.pageNumber = reader.uint64();
              break;
            case 4:
              message.pageTotal = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.txs.push(exports.TxResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseSearchTxsResult);
        message.totalCount = object.totalCount !== void 0 && object.totalCount !== null ? long_1.default.fromString(object.totalCount) : long_1.default.UZERO;
        message.count = object.count !== void 0 && object.count !== null ? long_1.default.fromString(object.count) : long_1.default.UZERO;
        message.pageNumber = object.pageNumber !== void 0 && object.pageNumber !== null ? long_1.default.fromString(object.pageNumber) : long_1.default.UZERO;
        message.pageTotal = object.pageTotal !== void 0 && object.pageTotal !== null ? long_1.default.fromString(object.pageTotal) : long_1.default.UZERO;
        message.limit = object.limit !== void 0 && object.limit !== null ? long_1.default.fromString(object.limit) : long_1.default.UZERO;
        message.txs = ((_a = object.txs) !== null && _a !== void 0 ? _a : []).map((e) => exports.TxResponse.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || long_1.default.UZERO).toString());
        message.count !== void 0 && (obj.count = (message.count || long_1.default.UZERO).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || long_1.default.UZERO).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || long_1.default.UZERO).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || long_1.default.UZERO).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? exports.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseSearchTxsResult);
        message.totalCount = object.totalCount !== void 0 && object.totalCount !== null ? long_1.default.fromValue(object.totalCount) : long_1.default.UZERO;
        message.count = object.count !== void 0 && object.count !== null ? long_1.default.fromValue(object.count) : long_1.default.UZERO;
        message.pageNumber = object.pageNumber !== void 0 && object.pageNumber !== null ? long_1.default.fromValue(object.pageNumber) : long_1.default.UZERO;
        message.pageTotal = object.pageTotal !== void 0 && object.pageTotal !== null ? long_1.default.fromValue(object.pageTotal) : long_1.default.UZERO;
        message.limit = object.limit !== void 0 && object.limit !== null ? long_1.default.fromValue(object.limit) : long_1.default.UZERO;
        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map((e) => exports.TxResponse.fromPartial(e))) || [];
        return message;
      }
    };
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js
var require_service = __commonJS({
  "node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceClientImpl = exports.GetTxResponse = exports.GetTxRequest = exports.SimulateResponse = exports.SimulateRequest = exports.BroadcastTxResponse = exports.BroadcastTxRequest = exports.GetTxsEventResponse = exports.GetTxsEventRequest = exports.broadcastModeToJSON = exports.broadcastModeFromJSON = exports.BroadcastMode = exports.orderByToJSON = exports.orderByFromJSON = exports.OrderBy = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var pagination_1 = require_pagination();
    var abci_1 = require_abci();
    var tx_1 = require_tx();
    exports.protobufPackage = "cosmos.tx.v1beta1";
    var OrderBy;
    (function(OrderBy2) {
      OrderBy2[OrderBy2["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
      OrderBy2[OrderBy2["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
      OrderBy2[OrderBy2["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
      OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OrderBy = exports.OrderBy || (exports.OrderBy = {}));
    function orderByFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_BY_UNSPECIFIED":
          return OrderBy.ORDER_BY_UNSPECIFIED;
        case 1:
        case "ORDER_BY_ASC":
          return OrderBy.ORDER_BY_ASC;
        case 2:
        case "ORDER_BY_DESC":
          return OrderBy.ORDER_BY_DESC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return OrderBy.UNRECOGNIZED;
      }
    }
    exports.orderByFromJSON = orderByFromJSON;
    function orderByToJSON(object) {
      switch (object) {
        case OrderBy.ORDER_BY_UNSPECIFIED:
          return "ORDER_BY_UNSPECIFIED";
        case OrderBy.ORDER_BY_ASC:
          return "ORDER_BY_ASC";
        case OrderBy.ORDER_BY_DESC:
          return "ORDER_BY_DESC";
        default:
          return "UNKNOWN";
      }
    }
    exports.orderByToJSON = orderByToJSON;
    var BroadcastMode;
    (function(BroadcastMode2) {
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
      BroadcastMode2[BroadcastMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BroadcastMode = exports.BroadcastMode || (exports.BroadcastMode = {}));
    function broadcastModeFromJSON(object) {
      switch (object) {
        case 0:
        case "BROADCAST_MODE_UNSPECIFIED":
          return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
        case 1:
        case "BROADCAST_MODE_BLOCK":
          return BroadcastMode.BROADCAST_MODE_BLOCK;
        case 2:
        case "BROADCAST_MODE_SYNC":
          return BroadcastMode.BROADCAST_MODE_SYNC;
        case 3:
        case "BROADCAST_MODE_ASYNC":
          return BroadcastMode.BROADCAST_MODE_ASYNC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BroadcastMode.UNRECOGNIZED;
      }
    }
    exports.broadcastModeFromJSON = broadcastModeFromJSON;
    function broadcastModeToJSON(object) {
      switch (object) {
        case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
          return "BROADCAST_MODE_UNSPECIFIED";
        case BroadcastMode.BROADCAST_MODE_BLOCK:
          return "BROADCAST_MODE_BLOCK";
        case BroadcastMode.BROADCAST_MODE_SYNC:
          return "BROADCAST_MODE_SYNC";
        case BroadcastMode.BROADCAST_MODE_ASYNC:
          return "BROADCAST_MODE_ASYNC";
        default:
          return "UNKNOWN";
      }
    }
    exports.broadcastModeToJSON = broadcastModeToJSON;
    var baseGetTxsEventRequest = { events: "", orderBy: 0 };
    exports.GetTxsEventRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.events) {
          writer.uint32(10).string(v);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.orderBy !== 0) {
          writer.uint32(24).int32(message.orderBy);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGetTxsEventRequest);
        message.events = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.orderBy = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseGetTxsEventRequest);
        message.events = ((_a = object.events) !== null && _a !== void 0 ? _a : []).map((e) => String(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromJSON(object.pagination) : void 0;
        message.orderBy = object.orderBy !== void 0 && object.orderBy !== null ? orderByFromJSON(object.orderBy) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e);
        } else {
          obj.events = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.orderBy !== void 0 && (obj.orderBy = orderByToJSON(message.orderBy));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseGetTxsEventRequest);
        message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageRequest.fromPartial(object.pagination) : void 0;
        message.orderBy = (_b = object.orderBy) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var baseGetTxsEventResponse = {};
    exports.GetTxsEventResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.txs) {
          tx_1.Tx.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.txResponses) {
          abci_1.TxResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGetTxsEventResponse);
        message.txs = [];
        message.txResponses = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResponses.push(abci_1.TxResponse.decode(reader, reader.uint32()));
              break;
            case 3:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a, _b;
        const message = Object.assign({}, baseGetTxsEventResponse);
        message.txs = ((_a = object.txs) !== null && _a !== void 0 ? _a : []).map((e) => tx_1.Tx.fromJSON(e));
        message.txResponses = ((_b = object.txResponses) !== null && _b !== void 0 ? _b : []).map((e) => abci_1.TxResponse.fromJSON(e));
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromJSON(object.pagination) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        if (message.txResponses) {
          obj.txResponses = message.txResponses.map((e) => e ? abci_1.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseGetTxsEventResponse);
        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map((e) => tx_1.Tx.fromPartial(e))) || [];
        message.txResponses = ((_b = object.txResponses) === null || _b === void 0 ? void 0 : _b.map((e) => abci_1.TxResponse.fromPartial(e))) || [];
        message.pagination = object.pagination !== void 0 && object.pagination !== null ? pagination_1.PageResponse.fromPartial(object.pagination) : void 0;
        return message;
      }
    };
    var baseBroadcastTxRequest = { mode: 0 };
    exports.BroadcastTxRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        if (message.mode !== 0) {
          writer.uint32(16).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBroadcastTxRequest);
        message.txBytes = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            case 2:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseBroadcastTxRequest);
        message.txBytes = object.txBytes !== void 0 && object.txBytes !== null ? bytesFromBase64(object.txBytes) : new Uint8Array();
        message.mode = object.mode !== void 0 && object.mode !== null ? broadcastModeFromJSON(object.mode) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = base64FromBytes(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        message.mode !== void 0 && (obj.mode = broadcastModeToJSON(message.mode));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseBroadcastTxRequest);
        message.txBytes = (_a = object.txBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.mode = (_b = object.mode) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var baseBroadcastTxResponse = {};
    exports.BroadcastTxResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBroadcastTxResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseBroadcastTxResponse);
        message.txResponse = object.txResponse !== void 0 && object.txResponse !== null ? abci_1.TxResponse.fromJSON(object.txResponse) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseBroadcastTxResponse);
        message.txResponse = object.txResponse !== void 0 && object.txResponse !== null ? abci_1.TxResponse.fromPartial(object.txResponse) : void 0;
        return message;
      }
    };
    var baseSimulateRequest = {};
    exports.SimulateRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txBytes.length !== 0) {
          writer.uint32(18).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSimulateRequest);
        message.txBytes = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseSimulateRequest);
        message.tx = object.tx !== void 0 && object.tx !== null ? tx_1.Tx.fromJSON(object.tx) : void 0;
        message.txBytes = object.txBytes !== void 0 && object.txBytes !== null ? bytesFromBase64(object.txBytes) : new Uint8Array();
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txBytes !== void 0 && (obj.txBytes = base64FromBytes(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseSimulateRequest);
        message.tx = object.tx !== void 0 && object.tx !== null ? tx_1.Tx.fromPartial(object.tx) : void 0;
        message.txBytes = (_a = object.txBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
      }
    };
    var baseSimulateResponse = {};
    exports.SimulateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.gasInfo !== void 0) {
          abci_1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          abci_1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSimulateResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = abci_1.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = abci_1.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseSimulateResponse);
        message.gasInfo = object.gasInfo !== void 0 && object.gasInfo !== null ? abci_1.GasInfo.fromJSON(object.gasInfo) : void 0;
        message.result = object.result !== void 0 && object.result !== null ? abci_1.Result.fromJSON(object.result) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? abci_1.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? abci_1.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseSimulateResponse);
        message.gasInfo = object.gasInfo !== void 0 && object.gasInfo !== null ? abci_1.GasInfo.fromPartial(object.gasInfo) : void 0;
        message.result = object.result !== void 0 && object.result !== null ? abci_1.Result.fromPartial(object.result) : void 0;
        return message;
      }
    };
    var baseGetTxRequest = { hash: "" };
    exports.GetTxRequest = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGetTxRequest);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseGetTxRequest);
        message.hash = object.hash !== void 0 && object.hash !== null ? String(object.hash) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseGetTxRequest);
        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseGetTxResponse = {};
    exports.GetTxResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGetTxResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseGetTxResponse);
        message.tx = object.tx !== void 0 && object.tx !== null ? tx_1.Tx.fromJSON(object.tx) : void 0;
        message.txResponse = object.txResponse !== void 0 && object.txResponse !== null ? abci_1.TxResponse.fromJSON(object.txResponse) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseGetTxResponse);
        message.tx = object.tx !== void 0 && object.tx !== null ? tx_1.Tx.fromPartial(object.tx) : void 0;
        message.txResponse = object.txResponse !== void 0 && object.txResponse !== null ? abci_1.TxResponse.fromPartial(object.txResponse) : void 0;
        return message;
      }
    };
    var ServiceClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Simulate = this.Simulate.bind(this);
        this.GetTx = this.GetTx.bind(this);
        this.BroadcastTx = this.BroadcastTx.bind(this);
        this.GetTxsEvent = this.GetTxsEvent.bind(this);
      }
      Simulate(request) {
        const data = exports.SimulateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", data);
        return promise.then((data2) => exports.SimulateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      GetTx(request) {
        const data = exports.GetTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", data);
        return promise.then((data2) => exports.GetTxResponse.decode(new minimal_1.default.Reader(data2)));
      }
      BroadcastTx(request) {
        const data = exports.BroadcastTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", data);
        return promise.then((data2) => exports.BroadcastTxResponse.decode(new minimal_1.default.Reader(data2)));
      }
      GetTxsEvent(request) {
        const data = exports.GetTxsEventRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", data);
        return promise.then((data2) => exports.GetTxsEventResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.ServiceClientImpl = ServiceClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/queries/tx.js
var require_tx3 = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/tx.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupTxExtension = void 0;
    var proto_signing_1 = require_build6();
    var signing_1 = require_signing();
    var service_1 = require_service();
    var tx_1 = require_tx();
    var long_1 = __importDefault(require_long());
    var utils_1 = require_utils2();
    function setupTxExtension(base) {
      const rpc = (0, utils_1.createProtobufRpcClient)(base);
      const queryService = new service_1.ServiceClientImpl(rpc);
      return {
        tx: {
          getTx: async (txId) => {
            const request = {
              hash: txId
            };
            const response = await queryService.GetTx(request);
            return response;
          },
          simulate: async (messages, memo, signer, sequence) => {
            const request = service_1.SimulateRequest.fromPartial({
              tx: tx_1.Tx.fromPartial({
                authInfo: tx_1.AuthInfo.fromPartial({
                  fee: tx_1.Fee.fromPartial({}),
                  signerInfos: [
                    {
                      publicKey: (0, proto_signing_1.encodePubkey)(signer),
                      sequence: long_1.default.fromNumber(sequence, true),
                      modeInfo: { single: { mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED } }
                    }
                  ]
                }),
                body: tx_1.TxBody.fromPartial({
                  messages: Array.from(messages),
                  memo
                }),
                signatures: [new Uint8Array()]
              }),
              txBytes: void 0
            });
            const response = await queryService.Simulate(request);
            return response;
          }
        }
      };
    }
    exports.setupTxExtension = setupTxExtension;
  }
});

// node_modules/@cosmjs/stargate/build/queries/index.js
var require_queries = __commonJS({
  "node_modules/@cosmjs/stargate/build/queries/index.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.setupTxExtension = exports.setupStakingExtension = exports.setupMintExtension = exports.setupIbcExtension = exports.setupGovExtension = exports.setupDistributionExtension = exports.setupBankExtension = exports.setupAuthExtension = exports.QueryClient = void 0;
    var queryclient_1 = require_queryclient();
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var auth_1 = require_auth2();
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return auth_1.setupAuthExtension;
    } });
    var bank_1 = require_bank2();
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return bank_1.setupBankExtension;
    } });
    var distribution_1 = require_distribution2();
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return distribution_1.setupDistributionExtension;
    } });
    var gov_1 = require_gov2();
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return gov_1.setupGovExtension;
    } });
    var ibc_1 = require_ibc();
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return ibc_1.setupIbcExtension;
    } });
    var mint_1 = require_mint2();
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return mint_1.setupMintExtension;
    } });
    var staking_1 = require_staking2();
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return staking_1.setupStakingExtension;
    } });
    var tx_1 = require_tx3();
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return tx_1.setupTxExtension;
    } });
    var utils_1 = require_utils2();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return utils_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return utils_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return utils_1.decodeCosmosSdkDecFromProto;
    } });
  }
});

// node_modules/@cosmjs/stargate/build/search.js
var require_search = __commonJS({
  "node_modules/@cosmjs/stargate/build/search.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSearchByTagsQuery = exports.isSearchBySentFromOrToQuery = exports.isSearchByHeightQuery = void 0;
    function isSearchByHeightQuery(query) {
      return query.height !== void 0;
    }
    exports.isSearchByHeightQuery = isSearchByHeightQuery;
    function isSearchBySentFromOrToQuery(query) {
      return query.sentFromOrTo !== void 0;
    }
    exports.isSearchBySentFromOrToQuery = isSearchBySentFromOrToQuery;
    function isSearchByTagsQuery(query) {
      return query.tags !== void 0;
    }
    exports.isSearchByTagsQuery = isSearchByTagsQuery;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/addresses.js
var require_addresses = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/addresses.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pubkeyToAddress = exports.pubkeyToRawAddress = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    function rawSecp256k1PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress;
    function pubkeyToRawAddress(type, data) {
      switch (type) {
        case "ed25519":
          return rawEd25519PubkeyToRawAddress(data);
        case "secp256k1":
          return rawSecp256k1PubkeyToRawAddress(data);
        default:
          throw new Error(`Pubkey type ${type} not supported`);
      }
    }
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    function pubkeyToAddress(type, data) {
      return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data)).toUpperCase();
    }
    exports.pubkeyToAddress = pubkeyToAddress;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/dates.js
var require_dates = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/dates.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateTime = exports.toSeconds = exports.fromSeconds = exports.toRfc3339WithNanoseconds = exports.fromRfc3339WithNanoseconds = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build3();
    function fromRfc3339WithNanoseconds(dateTimeString) {
      const out = (0, encoding_1.fromRfc3339)(dateTimeString);
      const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
      const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
      out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
      return out;
    }
    exports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
    function toRfc3339WithNanoseconds(dateTime) {
      var _a, _b;
      const millisecondIso = dateTime.toISOString();
      const nanoseconds = (_b = (_a = dateTime.nanoseconds) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : "";
      return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
    }
    exports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
    function fromSeconds(seconds, nanos = 0) {
      const checkedNanos = new math_1.Uint32(nanos).toNumber();
      if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
      }
      const out = new Date(seconds * 1e3 + Math.floor(checkedNanos / 1e6));
      out.nanoseconds = checkedNanos % 1e6;
      return out;
    }
    exports.fromSeconds = fromSeconds;
    function toSeconds(date) {
      var _a;
      return {
        seconds: Math.floor(date.getTime() / 1e3),
        nanos: date.getTime() % 1e3 * 1e6 + ((_a = date.nanoseconds) !== null && _a !== void 0 ? _a : 0)
      };
    }
    exports.toSeconds = toSeconds;
    var DateTime = class {
      static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
      }
      static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
      }
    };
    exports.DateTime = DateTime;
  }
});

// node_modules/@cosmjs/json-rpc/build/id.js
var require_id = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/id.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeJsonRpcId = void 0;
    var counter = 1e4;
    function makeJsonRpcId() {
      return counter += 1;
    }
    exports.makeJsonRpcId = makeJsonRpcId;
  }
});

// node_modules/@cosmjs/json-rpc/build/types.js
var require_types4 = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/types.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = void 0;
    function isJsonRpcErrorResponse(response) {
      return typeof response.error === "object";
    }
    exports.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
    function isJsonRpcSuccessResponse(response) {
      return !isJsonRpcErrorResponse(response);
    }
    exports.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
    exports.jsonRpcCode = {
      parseError: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internalError: -32603,
      serverError: {
        default: -32e3
      }
    };
  }
});

// node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js
var require_jsonrpcclient = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcClient = void 0;
    var stream_1 = require_build8();
    var types_1 = require_types4();
    var JsonRpcClient = class {
      constructor(connection) {
        this.connection = connection;
      }
      async run(request) {
        const filteredStream = this.connection.responseStream.filter((r) => r.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
          const error = response.error;
          throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
      }
    };
    exports.JsonRpcClient = JsonRpcClient;
  }
});

// node_modules/@cosmjs/json-rpc/build/compatibility.js
var require_compatibility = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/compatibility.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonCompatibleDictionary = exports.isJsonCompatibleArray = exports.isJsonCompatibleValue = void 0;
    function isJsonCompatibleValue(value) {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || isJsonCompatibleArray(value) || isJsonCompatibleDictionary(value)) {
        return true;
      } else {
        return false;
      }
    }
    exports.isJsonCompatibleValue = isJsonCompatibleValue;
    function isJsonCompatibleArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (const item of value) {
        if (!isJsonCompatibleValue(item)) {
          return false;
        }
      }
      return true;
    }
    exports.isJsonCompatibleArray = isJsonCompatibleArray;
    function isJsonCompatibleDictionary(data) {
      if (typeof data !== "object" || data === null) {
        return false;
      }
      if (Object.prototype.toString.call(data) !== "[object Object]") {
        return false;
      }
      const values = Object.getOwnPropertyNames(data).map((key) => data[key]);
      return values.every(isJsonCompatibleValue);
    }
    exports.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
  }
});

// node_modules/@cosmjs/json-rpc/build/parse.js
var require_parse = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/parse.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJsonRpcResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcErrorResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = void 0;
    var compatibility_1 = require_compatibility();
    function parseJsonRpcId(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        return null;
      }
      return id;
    }
    exports.parseJsonRpcId = parseJsonRpcId;
    function parseJsonRpcRequest(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${data.jsonrpc}`);
      }
      const id = parseJsonRpcId(data);
      if (id === null) {
        throw new Error("Invalid id field");
      }
      const method = data.method;
      if (typeof method !== "string") {
        throw new Error("Invalid method field");
      }
      if (!(0, compatibility_1.isJsonCompatibleArray)(data.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data.params)) {
        throw new Error("Invalid params field");
      }
      return {
        jsonrpc: "2.0",
        id,
        method,
        params: data.params
      };
    }
    exports.parseJsonRpcRequest = parseJsonRpcRequest;
    function parseError(error) {
      if (typeof error.code !== "number") {
        throw new Error("Error property 'code' is not a number");
      }
      if (typeof error.message !== "string") {
        throw new Error("Error property 'message' is not a string");
      }
      let maybeUndefinedData;
      if (error.data === void 0) {
        maybeUndefinedData = void 0;
      } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {
        maybeUndefinedData = error.data;
      } else {
        throw new Error("Error property 'data' is defined but not a JSON compatible value.");
      }
      return Object.assign({ code: error.code, message: error.message }, maybeUndefinedData !== void 0 ? { data: maybeUndefinedData } : {});
    }
    function parseJsonRpcErrorResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string" && id !== null) {
        throw new Error("Invalid id field");
      }
      if (typeof data.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data.error)) {
        throw new Error("Invalid error field");
      }
      return {
        jsonrpc: "2.0",
        id,
        error: parseError(data.error)
      };
    }
    exports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
    function parseJsonRpcSuccessResponse(data) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data)}`);
      }
      const id = data.id;
      if (typeof id !== "number" && typeof id !== "string") {
        throw new Error("Invalid id field");
      }
      if (typeof data.result === "undefined") {
        throw new Error("Invalid result field");
      }
      const result = data.result;
      return {
        jsonrpc: "2.0",
        id,
        result
      };
    }
    exports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
    function parseJsonRpcResponse(data) {
      let response;
      try {
        response = parseJsonRpcErrorResponse(data);
      } catch (_) {
        response = parseJsonRpcSuccessResponse(data);
      }
      return response;
    }
    exports.parseJsonRpcResponse = parseJsonRpcResponse;
  }
});

// node_modules/@cosmjs/json-rpc/build/index.js
var require_build9 = __commonJS({
  "node_modules/@cosmjs/json-rpc/build/index.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = exports.parseJsonRpcErrorResponse = exports.JsonRpcClient = exports.makeJsonRpcId = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "makeJsonRpcId", { enumerable: true, get: function() {
      return id_1.makeJsonRpcId;
    } });
    var jsonrpcclient_1 = require_jsonrpcclient();
    Object.defineProperty(exports, "JsonRpcClient", { enumerable: true, get: function() {
      return jsonrpcclient_1.JsonRpcClient;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports, "parseJsonRpcErrorResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcId", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcId;
    } });
    Object.defineProperty(exports, "parseJsonRpcRequest", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcRequest;
    } });
    Object.defineProperty(exports, "parseJsonRpcResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcSuccessResponse;
    } });
    var types_1 = require_types4();
    Object.defineProperty(exports, "isJsonRpcErrorResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "isJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcSuccessResponse;
    } });
    Object.defineProperty(exports, "jsonRpcCode", { enumerable: true, get: function() {
      return types_1.jsonRpcCode;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js
var require_rpcclient = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasProtocol = exports.instanceOfRpcStreamingClient = void 0;
    function instanceOfRpcStreamingClient(client) {
      return typeof client.listen === "function";
    }
    exports.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
    function hasProtocol(url) {
      return url.search("://") !== -1;
    }
    exports.hasProtocol = hasProtocol;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js
var require_httpclient = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = exports.http = void 0;
    var json_rpc_1 = require_build9();
    var axios_1 = __importDefault(require_axios());
    var rpcclient_1 = require_rpcclient();
    function filterBadStatus(res) {
      if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
      }
      return res;
    }
    async function http(method, url, request) {
      if (typeof fetch !== "undefined") {
        const body = request ? JSON.stringify(request) : void 0;
        return fetch(url, { method, body }).then(filterBadStatus).then((res) => res.json());
      } else {
        return axios_1.default.request({ url, method, data: request }).then((res) => res.data);
      }
    }
    exports.http = http;
    var HttpClient = class {
      constructor(url) {
        this.url = (0, rpcclient_1.hasProtocol)(url) ? url : "http://" + url;
      }
      disconnect() {
      }
      async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await http("POST", this.url, request));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
    };
    exports.HttpClient = HttpClient;
  }
});

// node_modules/isomorphic-ws/browser.js
var require_browser = __commonJS({
  "node_modules/isomorphic-ws/browser.js"(exports, module) {
    init_define_global();
    var ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof define_global_default !== "undefined") {
      ws = define_global_default.WebSocket || define_global_default.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws;
  }
});

// node_modules/@cosmjs/socket/build/socketwrapper.js
var require_socketwrapper = __commonJS({
  "node_modules/@cosmjs/socket/build/socketwrapper.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketWrapper = void 0;
    var isomorphic_ws_1 = __importDefault(require_browser());
    function environmentIsNodeJs() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    var SocketWrapper = class {
      constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 1e4) {
        this.closed = false;
        this.connected = new Promise((resolve, reject) => {
          this.connectedResolver = resolve;
          this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
      }
      connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error) => {
          this.clearTimeout();
          if (this.errorHandler) {
            this.errorHandler(error);
          }
        };
        socket.onmessage = (messageEvent) => {
          this.messageHandler({
            type: messageEvent.type,
            data: messageEvent.data
          });
        };
        socket.onopen = (_) => {
          this.clearTimeout();
          this.connectedResolver();
          if (this.openHandler) {
            this.openHandler();
          }
        };
        socket.onclose = (closeEvent) => {
          this.closed = true;
          if (this.closeHandler) {
            this.closeHandler(closeEvent);
          }
        };
        const started = Date.now();
        this.timeoutId = setTimeout(() => {
          socket.onmessage = () => 0;
          socket.onerror = () => 0;
          socket.onopen = () => 0;
          socket.onclose = () => 0;
          socket.close();
          this.socket = void 0;
          const elapsed = Math.floor(Date.now() - started);
          this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);
        }, this.timeout);
        this.socket = socket;
      }
      disconnect() {
        if (!this.socket) {
          throw new Error("Socket undefined. This must be called after connecting.");
        }
        this.clearTimeout();
        switch (this.socket.readyState) {
          case isomorphic_ws_1.default.OPEN:
            this.socket.close(1e3);
            break;
          case isomorphic_ws_1.default.CLOSED:
            break;
          case isomorphic_ws_1.default.CONNECTING:
            this.socket.onopen = () => 0;
            this.socket.onclose = () => 0;
            this.socket.onerror = () => 0;
            this.socket.onmessage = () => 0;
            this.socket = void 0;
            if (this.closeHandler) {
              this.closeHandler({ wasClean: false, code: 4001 });
            }
            break;
          case isomorphic_ws_1.default.CLOSING:
            break;
          default:
            throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
      }
      async send(data) {
        return new Promise((resolve, reject) => {
          if (!this.socket) {
            throw new Error("Socket undefined. This must be called after connecting.");
          }
          if (this.closed) {
            throw new Error("Socket was closed, so no data can be sent anymore.");
          }
          if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error("Websocket is not open");
          }
          if (environmentIsNodeJs()) {
            this.socket.send(data, (err) => err ? reject(err) : resolve());
          } else {
            this.socket.send(data);
            resolve();
          }
        });
      }
      clearTimeout() {
        if (!this.timeoutId) {
          throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        }
        clearTimeout(this.timeoutId);
      }
    };
    exports.SocketWrapper = SocketWrapper;
  }
});

// node_modules/@cosmjs/socket/build/streamingsocket.js
var require_streamingsocket = __commonJS({
  "node_modules/@cosmjs/socket/build/streamingsocket.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = void 0;
    var xstream_1 = require_xstream();
    var socketwrapper_1 = require_socketwrapper();
    var StreamingSocket = class {
      constructor(url, timeout = 1e4) {
        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.next(event);
          }
        }, (errorEvent) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.error(errorEvent);
          }
        }, () => {
        }, (closeEvent) => {
          if (this.eventProducerListener) {
            if (closeEvent.wasClean) {
              this.eventProducerListener.complete();
            } else {
              this.eventProducerListener.error("Socket was closed unclean");
            }
          }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
      }
      connect() {
        this.socket.connect();
      }
      disconnect() {
        this.socket.disconnect();
      }
      async send(data) {
        return this.socket.send(data);
      }
    };
    exports.StreamingSocket = StreamingSocket;
  }
});

// node_modules/@cosmjs/socket/build/queueingstreamingsocket.js
var require_queueingstreamingsocket = __commonJS({
  "node_modules/@cosmjs/socket/build/queueingstreamingsocket.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var stream_1 = require_build8();
    var xstream_1 = require_xstream();
    var streamingsocket_1 = require_streamingsocket();
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Unconnected"] = 0] = "Unconnected";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Connected"] = 2] = "Connected";
      ConnectionStatus2[ConnectionStatus2["Disconnected"] = 3] = "Disconnected";
    })(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));
    var QueueingStreamingSocket = class {
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.queue = [];
        this.isProcessingQueue = false;
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)
        });
      }
      connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async () => {
          this.connectionStatusProducer.update(ConnectionStatus.Connected);
          return this.processQueue();
        }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));
        this.socket.connect();
      }
      disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
      }
      reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)
        });
        this.socket.connected.then(() => {
          if (this.reconnectedHandler) {
            this.reconnectedHandler();
          }
        });
        this.connect();
      }
      getQueueLength() {
        return this.queue.length;
      }
      queueRequest(request) {
        this.queue.push(request);
        this.processQueue();
      }
      async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {
          return;
        }
        this.isProcessingQueue = true;
        let request;
        while (request = this.queue.shift()) {
          try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
          } catch (error) {
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
          }
        }
      }
    };
    exports.QueueingStreamingSocket = QueueingStreamingSocket;
  }
});

// node_modules/@cosmjs/socket/build/reconnectingsocket.js
var require_reconnectingsocket = __commonJS({
  "node_modules/@cosmjs/socket/build/reconnectingsocket.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReconnectingSocket = void 0;
    var xstream_1 = require_xstream();
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    var ReconnectingSocket = class {
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.unconnected = true;
        this.disconnected = false;
        this.timeoutIndex = 0;
        this.reconnectTimeout = null;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
          next: (event) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.next(event);
            }
          },
          error: (error) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.error(error);
            }
          }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
          next: (status) => {
            if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {
              this.timeoutIndex = 0;
            }
            if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
              if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
              }
              this.reconnectTimeout = setTimeout(() => this.socket.reconnect(), ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
            }
          }
        });
      }
      static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5e3);
      }
      connect() {
        if (!this.unconnected) {
          throw new Error("Cannot connect: socket has already connected");
        }
        this.socket.connect();
        this.unconnected = false;
      }
      disconnect() {
        if (this.unconnected) {
          throw new Error("Cannot disconnect: socket has not yet connected");
        }
        this.socket.disconnect();
        if (this.eventProducerListener) {
          this.eventProducerListener.complete();
        }
        this.disconnected = true;
      }
      queueRequest(request) {
        if (this.disconnected) {
          throw new Error("Cannot queue request: socket has disconnected");
        }
        this.socket.queueRequest(request);
      }
    };
    exports.ReconnectingSocket = ReconnectingSocket;
  }
});

// node_modules/@cosmjs/socket/build/index.js
var require_build10 = __commonJS({
  "node_modules/@cosmjs/socket/build/index.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = exports.SocketWrapper = exports.ReconnectingSocket = exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    Object.defineProperty(exports, "ConnectionStatus", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.ConnectionStatus;
    } });
    Object.defineProperty(exports, "QueueingStreamingSocket", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.QueueingStreamingSocket;
    } });
    var reconnectingsocket_1 = require_reconnectingsocket();
    Object.defineProperty(exports, "ReconnectingSocket", { enumerable: true, get: function() {
      return reconnectingsocket_1.ReconnectingSocket;
    } });
    var socketwrapper_1 = require_socketwrapper();
    Object.defineProperty(exports, "SocketWrapper", { enumerable: true, get: function() {
      return socketwrapper_1.SocketWrapper;
    } });
    var streamingsocket_1 = require_streamingsocket();
    Object.defineProperty(exports, "StreamingSocket", { enumerable: true, get: function() {
      return streamingsocket_1.StreamingSocket;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js
var require_websocketclient = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = void 0;
    var json_rpc_1 = require_build9();
    var socket_1 = require_build10();
    var stream_1 = require_build8();
    var xstream_1 = require_xstream();
    var rpcclient_1 = require_rpcclient();
    function defaultErrorHandler(error) {
      throw error;
    }
    function toJsonRpcResponse(message) {
      if (message.type !== "message") {
        throw new Error(`Unexcepted message type on websocket: ${message.type}`);
      }
      const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
      return jsonRpcEvent;
    }
    var RpcEventProducer = class {
      constructor(request, socket) {
        this.running = false;
        this.subscriptions = [];
        this.request = request;
        this.socket = socket;
      }
      start(listener) {
        if (this.running) {
          throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
      }
      stop() {
        this.running = false;
        const endRequest = Object.assign(Object.assign({}, this.request), { method: "unsubscribe" });
        try {
          this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
          if (error instanceof Error && error.message.match(/socket has disconnected/i)) {
          } else {
            throw error;
          }
        }
      }
      connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        const idSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            }
            idSubscription.unsubscribe();
          }
        });
        const idEventSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            } else {
              listener.next(response.result);
            }
          }
        });
        const nonResponseSubscription = responseStream.subscribe({
          error: (error) => {
            this.closeSubscriptions();
            listener.error(error);
          },
          complete: () => {
            this.closeSubscriptions();
            listener.complete();
          }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
      }
      closeSubscriptions() {
        for (const subscription of this.subscriptions) {
          subscription.unsubscribe();
        }
        this.subscriptions = [];
      }
    };
    var WebsocketClient = class {
      constructor(baseUrl, onError = defaultErrorHandler) {
        this.subscriptionStreams = new Map();
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        const cleanBaseUrl = (0, rpcclient_1.hasProtocol)(baseUrl) ? baseUrl : "ws://" + baseUrl;
        this.url = cleanBaseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
          error: (error) => {
            onError(error);
            errorSubscription.unsubscribe();
          }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
      }
      async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
      listen(request) {
        if (request.method !== "subscribe") {
          throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
          throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
          const producer = new RpcEventProducer(request, this.socket);
          const stream = xstream_1.Stream.create(producer);
          this.subscriptionStreams.set(query, stream);
        }
        return this.subscriptionStreams.get(query).filter((response) => response.query !== void 0);
      }
      async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
      }
      disconnect() {
        this.socket.disconnect();
      }
      async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r) => r.id === id));
      }
    };
    exports.WebsocketClient = WebsocketClient;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js
var require_rpcclients = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = exports.instanceOfRpcStreamingClient = exports.HttpClient = void 0;
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return httpclient_1.HttpClient;
    } });
    var rpcclient_1 = require_rpcclient();
    Object.defineProperty(exports, "instanceOfRpcStreamingClient", { enumerable: true, get: function() {
      return rpcclient_1.instanceOfRpcStreamingClient;
    } });
    var websocketclient_1 = require_websocketclient();
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return websocketclient_1.WebsocketClient;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js
var require_requests = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildQuery = exports.SubscriptionEventType = exports.Method = void 0;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method = exports.Method || (exports.Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType = exports.SubscriptionEventType || (exports.SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
    exports.buildQuery = buildQuery;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js
var require_responses = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxCommitSuccess = exports.broadcastTxSyncSuccess = void 0;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType = exports.VoteType || (exports.VoteType = {}));
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJsonRpcRequest = void 0;
    var numbersWithoutZero = "123456789";
    function randomNumericChar() {
      return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
    }
    function randomId() {
      return parseInt(Array.from({ length: 12 }).map(() => randomNumericChar()).join(""), 10);
    }
    function createJsonRpcRequest(method, params) {
      const paramsCopy = params ? Object.assign({}, params) : {};
      return {
        jsonrpc: "2.0",
        id: randomId(),
        method,
        params: paramsCopy
      };
    }
    exports.createJsonRpcRequest = createJsonRpcRequest;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js
var require_encodings = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeInt = exports.encodeString = exports.Integer = exports.dictionaryToStringMap = exports.may = exports.optional = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build3();
    function assertSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    exports.assertSet = assertSet;
    function assertBoolean(value) {
      assertSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    exports.assertBoolean = assertBoolean;
    function assertString(value) {
      assertSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    exports.assertString = assertString;
    function assertNumber(value) {
      assertSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    exports.assertNumber = assertNumber;
    function assertArray(value) {
      assertSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be a an array");
      }
      return value;
    }
    exports.assertArray = assertArray;
    function assertObject(value) {
      assertSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    exports.assertObject = assertObject;
    function assertNotEmpty(value) {
      assertSet(value);
      if (typeof value === "number" && value === 0) {
        throw new Error("must provide a non-zero value");
      } else if (value.length === 0) {
        throw new Error("must provide a non-empty value");
      }
      return value;
    }
    exports.assertNotEmpty = assertNotEmpty;
    function optional(value, fallback) {
      return value === void 0 || value === null ? fallback : value;
    }
    exports.optional = optional;
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    exports.may = may;
    function dictionaryToStringMap(obj) {
      const out = new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    exports.dictionaryToStringMap = dictionaryToStringMap;
    var Integer = class {
      static parse(input) {
        const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
        return asInt.toNumber();
      }
      static encode(num) {
        return new math_1.Int53(num).toString();
      }
    };
    exports.Integer = Integer;
    function encodeString(s) {
      const utf8 = (0, encoding_1.toUtf8)(s);
      return Uint8Array.from([utf8.length, ...utf8]);
    }
    exports.encodeString = encodeString;
    function encodeInt(n) {
      return n >= 128 ? Uint8Array.from([n & 255 | 128, ...encodeInt(n >> 7)]) : Uint8Array.from([n & 255]);
    }
    exports.encodeInt = encodeInt;
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeInt(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeInt(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    exports.encodeTime = encodeTime;
    function encodeBytes(bytes) {
      if (bytes.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes.length ? Uint8Array.from([bytes.length, ...bytes]) : new Uint8Array();
    }
    exports.encodeBytes = encodeBytes;
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeInt(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeInt(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    exports.encodeVersion = encodeVersion;
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
    exports.encodeBlockId = encodeBlockId;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js
var require_hasher = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashBlock = exports.hashTx = void 0;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    exports.hashTx = hashTx;
    function getSplitPoint(n) {
      if (n < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n));
      return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash = new crypto_1.Sha256(Uint8Array.from([0]));
      hash.update(leaf);
      return hash.digest();
    }
    function hashInner(left, right) {
      const hash = new crypto_1.Sha256(Uint8Array.from([1]));
      hash.update(left);
      hash.update(right);
      return hash.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeInt)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
    exports.hashBlock = hashBlock;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js
var require_requests2 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js"(exports) {
    init_define_global();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings();
    var requests = __importStar(require_requests());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(encodings_1.Integer.encode, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(encodings_1.Integer.encode, param.minHeight),
        maxHeight: (0, encodings_1.may)(encodings_1.Integer.encode, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(encodings_1.Integer.encode, params.page),
        per_page: (0, encodings_1.may)(encodings_1.Integer.encode, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, encodings_1.assertNotEmpty)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(encodings_1.Integer.encode, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.tx))
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)((0, encodings_1.assertNotEmpty)(params.hash)),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(encodings_1.Integer.encode, params.page),
        per_page: (0, encodings_1.may)(encodings_1.Integer.encode, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(encodings_1.Integer.encode, params.height),
        page: (0, encodings_1.may)(encodings_1.Integer.encode, params.page),
        per_page: (0, encodings_1.may)(encodings_1.Integer.encode, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/types.js
var require_types5 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/types.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = void 0;
    var BlockIdFlag;
    (function(BlockIdFlag2) {
      BlockIdFlag2[BlockIdFlag2["Unknown"] = 0] = "Unknown";
      BlockIdFlag2[BlockIdFlag2["Absent"] = 1] = "Absent";
      BlockIdFlag2[BlockIdFlag2["Commit"] = 2] = "Commit";
      BlockIdFlag2[BlockIdFlag2["Nil"] = 3] = "Nil";
      BlockIdFlag2[BlockIdFlag2["Unrecognized"] = -1] = "Unrecognized";
    })(BlockIdFlag = exports.BlockIdFlag || (exports.BlockIdFlag = {}));
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js
var require_responses2 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    var encoding_1 = require_build();
    var utils_1 = require_build2();
    var dates_1 = require_dates();
    var types_1 = require_types5();
    var encodings_1 = require_encodings();
    var hasher_1 = require_hasher();
    function decodeAbciInfo(data) {
      return {
        data: data.data,
        lastBlockHeight: (0, encodings_1.may)(encodings_1.Integer.parse, data.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data.last_block_app_hash)
      };
    }
    function decodeQueryProof(data) {
      return {
        ops: data.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.optional)(data.key, "")),
        value: (0, encoding_1.fromBase64)((0, encodings_1.optional)(data.value, "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data.proofOps),
        height: (0, encodings_1.may)(encodings_1.Integer.parse, data.height),
        code: (0, encodings_1.may)(encodings_1.Integer.parse, data.code),
        index: (0, encodings_1.may)(encodings_1.Integer.parse, data.index),
        log: data.log
      };
    }
    function decodeAttribute(attribute) {
      return {
        key: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, encodings_1.optional)(attribute.value, ""))
      };
    }
    function decodeAttributes(attributes) {
      return (0, encodings_1.assertArray)(attributes).map(decodeAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: decodeAttributes(event.attributes)
      };
    }
    function decodeEvents(events) {
      return (0, encodings_1.assertArray)(events).map(decodeEvent);
    }
    function decodeTxData(data) {
      return {
        code: encodings_1.Integer.parse((0, encodings_1.assertNumber)((0, encodings_1.optional)(data.code, 0))),
        codeSpace: data.codespace,
        log: data.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data.data),
        events: data.events ? decodeEvents(data.events) : [],
        gasWanted: encodings_1.Integer.parse((0, encodings_1.optional)(data.gas_wanted, "0")),
        gasUsed: encodings_1.Integer.parse((0, encodings_1.optional)(data.gas_used, "0"))
      };
    }
    function decodePubkey(data) {
      switch (data.type) {
        case "tendermint/PubKeyEd25519":
          return {
            algorithm: "ed25519",
            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
          };
        case "tendermint/PubKeySecp256k1":
          return {
            algorithm: "secp256k1",
            data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.value))
          };
        default:
          throw new Error(`unknown pubkey type: ${data.type}`);
      }
    }
    function decodeValidatorUpdate(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        proposerPriority: encodings_1.Integer.parse(data.proposer_priority)
      };
    }
    function decodeBlockParams(data) {
      return {
        maxBytes: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_bytes)),
        maxGas: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_gas))
      };
    }
    function decodeEvidenceParams(data) {
      return {
        maxAgeNumBlocks: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_age_num_blocks)),
        maxAgeDuration: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.max_age_duration))
      };
    }
    function decodeConsensusParams(data) {
      return {
        block: decodeBlockParams((0, encodings_1.assertObject)(data.block)),
        evidence: decodeEvidenceParams((0, encodings_1.assertObject)(data.evidence))
      };
    }
    function decodeBlockResults(data) {
      return {
        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),
        results: (data.txs_results || []).map(decodeTxData),
        validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data.consensus_param_updates),
        beginBlockEvents: decodeEvents(data.begin_block_events || []),
        endBlockEvents: decodeEvents(data.end_block_events || [])
      };
    }
    function decodeBlockId(data) {
      return {
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        parts: {
          total: (0, encodings_1.assertNotEmpty)(data.parts.total),
          hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data) {
      var _a;
      return {
        block: encodings_1.Integer.parse(data.block),
        app: encodings_1.Integer.parse((_a = data.app) !== null && _a !== void 0 ? _a : 0)
      };
    }
    function decodeHeader(data) {
      return {
        version: decodeBlockVersion(data.version),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.time)),
        lastBlockId: data.last_block_id.hash ? decodeBlockId(data.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.proposer_address))
      };
    }
    function decodeBlockMeta(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        blockSize: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.block_size)),
        header: decodeHeader(data.header),
        numTxs: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.num_txs))
      };
    }
    function decodeBlockchain(data) {
      return {
        lastHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.last_height)),
        blockMetas: (0, encodings_1.assertArray)(data.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data) {
      return Object.assign(Object.assign({}, decodeTxData(data)), { hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)) });
    }
    function decodeBroadcastTxCommit(data) {
      return {
        height: encodings_1.Integer.parse(data.height),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        checkTx: decodeTxData((0, encodings_1.assertObject)(data.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeOptionalTime(timestamp) {
      const nonZeroTime = timestamp && !timestamp.startsWith("0001-01-01");
      return nonZeroTime ? (0, dates_1.fromRfc3339WithNanoseconds)(timestamp) : void 0;
    }
    function decodeCommitSignature(data) {
      return {
        blockIdFlag: decodeBlockIdFlag(data.block_id_flag),
        validatorAddress: data.validator_address ? (0, encoding_1.fromHex)(data.validator_address) : void 0,
        timestamp: decodeOptionalTime(data.timestamp),
        signature: data.signature ? (0, encoding_1.fromBase64)(data.signature) : void 0
      };
    }
    function decodeCommit(data) {
      return {
        blockId: decodeBlockId((0, encodings_1.assertObject)(data.block_id)),
        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),
        round: encodings_1.Integer.parse(data.round),
        signatures: (0, encodings_1.assertArray)(data.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data) {
      return {
        canonical: (0, encodings_1.assertBoolean)(data.canonical),
        header: decodeHeader(data.signed_header.header),
        commit: decodeCommit(data.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data) {
      return {
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address)),
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.power))
      };
    }
    function decodeGenesis(data) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.genesis_time)),
        chainId: (0, encodings_1.assertNotEmpty)(data.chain_id),
        consensusParams: decodeConsensusParams(data.consensus_params),
        validators: data.validators ? (0, encodings_1.assertArray)(data.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, encodings_1.assertSet)(data.app_hash)),
        appState: data.app_state
      };
    }
    function decodeValidatorInfo(data) {
      return {
        pubkey: decodePubkey((0, encodings_1.assertObject)(data.pub_key)),
        votingPower: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.voting_power)),
        address: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.address))
      };
    }
    function decodeNodeInfo(data) {
      return {
        id: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.id)),
        listenAddr: (0, encodings_1.assertNotEmpty)(data.listen_addr),
        network: (0, encodings_1.assertNotEmpty)(data.network),
        version: (0, encodings_1.assertString)(data.version),
        channels: (0, encodings_1.assertNotEmpty)(data.channels),
        moniker: (0, encodings_1.assertNotEmpty)(data.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data.other),
        protocolVersion: {
          app: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.app)),
          block: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.block)),
          p2p: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data) {
      return {
        latestBlockHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, encodings_1.assertNotEmpty)(data.latest_block_time)),
        latestBlockHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.latest_block_height)),
        catchingUp: (0, encodings_1.assertBoolean)(data.catching_up)
      };
    }
    function decodeStatus(data) {
      return {
        nodeInfo: decodeNodeInfo(data.node_info),
        syncInfo: decodeSyncInfo(data.sync_info),
        validatorInfo: decodeValidatorInfo(data.validator_info)
      };
    }
    function decodeTxProof(data) {
      return {
        data: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.data)),
        rootHash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.root_hash)),
        proof: {
          total: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.proof.total)),
          index: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.proof.leaf_hash)),
          aunts: (0, encodings_1.assertArray)(data.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data) {
      return {
        tx: (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx)),
        result: decodeTxData((0, encodings_1.assertObject)(data.tx_result)),
        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),
        index: encodings_1.Integer.parse((0, encodings_1.assertNumber)(data.index)),
        hash: (0, encoding_1.fromHex)((0, encodings_1.assertNotEmpty)(data.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data.proof)
      };
    }
    function decodeTxSearch(data) {
      return {
        totalCount: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total_count)),
        txs: (0, encodings_1.assertArray)(data.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data) {
      const tx = (0, encoding_1.fromBase64)((0, encodings_1.assertNotEmpty)(data.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data.result),
        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),
        index: (0, encodings_1.may)(encodings_1.Integer.parse, data.index)
      };
    }
    function decodeValidators(data) {
      return {
        blockHeight: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.block_height)),
        validators: (0, encodings_1.assertArray)(data.validators).map(decodeValidatorUpdate),
        count: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.count)),
        total: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total))
      };
    }
    function decodeEvidence(data) {
      return {
        type: (0, encodings_1.assertNotEmpty)(data.type),
        height: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.height)),
        time: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.time)),
        totalVotingPower: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.totalVotingPower)),
        validator: decodeValidatorUpdate(data.validator)
      };
    }
    function decodeEvidences(ev) {
      return (0, encodings_1.assertArray)(ev).map(decodeEvidence);
    }
    function decodeBlock(data) {
      return {
        header: decodeHeader((0, encodings_1.assertObject)(data.header)),
        lastCommit: data.last_commit.block_id.hash ? decodeCommit((0, encodings_1.assertObject)(data.last_commit)) : null,
        txs: data.data.txs ? (0, encodings_1.assertArray)(data.data.txs).map(encoding_1.fromBase64) : [],
        evidence: data.evidence && (0, encodings_1.may)(decodeEvidences, data.evidence.evidence)
      };
    }
    function decodeBlockResponse(data) {
      return {
        blockId: decodeBlockId(data.block_id),
        block: decodeBlock(data.block)
      };
    }
    function decodeBlockSearch(data) {
      return {
        totalCount: encodings_1.Integer.parse((0, encodings_1.assertNotEmpty)(data.total_count)),
        blocks: (0, encodings_1.assertArray)(data.blocks).map(decodeBlockResponse)
      };
    }
    var Responses = class {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, encodings_1.assertObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, encodings_1.assertObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js
var require_adaptor = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.adaptor34 = void 0;
    var hasher_1 = require_hasher();
    var requests_1 = require_requests2();
    var responses_1 = require_responses2();
    exports.adaptor34 = {
      params: requests_1.Params,
      responses: responses_1.Responses,
      hashTx: hasher_1.hashTx,
      hashBlock: hasher_1.hashBlock
    };
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js
var require_tendermint34client = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js"(exports) {
    init_define_global();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = void 0;
    var jsonrpc_1 = require_jsonrpc();
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor();
    var requests = __importStar(require_requests());
    var Tendermint34Client = class {
      constructor(client) {
        this.client = client;
        this.p = adaptor_1.adaptor34.params;
        this.r = adaptor_1.adaptor34.responses;
      }
      static async connect(url) {
        const useHttp = url.startsWith("http://") || url.startsWith("https://");
        const rpcClient = useHttp ? new rpcclients_1.HttpClient(url) : new rpcclients_1.WebsocketClient(url);
        return Tendermint34Client.create(rpcClient);
      }
      static async create(rpcClient) {
        const _version = await this.detectVersion(rpcClient);
        return new Tendermint34Client(rpcClient);
      }
      static async detectVersion(client) {
        const req = (0, jsonrpc_1.createJsonRpcRequest)(requests.Method.Status);
        const response = await client.execute(req);
        const result = response.result;
        if (!result || !result.node_info) {
          throw new Error("Unrecognized format for status response");
        }
        const version = result.node_info.version;
        if (typeof version !== "string") {
          throw new Error("Unrecognized version format: must be string");
        }
        return version;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, this.p.encodeAbciInfo, this.r.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, this.p.encodeAbciQuery, this.r.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, this.p.encodeBlock, this.r.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, this.p.encodeBlockResults, this.r.decodeBlockResults);
      }
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, this.p.encodeBlockSearch, this.r.decodeBlockSearch);
        return Object.assign(Object.assign({}, resp), {
          blocks: [...resp.blocks].sort((a, b) => a.block.header.height - b.block.header.height)
        });
      }
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch(Object.assign(Object.assign({}, params), { page }));
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a, b) => a.block.header.height - b.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, this.p.encodeBlockchain, this.r.decodeBlockchain);
      }
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxSync);
      }
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxAsync);
      }
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, this.p.encodeBroadcastTx, this.r.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, this.p.encodeCommit, this.r.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, this.p.encodeGenesis, this.r.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, this.p.encodeHealth, this.r.decodeHealth);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, this.p.encodeStatus, this.r.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, this.r.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, this.r.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, this.r.decodeTxEvent);
      }
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, this.p.encodeTx, this.r.decodeTx);
      }
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, this.p.encodeTxSearch, this.r.decodeTxSearch);
      }
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch(Object.assign(Object.assign({}, params), { page }));
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, this.p.encodeValidators, this.r.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          blockHeight: blockHeight !== null && blockHeight !== void 0 ? blockHeight : 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = this.p.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint34Client = Tendermint34Client;
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js
var require_tendermint34 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint34client_1 = require_tendermint34client();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34client_1.Tendermint34Client;
    } });
  }
});

// node_modules/@cosmjs/tendermint-rpc/build/index.js
var require_build11 = __commonJS({
  "node_modules/@cosmjs/tendermint-rpc/build/index.js"(exports) {
    init_define_global();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = exports.Tendermint34Client = exports.tendermint34 = exports.VoteType = exports.SubscriptionEventType = exports.Method = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.WebsocketClient = exports.HttpClient = exports.toSeconds = exports.toRfc3339WithNanoseconds = exports.fromSeconds = exports.fromRfc3339WithNanoseconds = exports.DateTime = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var dates_1 = require_dates();
    Object.defineProperty(exports, "DateTime", { enumerable: true, get: function() {
      return dates_1.DateTime;
    } });
    Object.defineProperty(exports, "fromRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.fromRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "fromSeconds", { enumerable: true, get: function() {
      return dates_1.fromSeconds;
    } });
    Object.defineProperty(exports, "toRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.toRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "toSeconds", { enumerable: true, get: function() {
      return dates_1.toSeconds;
    } });
    var rpcclients_1 = require_rpcclients();
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpClient;
    } });
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return rpcclients_1.WebsocketClient;
    } });
    var tendermint34_1 = require_tendermint34();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return tendermint34_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return tendermint34_1.SubscriptionEventType;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return tendermint34_1.VoteType;
    } });
    exports.tendermint34 = __importStar(require_tendermint34());
    var tendermint34_2 = require_tendermint34();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34_2.Tendermint34Client;
    } });
    var types_1 = require_types5();
    Object.defineProperty(exports, "BlockIdFlag", { enumerable: true, get: function() {
      return types_1.BlockIdFlag;
    } });
  }
});

// node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js
var require_tx4 = __commonJS({
  "node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgFundCommunityPoolResponse = exports.MsgFundCommunityPool = exports.MsgWithdrawValidatorCommissionResponse = exports.MsgWithdrawValidatorCommission = exports.MsgWithdrawDelegatorRewardResponse = exports.MsgWithdrawDelegatorReward = exports.MsgSetWithdrawAddressResponse = exports.MsgSetWithdrawAddress = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    var baseMsgSetWithdrawAddress = { delegatorAddress: "", withdrawAddress: "" };
    exports.MsgSetWithdrawAddress = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
          writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgSetWithdrawAddress);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgSetWithdrawAddress);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.withdrawAddress = object.withdrawAddress !== void 0 && object.withdrawAddress !== null ? String(object.withdrawAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgSetWithdrawAddress);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.withdrawAddress = (_b = object.withdrawAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgSetWithdrawAddressResponse = {};
    exports.MsgSetWithdrawAddressResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgSetWithdrawAddressResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgSetWithdrawAddressResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgSetWithdrawAddressResponse);
        return message;
      }
    };
    var baseMsgWithdrawDelegatorReward = { delegatorAddress: "", validatorAddress: "" };
    exports.MsgWithdrawDelegatorReward = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgWithdrawDelegatorReward);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgWithdrawDelegatorReward);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgWithdrawDelegatorReward);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgWithdrawDelegatorRewardResponse = {};
    exports.MsgWithdrawDelegatorRewardResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgWithdrawDelegatorRewardResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgWithdrawDelegatorRewardResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgWithdrawDelegatorRewardResponse);
        return message;
      }
    };
    var baseMsgWithdrawValidatorCommission = { validatorAddress: "" };
    exports.MsgWithdrawValidatorCommission = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgWithdrawValidatorCommission);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgWithdrawValidatorCommission);
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseMsgWithdrawValidatorCommission);
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseMsgWithdrawValidatorCommissionResponse = {};
    exports.MsgWithdrawValidatorCommissionResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgWithdrawValidatorCommissionResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgWithdrawValidatorCommissionResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgWithdrawValidatorCommissionResponse);
        return message;
      }
    };
    var baseMsgFundCommunityPool = { depositor: "" };
    exports.MsgFundCommunityPool = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgFundCommunityPool);
        message.amount = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseMsgFundCommunityPool);
        message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        message.depositor = object.depositor !== void 0 && object.depositor !== null ? String(object.depositor) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgFundCommunityPool);
        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.depositor = (_b = object.depositor) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgFundCommunityPoolResponse = {};
    exports.MsgFundCommunityPoolResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgFundCommunityPoolResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgFundCommunityPoolResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgFundCommunityPoolResponse);
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
        this.FundCommunityPool = this.FundCommunityPool.bind(this);
      }
      SetWithdrawAddress(request) {
        const data = exports.MsgSetWithdrawAddress.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", data);
        return promise.then((data2) => exports.MsgSetWithdrawAddressResponse.decode(new minimal_1.default.Reader(data2)));
      }
      WithdrawDelegatorReward(request) {
        const data = exports.MsgWithdrawDelegatorReward.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", data);
        return promise.then((data2) => exports.MsgWithdrawDelegatorRewardResponse.decode(new minimal_1.default.Reader(data2)));
      }
      WithdrawValidatorCommission(request) {
        const data = exports.MsgWithdrawValidatorCommission.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", data);
        return promise.then((data2) => exports.MsgWithdrawValidatorCommissionResponse.decode(new minimal_1.default.Reader(data2)));
      }
      FundCommunityPool(request) {
        const data = exports.MsgFundCommunityPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", data);
        return promise.then((data2) => exports.MsgFundCommunityPoolResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js
var require_tx5 = __commonJS({
  "node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    var gov_1 = require_gov();
    var coin_1 = require_coin();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    var baseMsgSubmitProposal = { proposer: "" };
    exports.MsgSubmitProposal = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
          coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgSubmitProposal);
        message.initialDeposit = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseMsgSubmitProposal);
        message.content = object.content !== void 0 && object.content !== null ? any_1.Any.fromJSON(object.content) : void 0;
        message.initialDeposit = ((_a = object.initialDeposit) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        message.proposer = object.proposer !== void 0 && object.proposer !== null ? String(object.proposer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgSubmitProposal);
        message.content = object.content !== void 0 && object.content !== null ? any_1.Any.fromPartial(object.content) : void 0;
        message.initialDeposit = ((_a = object.initialDeposit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        message.proposer = (_b = object.proposer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgSubmitProposalResponse = { proposalId: long_1.default.UZERO };
    exports.MsgSubmitProposalResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgSubmitProposalResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgSubmitProposalResponse);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseMsgSubmitProposalResponse);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        return message;
      }
    };
    var baseMsgVote = { proposalId: long_1.default.UZERO, voter: "", option: 0 };
    exports.MsgVote = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgVote);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgVote);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.voter = object.voter !== void 0 && object.voter !== null ? String(object.voter) : "";
        message.option = object.option !== void 0 && object.option !== null ? gov_1.voteOptionFromJSON(object.option) : 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = gov_1.voteOptionToJSON(message.option));
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgVote);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.voter = (_a = object.voter) !== null && _a !== void 0 ? _a : "";
        message.option = (_b = object.option) !== null && _b !== void 0 ? _b : 0;
        return message;
      }
    };
    var baseMsgVoteResponse = {};
    exports.MsgVoteResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgVoteResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgVoteResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgVoteResponse);
        return message;
      }
    };
    var baseMsgVoteWeighted = { proposalId: long_1.default.UZERO, voter: "" };
    exports.MsgVoteWeighted = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
          gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgVoteWeighted);
        message.options = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseMsgVoteWeighted);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.voter = object.voter !== void 0 && object.voter !== null ? String(object.voter) : "";
        message.options = ((_a = object.options) !== null && _a !== void 0 ? _a : []).map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgVoteWeighted);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.voter = (_a = object.voter) !== null && _a !== void 0 ? _a : "";
        message.options = ((_b = object.options) === null || _b === void 0 ? void 0 : _b.map((e) => gov_1.WeightedVoteOption.fromPartial(e))) || [];
        return message;
      }
    };
    var baseMsgVoteWeightedResponse = {};
    exports.MsgVoteWeightedResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgVoteWeightedResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgVoteWeightedResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgVoteWeightedResponse);
        return message;
      }
    };
    var baseMsgDeposit = { proposalId: long_1.default.UZERO, depositor: "" };
    exports.MsgDeposit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.proposalId.isZero()) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
          coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgDeposit);
        message.amount = [];
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseMsgDeposit);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromString(object.proposalId) : long_1.default.UZERO;
        message.depositor = object.depositor !== void 0 && object.depositor !== null ? String(object.depositor) : "";
        message.amount = ((_a = object.amount) !== null && _a !== void 0 ? _a : []).map((e) => coin_1.Coin.fromJSON(e));
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || long_1.default.UZERO).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgDeposit);
        message.proposalId = object.proposalId !== void 0 && object.proposalId !== null ? long_1.default.fromValue(object.proposalId) : long_1.default.UZERO;
        message.depositor = (_a = object.depositor) !== null && _a !== void 0 ? _a : "";
        message.amount = ((_b = object.amount) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
      }
    };
    var baseMsgDepositResponse = {};
    exports.MsgDepositResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgDepositResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgDepositResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgDepositResponse);
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
      }
      SubmitProposal(request) {
        const data = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", data);
        return promise.then((data2) => exports.MsgSubmitProposalResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Vote(request) {
        const data = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", data);
        return promise.then((data2) => exports.MsgVoteResponse.decode(new minimal_1.default.Reader(data2)));
      }
      VoteWeighted(request) {
        const data = exports.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", data);
        return promise.then((data2) => exports.MsgVoteWeightedResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Deposit(request) {
        const data = exports.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", data);
        return promise.then((data2) => exports.MsgDepositResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js
var require_tx6 = __commonJS({
  "node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUndelegateResponse = exports.MsgUndelegate = exports.MsgBeginRedelegateResponse = exports.MsgBeginRedelegate = exports.MsgDelegateResponse = exports.MsgDelegate = exports.MsgEditValidatorResponse = exports.MsgEditValidator = exports.MsgCreateValidatorResponse = exports.MsgCreateValidator = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var staking_1 = require_staking();
    var any_1 = require_any();
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    var baseMsgCreateValidator = { minSelfDelegation: "", delegatorAddress: "", validatorAddress: "" };
    exports.MsgCreateValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
          writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== void 0) {
          any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== void 0) {
          coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgCreateValidator);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 3:
              message.minSelfDelegation = reader.string();
              break;
            case 4:
              message.delegatorAddress = reader.string();
              break;
            case 5:
              message.validatorAddress = reader.string();
              break;
            case 6:
              message.pubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.value = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgCreateValidator);
        message.description = object.description !== void 0 && object.description !== null ? staking_1.Description.fromJSON(object.description) : void 0;
        message.commission = object.commission !== void 0 && object.commission !== null ? staking_1.CommissionRates.fromJSON(object.commission) : void 0;
        message.minSelfDelegation = object.minSelfDelegation !== void 0 && object.minSelfDelegation !== null ? String(object.minSelfDelegation) : "";
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        message.pubkey = object.pubkey !== void 0 && object.pubkey !== null ? any_1.Any.fromJSON(object.pubkey) : void 0;
        message.value = object.value !== void 0 && object.value !== null ? coin_1.Coin.fromJSON(object.value) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.commission !== void 0 && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== void 0 && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : void 0);
        message.value !== void 0 && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseMsgCreateValidator);
        message.description = object.description !== void 0 && object.description !== null ? staking_1.Description.fromPartial(object.description) : void 0;
        message.commission = object.commission !== void 0 && object.commission !== null ? staking_1.CommissionRates.fromPartial(object.commission) : void 0;
        message.minSelfDelegation = (_a = object.minSelfDelegation) !== null && _a !== void 0 ? _a : "";
        message.delegatorAddress = (_b = object.delegatorAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : "";
        message.pubkey = object.pubkey !== void 0 && object.pubkey !== null ? any_1.Any.fromPartial(object.pubkey) : void 0;
        message.value = object.value !== void 0 && object.value !== null ? coin_1.Coin.fromPartial(object.value) : void 0;
        return message;
      }
    };
    var baseMsgCreateValidatorResponse = {};
    exports.MsgCreateValidatorResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgCreateValidatorResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgCreateValidatorResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgCreateValidatorResponse);
        return message;
      }
    };
    var baseMsgEditValidator = { validatorAddress: "", commissionRate: "", minSelfDelegation: "" };
    exports.MsgEditValidator = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
          writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgEditValidator);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.commissionRate = reader.string();
              break;
            case 4:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgEditValidator);
        message.description = object.description !== void 0 && object.description !== null ? staking_1.Description.fromJSON(object.description) : void 0;
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        message.commissionRate = object.commissionRate !== void 0 && object.commissionRate !== null ? String(object.commissionRate) : "";
        message.minSelfDelegation = object.minSelfDelegation !== void 0 && object.minSelfDelegation !== null ? String(object.minSelfDelegation) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== void 0 && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseMsgEditValidator);
        message.description = object.description !== void 0 && object.description !== null ? staking_1.Description.fromPartial(object.description) : void 0;
        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : "";
        message.commissionRate = (_b = object.commissionRate) !== null && _b !== void 0 ? _b : "";
        message.minSelfDelegation = (_c = object.minSelfDelegation) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseMsgEditValidatorResponse = {};
    exports.MsgEditValidatorResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgEditValidatorResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgEditValidatorResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgEditValidatorResponse);
        return message;
      }
    };
    var baseMsgDelegate = { delegatorAddress: "", validatorAddress: "" };
    exports.MsgDelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgDelegate);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgDelegate);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromJSON(object.amount) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgDelegate);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    var baseMsgDelegateResponse = {};
    exports.MsgDelegateResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgDelegateResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgDelegateResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgDelegateResponse);
        return message;
      }
    };
    var baseMsgBeginRedelegate = {
      delegatorAddress: "",
      validatorSrcAddress: "",
      validatorDstAddress: ""
    };
    exports.MsgBeginRedelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgBeginRedelegate);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgBeginRedelegate);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorSrcAddress = object.validatorSrcAddress !== void 0 && object.validatorSrcAddress !== null ? String(object.validatorSrcAddress) : "";
        message.validatorDstAddress = object.validatorDstAddress !== void 0 && object.validatorDstAddress !== null ? String(object.validatorDstAddress) : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromJSON(object.amount) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseMsgBeginRedelegate);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : "";
        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    var baseMsgBeginRedelegateResponse = {};
    exports.MsgBeginRedelegateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgBeginRedelegateResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgBeginRedelegateResponse);
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? fromJsonTimestamp(object.completionTime) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseMsgBeginRedelegateResponse);
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : void 0;
        return message;
      }
    };
    var baseMsgUndelegate = { delegatorAddress: "", validatorAddress: "" };
    exports.MsgUndelegate = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgUndelegate);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgUndelegate);
        message.delegatorAddress = object.delegatorAddress !== void 0 && object.delegatorAddress !== null ? String(object.delegatorAddress) : "";
        message.validatorAddress = object.validatorAddress !== void 0 && object.validatorAddress !== null ? String(object.validatorAddress) : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromJSON(object.amount) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgUndelegate);
        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : "";
        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : "";
        message.amount = object.amount !== void 0 && object.amount !== null ? coin_1.Coin.fromPartial(object.amount) : void 0;
        return message;
      }
    };
    var baseMsgUndelegateResponse = {};
    exports.MsgUndelegateResponse = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgUndelegateResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgUndelegateResponse);
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? fromJsonTimestamp(object.completionTime) : void 0;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = fromTimestamp(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = Object.assign({}, baseMsgUndelegateResponse);
        message.completionTime = object.completionTime !== void 0 && object.completionTime !== null ? timestamp_1.Timestamp.fromPartial(object.completionTime) : void 0;
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateValidator = this.CreateValidator.bind(this);
        this.EditValidator = this.EditValidator.bind(this);
        this.Delegate = this.Delegate.bind(this);
        this.BeginRedelegate = this.BeginRedelegate.bind(this);
        this.Undelegate = this.Undelegate.bind(this);
      }
      CreateValidator(request) {
        const data = exports.MsgCreateValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", data);
        return promise.then((data2) => exports.MsgCreateValidatorResponse.decode(new minimal_1.default.Reader(data2)));
      }
      EditValidator(request) {
        const data = exports.MsgEditValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", data);
        return promise.then((data2) => exports.MsgEditValidatorResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Delegate(request) {
        const data = exports.MsgDelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", data);
        return promise.then((data2) => exports.MsgDelegateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      BeginRedelegate(request) {
        const data = exports.MsgBeginRedelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", data);
        return promise.then((data2) => exports.MsgBeginRedelegateResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Undelegate(request) {
        const data = exports.MsgUndelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", data);
        return promise.then((data2) => exports.MsgUndelegateResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return { seconds, nanos };
    }
    function fromTimestamp(t) {
      let millis = t.seconds.toNumber() * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    function fromJsonTimestamp(o) {
      if (o instanceof Date) {
        return toTimestamp(o);
      } else if (typeof o === "string") {
        return toTimestamp(new Date(o));
      } else {
        return timestamp_1.Timestamp.fromJSON(o);
      }
    }
    function numberToLong(number) {
      return long_1.default.fromNumber(number);
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js
var require_tx7 = __commonJS({
  "node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgTransferResponse = exports.MsgTransfer = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var coin_1 = require_coin();
    var client_1 = require_client();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    var baseMsgTransfer = {
      sourcePort: "",
      sourceChannel: "",
      sender: "",
      receiver: "",
      timeoutTimestamp: long_1.default.UZERO
    };
    exports.MsgTransfer = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sourcePort !== "") {
          writer.uint32(10).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(18).string(message.sourceChannel);
        }
        if (message.token !== void 0) {
          coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(42).string(message.receiver);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        }
        if (!message.timeoutTimestamp.isZero()) {
          writer.uint32(56).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgTransfer);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sourcePort = reader.string();
              break;
            case 2:
              message.sourceChannel = reader.string();
              break;
            case 3:
              message.token = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.sender = reader.string();
              break;
            case 5:
              message.receiver = reader.string();
              break;
            case 6:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.timeoutTimestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgTransfer);
        message.sourcePort = object.sourcePort !== void 0 && object.sourcePort !== null ? String(object.sourcePort) : "";
        message.sourceChannel = object.sourceChannel !== void 0 && object.sourceChannel !== null ? String(object.sourceChannel) : "";
        message.token = object.token !== void 0 && object.token !== null ? coin_1.Coin.fromJSON(object.token) : void 0;
        message.sender = object.sender !== void 0 && object.sender !== null ? String(object.sender) : "";
        message.receiver = object.receiver !== void 0 && object.receiver !== null ? String(object.receiver) : "";
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? client_1.Height.fromJSON(object.timeoutHeight) : void 0;
        message.timeoutTimestamp = object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null ? long_1.default.fromString(object.timeoutTimestamp) : long_1.default.UZERO;
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.token !== void 0 && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : void 0);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || long_1.default.UZERO).toString());
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseMsgTransfer);
        message.sourcePort = (_a = object.sourcePort) !== null && _a !== void 0 ? _a : "";
        message.sourceChannel = (_b = object.sourceChannel) !== null && _b !== void 0 ? _b : "";
        message.token = object.token !== void 0 && object.token !== null ? coin_1.Coin.fromPartial(object.token) : void 0;
        message.sender = (_c = object.sender) !== null && _c !== void 0 ? _c : "";
        message.receiver = (_d = object.receiver) !== null && _d !== void 0 ? _d : "";
        message.timeoutHeight = object.timeoutHeight !== void 0 && object.timeoutHeight !== null ? client_1.Height.fromPartial(object.timeoutHeight) : void 0;
        message.timeoutTimestamp = object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null ? long_1.default.fromValue(object.timeoutTimestamp) : long_1.default.UZERO;
        return message;
      }
    };
    var baseMsgTransferResponse = {};
    exports.MsgTransferResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgTransferResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgTransferResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgTransferResponse);
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Transfer = this.Transfer.bind(this);
      }
      Transfer(request) {
        const data = exports.MsgTransfer.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", data);
        return promise.then((data2) => exports.MsgTransferResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/channel/v1/tx.js
var require_tx8 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/channel/v1/tx.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var channel_1 = require_channel();
    var client_1 = require_client();
    exports.protobufPackage = "ibc.core.channel.v1";
    var baseMsgChannelOpenInit = { portId: "", signer: "" };
    exports.MsgChannelOpenInit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelOpenInit);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgChannelOpenInit);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromJSON(object.channel) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgChannelOpenInit);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : void 0;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgChannelOpenInitResponse = {};
    exports.MsgChannelOpenInitResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelOpenInitResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgChannelOpenInitResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgChannelOpenInitResponse);
        return message;
      }
    };
    var baseMsgChannelOpenTry = {
      portId: "",
      previousChannelId: "",
      counterpartyVersion: "",
      signer: ""
    };
    exports.MsgChannelOpenTry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.previousChannelId !== "") {
          writer.uint32(18).string(message.previousChannelId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(42).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelOpenTry);
        message.proofInit = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.previousChannelId = reader.string();
              break;
            case 3:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofInit = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgChannelOpenTry);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.previousChannelId = object.previousChannelId !== void 0 && object.previousChannelId !== null ? String(object.previousChannelId) : "";
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromJSON(object.channel) : void 0;
        message.counterpartyVersion = object.counterpartyVersion !== void 0 && object.counterpartyVersion !== null ? String(object.counterpartyVersion) : "";
        message.proofInit = object.proofInit !== void 0 && object.proofInit !== null ? bytesFromBase64(object.proofInit) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.previousChannelId !== void 0 && (obj.previousChannelId = message.previousChannelId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofInit !== void 0 && (obj.proofInit = base64FromBytes(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = Object.assign({}, baseMsgChannelOpenTry);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.previousChannelId = (_b = object.previousChannelId) !== null && _b !== void 0 ? _b : "";
        message.channel = object.channel !== void 0 && object.channel !== null ? channel_1.Channel.fromPartial(object.channel) : void 0;
        message.counterpartyVersion = (_c = object.counterpartyVersion) !== null && _c !== void 0 ? _c : "";
        message.proofInit = (_d = object.proofInit) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_e = object.signer) !== null && _e !== void 0 ? _e : "";
        return message;
      }
    };
    var baseMsgChannelOpenTryResponse = {};
    exports.MsgChannelOpenTryResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelOpenTryResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgChannelOpenTryResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgChannelOpenTryResponse);
        return message;
      }
    };
    var baseMsgChannelOpenAck = {
      portId: "",
      channelId: "",
      counterpartyChannelId: "",
      counterpartyVersion: "",
      signer: ""
    };
    exports.MsgChannelOpenAck = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelId !== "") {
          writer.uint32(26).string(message.counterpartyChannelId);
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(42).bytes(message.proofTry);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelOpenAck);
        message.proofTry = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelId = reader.string();
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofTry = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgChannelOpenAck);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.counterpartyChannelId = object.counterpartyChannelId !== void 0 && object.counterpartyChannelId !== null ? String(object.counterpartyChannelId) : "";
        message.counterpartyVersion = object.counterpartyVersion !== void 0 && object.counterpartyVersion !== null ? String(object.counterpartyVersion) : "";
        message.proofTry = object.proofTry !== void 0 && object.proofTry !== null ? bytesFromBase64(object.proofTry) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelId !== void 0 && (obj.counterpartyChannelId = message.counterpartyChannelId);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofTry !== void 0 && (obj.proofTry = base64FromBytes(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = Object.assign({}, baseMsgChannelOpenAck);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.counterpartyChannelId = (_c = object.counterpartyChannelId) !== null && _c !== void 0 ? _c : "";
        message.counterpartyVersion = (_d = object.counterpartyVersion) !== null && _d !== void 0 ? _d : "";
        message.proofTry = (_e = object.proofTry) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    var baseMsgChannelOpenAckResponse = {};
    exports.MsgChannelOpenAckResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelOpenAckResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgChannelOpenAckResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgChannelOpenAckResponse);
        return message;
      }
    };
    var baseMsgChannelOpenConfirm = { portId: "", channelId: "", signer: "" };
    exports.MsgChannelOpenConfirm = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(26).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelOpenConfirm);
        message.proofAck = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofAck = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgChannelOpenConfirm);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.proofAck = object.proofAck !== void 0 && object.proofAck !== null ? bytesFromBase64(object.proofAck) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofAck !== void 0 && (obj.proofAck = base64FromBytes(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseMsgChannelOpenConfirm);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.proofAck = (_c = object.proofAck) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    var baseMsgChannelOpenConfirmResponse = {};
    exports.MsgChannelOpenConfirmResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);
        return message;
      }
    };
    var baseMsgChannelCloseInit = { portId: "", channelId: "", signer: "" };
    exports.MsgChannelCloseInit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelCloseInit);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgChannelCloseInit);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseMsgChannelCloseInit);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseMsgChannelCloseInitResponse = {};
    exports.MsgChannelCloseInitResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelCloseInitResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgChannelCloseInitResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgChannelCloseInitResponse);
        return message;
      }
    };
    var baseMsgChannelCloseConfirm = { portId: "", channelId: "", signer: "" };
    exports.MsgChannelCloseConfirm = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(26).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelCloseConfirm);
        message.proofInit = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofInit = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgChannelCloseConfirm);
        message.portId = object.portId !== void 0 && object.portId !== null ? String(object.portId) : "";
        message.channelId = object.channelId !== void 0 && object.channelId !== null ? String(object.channelId) : "";
        message.proofInit = object.proofInit !== void 0 && object.proofInit !== null ? bytesFromBase64(object.proofInit) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofInit !== void 0 && (obj.proofInit = base64FromBytes(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseMsgChannelCloseConfirm);
        message.portId = (_a = object.portId) !== null && _a !== void 0 ? _a : "";
        message.channelId = (_b = object.channelId) !== null && _b !== void 0 ? _b : "";
        message.proofInit = (_c = object.proofInit) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    var baseMsgChannelCloseConfirmResponse = {};
    exports.MsgChannelCloseConfirmResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);
        return message;
      }
    };
    var baseMsgRecvPacket = { signer: "" };
    exports.MsgRecvPacket = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofCommitment.length !== 0) {
          writer.uint32(18).bytes(message.proofCommitment);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRecvPacket);
        message.proofCommitment = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofCommitment = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgRecvPacket);
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromJSON(object.packet) : void 0;
        message.proofCommitment = object.proofCommitment !== void 0 && object.proofCommitment !== null ? bytesFromBase64(object.proofCommitment) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofCommitment !== void 0 && (obj.proofCommitment = base64FromBytes(message.proofCommitment !== void 0 ? message.proofCommitment : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgRecvPacket);
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : void 0;
        message.proofCommitment = (_a = object.proofCommitment) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgRecvPacketResponse = {};
    exports.MsgRecvPacketResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgRecvPacketResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgRecvPacketResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgRecvPacketResponse);
        return message;
      }
    };
    var baseMsgTimeout = { nextSequenceRecv: long_1.default.UZERO, signer: "" };
    exports.MsgTimeout = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (!message.nextSequenceRecv.isZero()) {
          writer.uint32(32).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgTimeout);
        message.proofUnreceived = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgTimeout);
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromJSON(object.packet) : void 0;
        message.proofUnreceived = object.proofUnreceived !== void 0 && object.proofUnreceived !== null ? bytesFromBase64(object.proofUnreceived) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.nextSequenceRecv = object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null ? long_1.default.fromString(object.nextSequenceRecv) : long_1.default.UZERO;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgTimeout);
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : void 0;
        message.proofUnreceived = (_a = object.proofUnreceived) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.nextSequenceRecv = object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgTimeoutResponse = {};
    exports.MsgTimeoutResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgTimeoutResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgTimeoutResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgTimeoutResponse);
        return message;
      }
    };
    var baseMsgTimeoutOnClose = { nextSequenceRecv: long_1.default.UZERO, signer: "" };
    exports.MsgTimeoutOnClose = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofClose.length !== 0) {
          writer.uint32(26).bytes(message.proofClose);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (!message.nextSequenceRecv.isZero()) {
          writer.uint32(40).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgTimeoutOnClose);
        message.proofUnreceived = new Uint8Array();
        message.proofClose = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofClose = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgTimeoutOnClose);
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromJSON(object.packet) : void 0;
        message.proofUnreceived = object.proofUnreceived !== void 0 && object.proofUnreceived !== null ? bytesFromBase64(object.proofUnreceived) : new Uint8Array();
        message.proofClose = object.proofClose !== void 0 && object.proofClose !== null ? bytesFromBase64(object.proofClose) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.nextSequenceRecv = object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null ? long_1.default.fromString(object.nextSequenceRecv) : long_1.default.UZERO;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofClose !== void 0 && (obj.proofClose = base64FromBytes(message.proofClose !== void 0 ? message.proofClose : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseMsgTimeoutOnClose);
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : void 0;
        message.proofUnreceived = (_a = object.proofUnreceived) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofClose = (_b = object.proofClose) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.nextSequenceRecv = object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null ? long_1.default.fromValue(object.nextSequenceRecv) : long_1.default.UZERO;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseMsgTimeoutOnCloseResponse = {};
    exports.MsgTimeoutOnCloseResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);
        return message;
      }
    };
    var baseMsgAcknowledgement = { signer: "" };
    exports.MsgAcknowledgement = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.acknowledgement.length !== 0) {
          writer.uint32(18).bytes(message.acknowledgement);
        }
        if (message.proofAcked.length !== 0) {
          writer.uint32(26).bytes(message.proofAcked);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgAcknowledgement);
        message.acknowledgement = new Uint8Array();
        message.proofAcked = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.acknowledgement = reader.bytes();
              break;
            case 3:
              message.proofAcked = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgAcknowledgement);
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromJSON(object.packet) : void 0;
        message.acknowledgement = object.acknowledgement !== void 0 && object.acknowledgement !== null ? bytesFromBase64(object.acknowledgement) : new Uint8Array();
        message.proofAcked = object.proofAcked !== void 0 && object.proofAcked !== null ? bytesFromBase64(object.proofAcked) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.acknowledgement !== void 0 && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proofAcked !== void 0 && (obj.proofAcked = base64FromBytes(message.proofAcked !== void 0 ? message.proofAcked : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseMsgAcknowledgement);
        message.packet = object.packet !== void 0 && object.packet !== null ? channel_1.Packet.fromPartial(object.packet) : void 0;
        message.acknowledgement = (_a = object.acknowledgement) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.proofAcked = (_b = object.proofAcked) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseMsgAcknowledgementResponse = {};
    exports.MsgAcknowledgementResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgAcknowledgementResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgAcknowledgementResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgAcknowledgementResponse);
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ChannelOpenInit = this.ChannelOpenInit.bind(this);
        this.ChannelOpenTry = this.ChannelOpenTry.bind(this);
        this.ChannelOpenAck = this.ChannelOpenAck.bind(this);
        this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);
        this.ChannelCloseInit = this.ChannelCloseInit.bind(this);
        this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);
        this.RecvPacket = this.RecvPacket.bind(this);
        this.Timeout = this.Timeout.bind(this);
        this.TimeoutOnClose = this.TimeoutOnClose.bind(this);
        this.Acknowledgement = this.Acknowledgement.bind(this);
      }
      ChannelOpenInit(request) {
        const data = exports.MsgChannelOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", data);
        return promise.then((data2) => exports.MsgChannelOpenInitResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelOpenTry(request) {
        const data = exports.MsgChannelOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", data);
        return promise.then((data2) => exports.MsgChannelOpenTryResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelOpenAck(request) {
        const data = exports.MsgChannelOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", data);
        return promise.then((data2) => exports.MsgChannelOpenAckResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelOpenConfirm(request) {
        const data = exports.MsgChannelOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", data);
        return promise.then((data2) => exports.MsgChannelOpenConfirmResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelCloseInit(request) {
        const data = exports.MsgChannelCloseInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", data);
        return promise.then((data2) => exports.MsgChannelCloseInitResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ChannelCloseConfirm(request) {
        const data = exports.MsgChannelCloseConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", data);
        return promise.then((data2) => exports.MsgChannelCloseConfirmResponse.decode(new minimal_1.default.Reader(data2)));
      }
      RecvPacket(request) {
        const data = exports.MsgRecvPacket.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", data);
        return promise.then((data2) => exports.MsgRecvPacketResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Timeout(request) {
        const data = exports.MsgTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", data);
        return promise.then((data2) => exports.MsgTimeoutResponse.decode(new minimal_1.default.Reader(data2)));
      }
      TimeoutOnClose(request) {
        const data = exports.MsgTimeoutOnClose.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", data);
        return promise.then((data2) => exports.MsgTimeoutOnCloseResponse.decode(new minimal_1.default.Reader(data2)));
      }
      Acknowledgement(request) {
        const data = exports.MsgAcknowledgement.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", data);
        return promise.then((data2) => exports.MsgAcknowledgementResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/client/v1/tx.js
var require_tx9 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/client/v1/tx.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgSubmitMisbehaviourResponse = exports.MsgSubmitMisbehaviour = exports.MsgUpgradeClientResponse = exports.MsgUpgradeClient = exports.MsgUpdateClientResponse = exports.MsgUpdateClient = exports.MsgCreateClientResponse = exports.MsgCreateClient = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var any_1 = require_any();
    exports.protobufPackage = "ibc.core.client.v1";
    var baseMsgCreateClient = { signer: "" };
    exports.MsgCreateClient = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgCreateClient);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgCreateClient);
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromJSON(object.clientState) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromJSON(object.consensusState) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a;
        const message = Object.assign({}, baseMsgCreateClient);
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        return message;
      }
    };
    var baseMsgCreateClientResponse = {};
    exports.MsgCreateClientResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgCreateClientResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgCreateClientResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgCreateClientResponse);
        return message;
      }
    };
    var baseMsgUpdateClient = { clientId: "", signer: "" };
    exports.MsgUpdateClient = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.header !== void 0) {
          any_1.Any.encode(message.header, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgUpdateClient);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.header = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgUpdateClient);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.header = object.header !== void 0 && object.header !== null ? any_1.Any.fromJSON(object.header) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header !== void 0 && (obj.header = message.header ? any_1.Any.toJSON(message.header) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgUpdateClient);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.header = object.header !== void 0 && object.header !== null ? any_1.Any.fromPartial(object.header) : void 0;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgUpdateClientResponse = {};
    exports.MsgUpdateClientResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgUpdateClientResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgUpdateClientResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgUpdateClientResponse);
        return message;
      }
    };
    var baseMsgUpgradeClient = { clientId: "", signer: "" };
    exports.MsgUpgradeClient = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofUpgradeClient.length !== 0) {
          writer.uint32(34).bytes(message.proofUpgradeClient);
        }
        if (message.proofUpgradeConsensusState.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgradeConsensusState);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgUpgradeClient);
        message.proofUpgradeClient = new Uint8Array();
        message.proofUpgradeConsensusState = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofUpgradeClient = reader.bytes();
              break;
            case 5:
              message.proofUpgradeConsensusState = reader.bytes();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgUpgradeClient);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromJSON(object.clientState) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromJSON(object.consensusState) : void 0;
        message.proofUpgradeClient = object.proofUpgradeClient !== void 0 && object.proofUpgradeClient !== null ? bytesFromBase64(object.proofUpgradeClient) : new Uint8Array();
        message.proofUpgradeConsensusState = object.proofUpgradeConsensusState !== void 0 && object.proofUpgradeConsensusState !== null ? bytesFromBase64(object.proofUpgradeConsensusState) : new Uint8Array();
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proofUpgradeClient !== void 0 && (obj.proofUpgradeClient = base64FromBytes(message.proofUpgradeClient !== void 0 ? message.proofUpgradeClient : new Uint8Array()));
        message.proofUpgradeConsensusState !== void 0 && (obj.proofUpgradeConsensusState = base64FromBytes(message.proofUpgradeConsensusState !== void 0 ? message.proofUpgradeConsensusState : new Uint8Array()));
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d;
        const message = Object.assign({}, baseMsgUpgradeClient);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.consensusState = object.consensusState !== void 0 && object.consensusState !== null ? any_1.Any.fromPartial(object.consensusState) : void 0;
        message.proofUpgradeClient = (_b = object.proofUpgradeClient) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofUpgradeConsensusState = (_c = object.proofUpgradeConsensusState) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.signer = (_d = object.signer) !== null && _d !== void 0 ? _d : "";
        return message;
      }
    };
    var baseMsgUpgradeClientResponse = {};
    exports.MsgUpgradeClientResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgUpgradeClientResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgUpgradeClientResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgUpgradeClientResponse);
        return message;
      }
    };
    var baseMsgSubmitMisbehaviour = { clientId: "", signer: "" };
    exports.MsgSubmitMisbehaviour = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.misbehaviour !== void 0) {
          any_1.Any.encode(message.misbehaviour, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgSubmitMisbehaviour);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.misbehaviour = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgSubmitMisbehaviour);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.misbehaviour = object.misbehaviour !== void 0 && object.misbehaviour !== null ? any_1.Any.fromJSON(object.misbehaviour) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.misbehaviour !== void 0 && (obj.misbehaviour = message.misbehaviour ? any_1.Any.toJSON(message.misbehaviour) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgSubmitMisbehaviour);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.misbehaviour = object.misbehaviour !== void 0 && object.misbehaviour !== null ? any_1.Any.fromPartial(object.misbehaviour) : void 0;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgSubmitMisbehaviourResponse = {};
    exports.MsgSubmitMisbehaviourResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgSubmitMisbehaviourResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgSubmitMisbehaviourResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgSubmitMisbehaviourResponse);
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateClient = this.CreateClient.bind(this);
        this.UpdateClient = this.UpdateClient.bind(this);
        this.UpgradeClient = this.UpgradeClient.bind(this);
        this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
      }
      CreateClient(request) {
        const data = exports.MsgCreateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", data);
        return promise.then((data2) => exports.MsgCreateClientResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UpdateClient(request) {
        const data = exports.MsgUpdateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", data);
        return promise.then((data2) => exports.MsgUpdateClientResponse.decode(new minimal_1.default.Reader(data2)));
      }
      UpgradeClient(request) {
        const data = exports.MsgUpgradeClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", data);
        return promise.then((data2) => exports.MsgUpgradeClientResponse.decode(new minimal_1.default.Reader(data2)));
      }
      SubmitMisbehaviour(request) {
        const data = exports.MsgSubmitMisbehaviour.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", data);
        return promise.then((data2) => exports.MsgSubmitMisbehaviourResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/cosmjs-types/ibc/core/connection/v1/tx.js
var require_tx10 = __commonJS({
  "node_modules/cosmjs-types/ibc/core/connection/v1/tx.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgConnectionOpenConfirmResponse = exports.MsgConnectionOpenConfirm = exports.MsgConnectionOpenAckResponse = exports.MsgConnectionOpenAck = exports.MsgConnectionOpenTryResponse = exports.MsgConnectionOpenTry = exports.MsgConnectionOpenInitResponse = exports.MsgConnectionOpenInit = exports.protobufPackage = void 0;
    var long_1 = __importDefault(require_long());
    var minimal_1 = __importDefault(require_minimal());
    var connection_1 = require_connection();
    var any_1 = require_any();
    var client_1 = require_client();
    exports.protobufPackage = "ibc.core.connection.v1";
    var baseMsgConnectionOpenInit = { clientId: "", delayPeriod: long_1.default.UZERO, signer: "" };
    exports.MsgConnectionOpenInit = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (!message.delayPeriod.isZero()) {
          writer.uint32(32).uint64(message.delayPeriod);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgConnectionOpenInit);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.delayPeriod = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgConnectionOpenInit);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? connection_1.Counterparty.fromJSON(object.counterparty) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? connection_1.Version.fromJSON(object.version) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromString(object.delayPeriod) : long_1.default.UZERO;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b;
        const message = Object.assign({}, baseMsgConnectionOpenInit);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? connection_1.Counterparty.fromPartial(object.counterparty) : void 0;
        message.version = object.version !== void 0 && object.version !== null ? connection_1.Version.fromPartial(object.version) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO;
        message.signer = (_b = object.signer) !== null && _b !== void 0 ? _b : "";
        return message;
      }
    };
    var baseMsgConnectionOpenInitResponse = {};
    exports.MsgConnectionOpenInitResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgConnectionOpenInitResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgConnectionOpenInitResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgConnectionOpenInitResponse);
        return message;
      }
    };
    var baseMsgConnectionOpenTry = {
      clientId: "",
      previousConnectionId: "",
      delayPeriod: long_1.default.UZERO,
      signer: ""
    };
    exports.MsgConnectionOpenTry = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.previousConnectionId !== "") {
          writer.uint32(18).string(message.previousConnectionId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (!message.delayPeriod.isZero()) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        for (const v of message.counterpartyVersions) {
          connection_1.Version.encode(v, writer.uint32(50).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(66).bytes(message.proofInit);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(74).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(82).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(98).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgConnectionOpenTry);
        message.counterpartyVersions = [];
        message.proofInit = new Uint8Array();
        message.proofClient = new Uint8Array();
        message.proofConsensus = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.previousConnectionId = reader.string();
              break;
            case 3:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            case 6:
              message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofInit = reader.bytes();
              break;
            case 9:
              message.proofClient = reader.bytes();
              break;
            case 10:
              message.proofConsensus = reader.bytes();
              break;
            case 11:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 12:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        var _a;
        const message = Object.assign({}, baseMsgConnectionOpenTry);
        message.clientId = object.clientId !== void 0 && object.clientId !== null ? String(object.clientId) : "";
        message.previousConnectionId = object.previousConnectionId !== void 0 && object.previousConnectionId !== null ? String(object.previousConnectionId) : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromJSON(object.clientState) : void 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? connection_1.Counterparty.fromJSON(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromString(object.delayPeriod) : long_1.default.UZERO;
        message.counterpartyVersions = ((_a = object.counterpartyVersions) !== null && _a !== void 0 ? _a : []).map((e) => connection_1.Version.fromJSON(e));
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.proofInit = object.proofInit !== void 0 && object.proofInit !== null ? bytesFromBase64(object.proofInit) : new Uint8Array();
        message.proofClient = object.proofClient !== void 0 && object.proofClient !== null ? bytesFromBase64(object.proofClient) : new Uint8Array();
        message.proofConsensus = object.proofConsensus !== void 0 && object.proofConsensus !== null ? bytesFromBase64(object.proofConsensus) : new Uint8Array();
        message.consensusHeight = object.consensusHeight !== void 0 && object.consensusHeight !== null ? client_1.Height.fromJSON(object.consensusHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.previousConnectionId !== void 0 && (obj.previousConnectionId = message.previousConnectionId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());
        if (message.counterpartyVersions) {
          obj.counterpartyVersions = message.counterpartyVersions.map((e) => e ? connection_1.Version.toJSON(e) : void 0);
        } else {
          obj.counterpartyVersions = [];
        }
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofInit !== void 0 && (obj.proofInit = base64FromBytes(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = base64FromBytes(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = base64FromBytes(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = Object.assign({}, baseMsgConnectionOpenTry);
        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : "";
        message.previousConnectionId = (_b = object.previousConnectionId) !== null && _b !== void 0 ? _b : "";
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.counterparty = object.counterparty !== void 0 && object.counterparty !== null ? connection_1.Counterparty.fromPartial(object.counterparty) : void 0;
        message.delayPeriod = object.delayPeriod !== void 0 && object.delayPeriod !== null ? long_1.default.fromValue(object.delayPeriod) : long_1.default.UZERO;
        message.counterpartyVersions = ((_c = object.counterpartyVersions) === null || _c === void 0 ? void 0 : _c.map((e) => connection_1.Version.fromPartial(e))) || [];
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.proofInit = (_d = object.proofInit) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.proofClient = (_e = object.proofClient) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.proofConsensus = (_f = object.proofConsensus) !== null && _f !== void 0 ? _f : new Uint8Array();
        message.consensusHeight = object.consensusHeight !== void 0 && object.consensusHeight !== null ? client_1.Height.fromPartial(object.consensusHeight) : void 0;
        message.signer = (_g = object.signer) !== null && _g !== void 0 ? _g : "";
        return message;
      }
    };
    var baseMsgConnectionOpenTryResponse = {};
    exports.MsgConnectionOpenTryResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgConnectionOpenTryResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgConnectionOpenTryResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgConnectionOpenTryResponse);
        return message;
      }
    };
    var baseMsgConnectionOpenAck = { connectionId: "", counterpartyConnectionId: "", signer: "" };
    exports.MsgConnectionOpenAck = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.counterpartyConnectionId !== "") {
          writer.uint32(18).string(message.counterpartyConnectionId);
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(50).bytes(message.proofTry);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(58).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(66).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(82).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgConnectionOpenAck);
        message.proofTry = new Uint8Array();
        message.proofClient = new Uint8Array();
        message.proofConsensus = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.counterpartyConnectionId = reader.string();
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.proofTry = reader.bytes();
              break;
            case 7:
              message.proofClient = reader.bytes();
              break;
            case 8:
              message.proofConsensus = reader.bytes();
              break;
            case 9:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 10:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgConnectionOpenAck);
        message.connectionId = object.connectionId !== void 0 && object.connectionId !== null ? String(object.connectionId) : "";
        message.counterpartyConnectionId = object.counterpartyConnectionId !== void 0 && object.counterpartyConnectionId !== null ? String(object.counterpartyConnectionId) : "";
        message.version = object.version !== void 0 && object.version !== null ? connection_1.Version.fromJSON(object.version) : void 0;
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromJSON(object.clientState) : void 0;
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.proofTry = object.proofTry !== void 0 && object.proofTry !== null ? bytesFromBase64(object.proofTry) : new Uint8Array();
        message.proofClient = object.proofClient !== void 0 && object.proofClient !== null ? bytesFromBase64(object.proofClient) : new Uint8Array();
        message.proofConsensus = object.proofConsensus !== void 0 && object.proofConsensus !== null ? bytesFromBase64(object.proofConsensus) : new Uint8Array();
        message.consensusHeight = object.consensusHeight !== void 0 && object.consensusHeight !== null ? client_1.Height.fromJSON(object.consensusHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.counterpartyConnectionId !== void 0 && (obj.counterpartyConnectionId = message.counterpartyConnectionId);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofTry !== void 0 && (obj.proofTry = base64FromBytes(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = base64FromBytes(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = base64FromBytes(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = Object.assign({}, baseMsgConnectionOpenAck);
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        message.counterpartyConnectionId = (_b = object.counterpartyConnectionId) !== null && _b !== void 0 ? _b : "";
        message.version = object.version !== void 0 && object.version !== null ? connection_1.Version.fromPartial(object.version) : void 0;
        message.clientState = object.clientState !== void 0 && object.clientState !== null ? any_1.Any.fromPartial(object.clientState) : void 0;
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.proofTry = (_c = object.proofTry) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.proofClient = (_d = object.proofClient) !== null && _d !== void 0 ? _d : new Uint8Array();
        message.proofConsensus = (_e = object.proofConsensus) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.consensusHeight = object.consensusHeight !== void 0 && object.consensusHeight !== null ? client_1.Height.fromPartial(object.consensusHeight) : void 0;
        message.signer = (_f = object.signer) !== null && _f !== void 0 ? _f : "";
        return message;
      }
    };
    var baseMsgConnectionOpenAckResponse = {};
    exports.MsgConnectionOpenAckResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgConnectionOpenAckResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgConnectionOpenAckResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgConnectionOpenAckResponse);
        return message;
      }
    };
    var baseMsgConnectionOpenConfirm = { connectionId: "", signer: "" };
    exports.MsgConnectionOpenConfirm = {
      encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(18).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgConnectionOpenConfirm);
        message.proofAck = new Uint8Array();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.proofAck = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const message = Object.assign({}, baseMsgConnectionOpenConfirm);
        message.connectionId = object.connectionId !== void 0 && object.connectionId !== null ? String(object.connectionId) : "";
        message.proofAck = object.proofAck !== void 0 && object.proofAck !== null ? bytesFromBase64(object.proofAck) : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromJSON(object.proofHeight) : void 0;
        message.signer = object.signer !== void 0 && object.signer !== null ? String(object.signer) : "";
        return message;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.proofAck !== void 0 && (obj.proofAck = base64FromBytes(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        var _a, _b, _c;
        const message = Object.assign({}, baseMsgConnectionOpenConfirm);
        message.connectionId = (_a = object.connectionId) !== null && _a !== void 0 ? _a : "";
        message.proofAck = (_b = object.proofAck) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.proofHeight = object.proofHeight !== void 0 && object.proofHeight !== null ? client_1.Height.fromPartial(object.proofHeight) : void 0;
        message.signer = (_c = object.signer) !== null && _c !== void 0 ? _c : "";
        return message;
      }
    };
    var baseMsgConnectionOpenConfirmResponse = {};
    exports.MsgConnectionOpenConfirmResponse = {
      encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_) {
        const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);
        return message;
      },
      toJSON(_) {
        const obj = {};
        return obj;
      },
      fromPartial(_) {
        const message = Object.assign({}, baseMsgConnectionOpenConfirmResponse);
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);
        this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);
        this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);
        this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
      }
      ConnectionOpenInit(request) {
        const data = exports.MsgConnectionOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", data);
        return promise.then((data2) => exports.MsgConnectionOpenInitResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionOpenTry(request) {
        const data = exports.MsgConnectionOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", data);
        return promise.then((data2) => exports.MsgConnectionOpenTryResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionOpenAck(request) {
        const data = exports.MsgConnectionOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", data);
        return promise.then((data2) => exports.MsgConnectionOpenAckResponse.decode(new minimal_1.default.Reader(data2)));
      }
      ConnectionOpenConfirm(request) {
        const data = exports.MsgConnectionOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", data);
        return promise.then((data2) => exports.MsgConnectionOpenConfirmResponse.decode(new minimal_1.default.Reader(data2)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof define_global_default !== "undefined")
        return define_global_default;
      throw "Unable to locate global object";
    })();
    var atob = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob(b64);
      const arr = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
      }
      return arr;
    }
    var btoa = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
      }
      return btoa(bin.join(""));
    }
    if (minimal_1.default.util.Long !== long_1.default) {
      minimal_1.default.util.Long = long_1.default;
      minimal_1.default.configure();
    }
  }
});

// node_modules/@cosmjs/stargate/build/stargateclient.js
var require_stargateclient = __commonJS({
  "node_modules/@cosmjs/stargate/build/stargateclient.js"(exports) {
    init_define_global();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StargateClient = exports.assertIsDeliverTxFailure = exports.assertIsDeliverTxSuccess = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.TimeoutError = void 0;
    var encoding_1 = require_build();
    var math_1 = require_build3();
    var tendermint_rpc_1 = require_build11();
    var utils_1 = require_build2();
    var accounts_1 = require_accounts();
    var queries_1 = require_queries();
    var search_1 = require_search();
    var TimeoutError = class extends Error {
      constructor(message, txId) {
        super(message);
        this.txId = txId;
      }
    };
    exports.TimeoutError = TimeoutError;
    function isDeliverTxFailure(result) {
      return !!result.code;
    }
    exports.isDeliverTxFailure = isDeliverTxFailure;
    function isDeliverTxSuccess(result) {
      return !isDeliverTxFailure(result);
    }
    exports.isDeliverTxSuccess = isDeliverTxSuccess;
    function assertIsDeliverTxSuccess(result) {
      if (isDeliverTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    exports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
    function assertIsDeliverTxFailure(result) {
      if (isDeliverTxSuccess(result)) {
        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    exports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
    var StargateClient = class {
      constructor(tmClient) {
        if (tmClient) {
          this.tmClient = tmClient;
          this.queryClient = queries_1.QueryClient.withExtensions(tmClient, queries_1.setupAuthExtension, queries_1.setupBankExtension, queries_1.setupStakingExtension, queries_1.setupTxExtension);
        }
      }
      static async connect(endpoint) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new StargateClient(tmClient);
      }
      getTmClient() {
        return this.tmClient;
      }
      forceGetTmClient() {
        if (!this.tmClient) {
          throw new Error("Tendermint client not available. You cannot use online functionality in offline mode.");
        }
        return this.tmClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetTmClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetTmClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? (0, accounts_1.accountFromAny)(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error("Account does not exist on chain. Send some tokens there before trying to query sequence.");
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetTmClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
      }
      async getDelegation(delegatorAddress, validatorAddress) {
        var _a;
        let delegatedAmount;
        try {
          delegatedAmount = (_a = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse) === null || _a === void 0 ? void 0 : _a.balance;
        } catch (e) {
          if (e.toString().includes("key not found")) {
          } else {
            throw e;
          }
        }
        return delegatedAmount || null;
      }
      async getTx(id) {
        var _a;
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return (_a = results[0]) !== null && _a !== void 0 ? _a : null;
      }
      async searchTx(query, filter = {}) {
        const minHeight = filter.minHeight || 0;
        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;
        if (maxHeight < minHeight)
          return [];
        function withFilters(originalQuery) {
          return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;
        }
        let txs;
        if ((0, search_1.isSearchByHeightQuery)(query)) {
          txs = query.height >= minHeight && query.height <= maxHeight ? await this.txsQuery(`tx.height=${query.height}`) : [];
        } else if ((0, search_1.isSearchBySentFromOrToQuery)(query)) {
          const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);
          const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);
          const [sent, received] = await Promise.all([sentQuery, receivedQuery].map((rawQuery) => this.txsQuery(rawQuery)));
          const sentHashes = sent.map((t) => t.hash);
          txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];
        } else if ((0, search_1.isSearchByTagsQuery)(query)) {
          const rawQuery = withFilters(query.tags.map((t) => `${t.key}='${t.value}'`).join(" AND "));
          txs = await this.txsQuery(rawQuery);
        } else {
          throw new Error("Unknown query type");
        }
        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);
        return filtered;
      }
      disconnect() {
        if (this.tmClient)
          this.tmClient.disconnect();
      }
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            rawLog: result.rawLog,
            transactionHash: txId,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const broadcasted = await this.forceGetTmClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          throw new Error(`Broadcasting transaction failed with code ${broadcasted.code} (codespace: ${broadcasted.codeSpace}). Log: ${broadcasted.log}`);
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      async txsQuery(query) {
        const results = await this.forceGetTmClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          return {
            height: tx.height,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            rawLog: tx.result.log || "",
            tx: tx.tx,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports.StargateClient = StargateClient;
  }
});

// node_modules/@cosmjs/stargate/build/signingstargateclient.js
var require_signingstargateclient = __commonJS({
  "node_modules/@cosmjs/stargate/build/signingstargateclient.js"(exports) {
    init_define_global();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningStargateClient = exports.defaultRegistryTypes = void 0;
    var amino_1 = require_build5();
    var encoding_1 = require_build();
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    var tendermint_rpc_1 = require_build11();
    var utils_1 = require_build2();
    var tx_1 = require_tx2();
    var tx_2 = require_tx4();
    var tx_3 = require_tx5();
    var tx_4 = require_tx6();
    var signing_1 = require_signing();
    var tx_5 = require_tx();
    var tx_6 = require_tx7();
    var tx_7 = require_tx8();
    var tx_8 = require_tx9();
    var tx_9 = require_tx10();
    var long_1 = __importDefault(require_long());
    var aminotypes_1 = require_aminotypes();
    var fee_1 = require_fee();
    var stargateclient_1 = require_stargateclient();
    exports.defaultRegistryTypes = [
      ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
      ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_2.MsgFundCommunityPool],
      ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_2.MsgSetWithdrawAddress],
      ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_2.MsgWithdrawDelegatorReward],
      ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_2.MsgWithdrawValidatorCommission],
      ["/cosmos.gov.v1beta1.MsgDeposit", tx_3.MsgDeposit],
      ["/cosmos.gov.v1beta1.MsgSubmitProposal", tx_3.MsgSubmitProposal],
      ["/cosmos.gov.v1beta1.MsgVote", tx_3.MsgVote],
      ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_4.MsgBeginRedelegate],
      ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_4.MsgCreateValidator],
      ["/cosmos.staking.v1beta1.MsgDelegate", tx_4.MsgDelegate],
      ["/cosmos.staking.v1beta1.MsgEditValidator", tx_4.MsgEditValidator],
      ["/cosmos.staking.v1beta1.MsgUndelegate", tx_4.MsgUndelegate],
      ["/ibc.core.channel.v1.MsgChannelOpenInit", tx_7.MsgChannelOpenInit],
      ["/ibc.core.channel.v1.MsgChannelOpenTry", tx_7.MsgChannelOpenTry],
      ["/ibc.core.channel.v1.MsgChannelOpenAck", tx_7.MsgChannelOpenAck],
      ["/ibc.core.channel.v1.MsgChannelOpenConfirm", tx_7.MsgChannelOpenConfirm],
      ["/ibc.core.channel.v1.MsgChannelCloseInit", tx_7.MsgChannelCloseInit],
      ["/ibc.core.channel.v1.MsgChannelCloseConfirm", tx_7.MsgChannelCloseConfirm],
      ["/ibc.core.channel.v1.MsgRecvPacket", tx_7.MsgRecvPacket],
      ["/ibc.core.channel.v1.MsgTimeout", tx_7.MsgTimeout],
      ["/ibc.core.channel.v1.MsgTimeoutOnClose", tx_7.MsgTimeoutOnClose],
      ["/ibc.core.channel.v1.MsgAcknowledgement", tx_7.MsgAcknowledgement],
      ["/ibc.core.client.v1.MsgCreateClient", tx_8.MsgCreateClient],
      ["/ibc.core.client.v1.MsgUpdateClient", tx_8.MsgUpdateClient],
      ["/ibc.core.client.v1.MsgUpgradeClient", tx_8.MsgUpgradeClient],
      ["/ibc.core.client.v1.MsgSubmitMisbehaviour", tx_8.MsgSubmitMisbehaviour],
      ["/ibc.core.connection.v1.MsgConnectionOpenInit", tx_9.MsgConnectionOpenInit],
      ["/ibc.core.connection.v1.MsgConnectionOpenTry", tx_9.MsgConnectionOpenTry],
      ["/ibc.core.connection.v1.MsgConnectionOpenAck", tx_9.MsgConnectionOpenAck],
      ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", tx_9.MsgConnectionOpenConfirm],
      ["/ibc.applications.transfer.v1.MsgTransfer", tx_6.MsgTransfer]
    ];
    function createDefaultRegistry() {
      return new proto_signing_1.Registry(exports.defaultRegistryTypes);
    }
    var SigningStargateClient = class extends stargateclient_1.StargateClient {
      constructor(tmClient, signer, options) {
        super(tmClient);
        const { registry = createDefaultRegistry(), aminoTypes = new aminotypes_1.AminoTypes({ prefix: options.prefix }) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      static async connectWithSigner(endpoint, signer, options = {}) {
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        return new SigningStargateClient(tmClient, signer, options);
      }
      static async offline(signer, options = {}) {
        return new SigningStargateClient(void 0, signer, options);
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m) => this.registry.encodeAsAny(m));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_4.MsgDelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_4.MsgUndelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_2.MsgWithdrawDelegatorReward.fromPartial({
            delegatorAddress,
            validatorAddress
          })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
      }
      async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? long_1.default.fromNumber(timeoutTimestamp).multiply(1e9) : void 0;
        const transferMsg = {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: tx_6.MsgTransfer.fromPartial({
            sourcePort,
            sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: transferAmount,
            timeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds
          })
        };
        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
      }
      async signAndBroadcast(signerAddress, messages, fee, memo = "") {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const muliplier = typeof fee === "number" ? fee : 1.3;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * muliplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo);
        const txBytes = tx_5.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      async sign(signerAddress, messages, fee, memo, explicitSignerData) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData) : this.signAmino(signerAddress, messages, fee, memo, signerData);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
          memo: signed.memo
        };
        const signedTxBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signMode);
        return tx_5.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo
          }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_5.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports.SigningStargateClient = SigningStargateClient;
  }
});

// node_modules/@cosmjs/stargate/build/index.js
var require_build12 = __commonJS({
  "node_modules/@cosmjs/stargate/build/index.js"(exports) {
    init_define_global();
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertIsDeliverTxSuccess = exports.assertIsDeliverTxFailure = exports.SigningStargateClient = exports.defaultRegistryTypes = exports.isSearchByTagsQuery = exports.isSearchBySentFromOrToQuery = exports.isSearchByHeightQuery = exports.setupTxExtension = exports.setupStakingExtension = exports.setupMintExtension = exports.setupIbcExtension = exports.setupGovExtension = exports.setupDistributionExtension = exports.setupBankExtension = exports.setupAuthExtension = exports.QueryClient = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.makeMultisignedTx = exports.logs = exports.GasPrice = exports.calculateFee = exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgTransferEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgSendEncodeObject = exports.isMsgDepositEncodeObject = exports.isMsgDelegateEncodeObject = exports.AminoTypes = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgVote = exports.isAminoMsgVerifyInvariant = exports.isAminoMsgUnjail = exports.isAminoMsgUndelegate = exports.isAminoMsgSubmitProposal = exports.isAminoMsgSubmitEvidence = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgEditValidator = exports.isAminoMsgDeposit = exports.isAminoMsgDelegate = exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.accountFromAny = void 0;
    exports.parseCoins = exports.makeCosmoshubPath = exports.coins = exports.coin = exports.TimeoutError = exports.StargateClient = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = void 0;
    var accounts_1 = require_accounts();
    Object.defineProperty(exports, "accountFromAny", { enumerable: true, get: function() {
      return accounts_1.accountFromAny;
    } });
    var aminomsgs_1 = require_aminomsgs();
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgSubmitEvidence;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgUndelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgUnjail;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgVerifyInvariant;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return aminomsgs_1.isAminoMsgWithdrawValidatorCommission;
    } });
    var aminotypes_1 = require_aminotypes();
    Object.defineProperty(exports, "AminoTypes", { enumerable: true, get: function() {
      return aminotypes_1.AminoTypes;
    } });
    var encodeobjects_1 = require_encodeobjects();
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return encodeobjects_1.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return encodeobjects_1.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return encodeobjects_1.isMsgSendEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return encodeobjects_1.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return encodeobjects_1.isMsgTransferEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return encodeobjects_1.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return encodeobjects_1.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return encodeobjects_1.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    var fee_1 = require_fee();
    Object.defineProperty(exports, "calculateFee", { enumerable: true, get: function() {
      return fee_1.calculateFee;
    } });
    Object.defineProperty(exports, "GasPrice", { enumerable: true, get: function() {
      return fee_1.GasPrice;
    } });
    exports.logs = __importStar(require_logs());
    var multisignature_1 = require_multisignature();
    Object.defineProperty(exports, "makeMultisignedTx", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTx;
    } });
    var queries_1 = require_queries();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return queries_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return queries_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return queries_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queries_1.QueryClient;
    } });
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return queries_1.setupAuthExtension;
    } });
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return queries_1.setupBankExtension;
    } });
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return queries_1.setupDistributionExtension;
    } });
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return queries_1.setupGovExtension;
    } });
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return queries_1.setupIbcExtension;
    } });
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return queries_1.setupMintExtension;
    } });
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return queries_1.setupStakingExtension;
    } });
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return queries_1.setupTxExtension;
    } });
    var search_1 = require_search();
    Object.defineProperty(exports, "isSearchByHeightQuery", { enumerable: true, get: function() {
      return search_1.isSearchByHeightQuery;
    } });
    Object.defineProperty(exports, "isSearchBySentFromOrToQuery", { enumerable: true, get: function() {
      return search_1.isSearchBySentFromOrToQuery;
    } });
    Object.defineProperty(exports, "isSearchByTagsQuery", { enumerable: true, get: function() {
      return search_1.isSearchByTagsQuery;
    } });
    var signingstargateclient_1 = require_signingstargateclient();
    Object.defineProperty(exports, "defaultRegistryTypes", { enumerable: true, get: function() {
      return signingstargateclient_1.defaultRegistryTypes;
    } });
    Object.defineProperty(exports, "SigningStargateClient", { enumerable: true, get: function() {
      return signingstargateclient_1.SigningStargateClient;
    } });
    var stargateclient_1 = require_stargateclient();
    Object.defineProperty(exports, "assertIsDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxFailure;
    } });
    Object.defineProperty(exports, "assertIsDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "isDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxFailure;
    } });
    Object.defineProperty(exports, "isDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "StargateClient", { enumerable: true, get: function() {
      return stargateclient_1.StargateClient;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return stargateclient_1.TimeoutError;
    } });
    var proto_signing_1 = require_build6();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return proto_signing_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return proto_signing_1.coins;
    } });
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return proto_signing_1.makeCosmoshubPath;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return proto_signing_1.parseCoins;
    } });
  }
});

export {
  require_build12 as require_build
};
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
//# sourceMappingURL=chunk-HBCPMZKW.js.map
