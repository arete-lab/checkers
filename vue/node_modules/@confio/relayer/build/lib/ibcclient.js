"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareChannelHandshake = exports.prepareConnectionHandshake = exports.buildCreateClientArgs = exports.IbcClient = void 0;
const encoding_1 = require("@cosmjs/encoding");
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const utils_1 = require("@cosmjs/utils");
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const long_1 = __importDefault(require("long"));
const tx_1 = require("../codec/ibc/applications/transfer/v1/tx");
const channel_1 = require("../codec/ibc/core/channel/v1/channel");
const tx_2 = require("../codec/ibc/core/channel/v1/tx");
const client_1 = require("../codec/ibc/core/client/v1/client");
const tx_3 = require("../codec/ibc/core/client/v1/tx");
const tx_4 = require("../codec/ibc/core/connection/v1/tx");
const tendermint_1 = require("../codec/ibc/lightclients/tendermint/v1/tendermint");
const types_1 = require("../codec/tendermint/types/types");
const validator_1 = require("../codec/tendermint/types/validator");
const logger_1 = require("./logger");
const ibc_1 = require("./queries/ibc");
const utils_2 = require("./utils");
function deepCloneAndMutate(object, mutateFn) {
    const deepClonedObject = cloneDeep_1.default(object);
    mutateFn(deepClonedObject);
    return deepClonedObject;
}
function toBase64AsAny(...input) {
    return encoding_1.toBase64(...input); // eslint-disable-line @typescript-eslint/no-explicit-any
}
/**** These are needed to bootstrap the endpoints */
/* Some of them are hardcoded various places, which should we make configurable? */
// const DefaultTrustLevel = '1/3';
// const MaxClockDrift = 10; // 10 seconds
// const upgradePath = ['upgrade', 'upgradedIBCState'];
// const allowUpgradeAfterExpiry = false;
// const allowUpgradeAfterMisbehavior = false;
// these are from the cosmos sdk implementation
const defaultMerklePrefix = {
    keyPrefix: encoding_1.toAscii('ibc'),
};
const defaultConnectionVersion = {
    identifier: '1',
    features: ['ORDER_ORDERED', 'ORDER_UNORDERED'],
};
// this is a sane default, but we can revisit it
const defaultDelayPeriod = new long_1.default(0);
function ibcRegistry() {
    return new proto_signing_1.Registry([
        ...stargate_1.defaultRegistryTypes,
        ['/ibc.core.client.v1.MsgCreateClient', tx_3.MsgCreateClient],
        ['/ibc.core.client.v1.MsgUpdateClient', tx_3.MsgUpdateClient],
        ['/ibc.core.connection.v1.MsgConnectionOpenInit', tx_4.MsgConnectionOpenInit],
        ['/ibc.core.connection.v1.MsgConnectionOpenTry', tx_4.MsgConnectionOpenTry],
        ['/ibc.core.connection.v1.MsgConnectionOpenAck', tx_4.MsgConnectionOpenAck],
        [
            '/ibc.core.connection.v1.MsgConnectionOpenConfirm',
            tx_4.MsgConnectionOpenConfirm,
        ],
        ['/ibc.core.channel.v1.MsgChannelOpenInit', tx_2.MsgChannelOpenInit],
        ['/ibc.core.channel.v1.MsgChannelOpenTry', tx_2.MsgChannelOpenTry],
        ['/ibc.core.channel.v1.MsgChannelOpenAck', tx_2.MsgChannelOpenAck],
        ['/ibc.core.channel.v1.MsgChannelOpenConfirm', tx_2.MsgChannelOpenConfirm],
        ['/ibc.core.channel.v1.MsgRecvPacket', tx_2.MsgRecvPacket],
        ['/ibc.core.channel.v1.MsgAcknowledgement', tx_2.MsgAcknowledgement],
        ['/ibc.core.channel.v1.MsgTimeout', tx_2.MsgTimeout],
        ['/ibc.applications.transfer.v1.MsgTransfer', tx_1.MsgTransfer],
    ]);
}
const defaultGasPrice = stargate_1.GasPrice.fromString('0.025ucosm');
const defaultGasLimits = {
    bankSend: 200000,
    initClient: 150000,
    updateClient: 600000,
    initConnection: 150000,
    connectionHandshake: 300000,
    initChannel: 150000,
    channelHandshake: 300000,
    receivePacket: 300000,
    ackPacket: 300000,
    timeoutPacket: 300000,
    transfer: 180000,
};
class IbcClient {
    constructor(signingClient, tmClient, senderAddress, chainId, options) {
        this.sign = signingClient;
        this.tm = tmClient;
        this.query = stargate_1.QueryClient.withExtensions(tmClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, ibc_1.setupIbcExtension, stargate_1.setupStakingExtension);
        this.senderAddress = senderAddress;
        this.chainId = chainId;
        this.revisionNumber = utils_2.parseRevisionNumber(chainId);
        const { gasPrice = defaultGasPrice, gasLimits = {}, logger } = options;
        this.gasPrice = gasPrice;
        // we must do this explicitly, not
        //   this.limits = { ...defaultGasLimits, ...gasLimits };
        // so undefined in gasLimits don't overwrite defaults
        this.limits = {
            bankSend: gasLimits.bankSend || defaultGasLimits.bankSend,
            initClient: gasLimits.initClient || defaultGasLimits.initClient,
            updateClient: gasLimits.updateClient || defaultGasLimits.updateClient,
            initConnection: gasLimits.initConnection || defaultGasLimits.initConnection,
            connectionHandshake: gasLimits.connectionHandshake || defaultGasLimits.connectionHandshake,
            initChannel: gasLimits.initChannel || defaultGasLimits.initChannel,
            channelHandshake: gasLimits.channelHandshake || defaultGasLimits.channelHandshake,
            receivePacket: gasLimits.receivePacket || defaultGasLimits.receivePacket,
            ackPacket: gasLimits.ackPacket || defaultGasLimits.ackPacket,
            timeoutPacket: gasLimits.timeoutPacket || defaultGasLimits.timeoutPacket,
            transfer: gasLimits.transfer || defaultGasLimits.transfer,
        };
        this.logger = logger !== null && logger !== void 0 ? logger : new logger_1.NoopLogger();
    }
    static connectWithSigner(endpoint, signer, senderAddress, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // override any registry setup, use the other options
            const mergedOptions = Object.assign(Object.assign({}, options), { registry: ibcRegistry() });
            const signingClient = yield stargate_1.SigningStargateClient.connectWithSigner(endpoint, signer, mergedOptions);
            const tmClient = yield tendermint_rpc_1.Tendermint34Client.connect(endpoint);
            const chainId = yield signingClient.getChainId();
            return new IbcClient(signingClient, tmClient, senderAddress, chainId, options);
        });
    }
    revisionHeight(height) {
        return client_1.Height.fromPartial({
            revisionHeight: new long_1.default(height),
            revisionNumber: this.revisionNumber,
        });
    }
    ensureRevisionHeight(height) {
        if (typeof height === 'number') {
            return client_1.Height.fromPartial({
                revisionHeight: long_1.default.fromNumber(height),
                revisionNumber: this.revisionNumber,
            });
        }
        if (height.revisionNumber.toNumber() !== this.revisionNumber.toNumber()) {
            throw new Error(`Using incorrect revisionNumber ${height.revisionNumber} on chain with ${this.revisionNumber}`);
        }
        return height;
    }
    timeoutHeight(blocksInFuture) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = yield this.latestHeader();
            return this.revisionHeight(header.height + blocksInFuture);
        });
    }
    getChainId() {
        this.logger.verbose('Get chain ID');
        return this.sign.getChainId();
    }
    header(height) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Get header for height ${height}`);
            // TODO: expose header method on tmClient and use that
            const resp = yield this.tm.blockchain(height, height);
            return resp.blockMetas[0].header;
        });
    }
    latestHeader() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: expose header method on tmClient and use that
            const block = yield this.tm.block();
            return block.block.header;
        });
    }
    currentTime() {
        return __awaiter(this, void 0, void 0, function* () {
            // const status = await this.tm.status();
            // return status.syncInfo.latestBlockTime;
            return (yield this.latestHeader()).time;
        });
    }
    currentHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this.tm.status();
            return status.syncInfo.latestBlockHeight;
        });
    }
    currentRevision() {
        return __awaiter(this, void 0, void 0, function* () {
            const block = yield this.currentHeight();
            return this.revisionHeight(block);
        });
    }
    waitOneBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            // ensure this works
            const start = yield this.currentHeight();
            let end;
            do {
                yield utils_1.sleep(500);
                end = yield this.currentHeight();
            } while (end === start);
            // TODO: this works but only for websocket connections, is there some code that falls back to polling in cosmjs?
            // await firstEvent(this.tm.subscribeNewBlockHeader());
        });
    }
    // we may have to wait a bit before a tx returns and making queries on the event log
    waitForIndexer() {
        return __awaiter(this, void 0, void 0, function* () {
            yield utils_1.sleep(50);
        });
    }
    getCommit(height) {
        this.logger.verbose(height === undefined
            ? 'Get latest commit'
            : `Get commit for height ${height}`);
        return this.tm.commit(height);
    }
    /** Returns the unbonding period in seconds */
    getUnbondingPeriod() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const { params } = yield this.query.staking.params();
            const seconds = (_b = (_a = params === null || params === void 0 ? void 0 : params.unbondingTime) === null || _a === void 0 ? void 0 : _a.seconds) === null || _b === void 0 ? void 0 : _b.toNumber();
            if (!seconds) {
                throw new Error('No unbonding period found');
            }
            this.logger.verbose('Queried unbonding period', { seconds });
            return seconds;
        });
    }
    getSignedHeader(height) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const { header: rpcHeader, commit: rpcCommit } = yield this.getCommit(height);
            const header = types_1.Header.fromPartial(Object.assign(Object.assign({}, rpcHeader), { version: {
                    block: new long_1.default(rpcHeader.version.block),
                }, height: new long_1.default(rpcHeader.height), time: utils_2.timestampFromDateNanos(rpcHeader.time), lastBlockId: {
                    hash: (_a = rpcHeader.lastBlockId) === null || _a === void 0 ? void 0 : _a.hash,
                    partSetHeader: (_b = rpcHeader.lastBlockId) === null || _b === void 0 ? void 0 : _b.parts,
                } }));
            const signatures = rpcCommit.signatures.map((sig) => (Object.assign(Object.assign({}, sig), { timestamp: sig.timestamp && utils_2.timestampFromDateNanos(sig.timestamp), blockIdFlag: types_1.blockIDFlagFromJSON(sig.blockIdFlag) })));
            const commit = types_1.Commit.fromPartial({
                height: new long_1.default(rpcCommit.height),
                round: rpcCommit.round,
                blockId: {
                    hash: rpcCommit.blockId.hash,
                    partSetHeader: rpcCommit.blockId.parts,
                },
                signatures,
            });
            // For the vote sign bytes, it checks (from the commit):
            //   Height, Round, BlockId, TimeStamp, ChainID
            return { header, commit };
        });
    }
    getValidatorSet(height) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Get validator set for height ${height}`);
            // we need to query the header to find out who the proposer was, and pull them out
            const { proposerAddress } = yield this.header(height);
            const validators = yield this.tm.validatorsAll(height);
            const mappedValidators = validators.validators.map((val) => ({
                address: val.address,
                pubKey: utils_2.mapRpcPubKeyToProto(val.pubkey),
                votingPower: new long_1.default(val.votingPower),
                proposerPriority: val.proposerPriority
                    ? new long_1.default(val.proposerPriority)
                    : undefined,
            }));
            const totalPower = validators.validators.reduce((x, v) => x + v.votingPower, 0);
            const proposer = mappedValidators.find((val) => utils_1.arrayContentEquals(val.address, proposerAddress));
            return validator_1.ValidatorSet.fromPartial({
                validators: mappedValidators,
                totalVotingPower: new long_1.default(totalPower),
                proposer,
            });
        });
    }
    // this builds a header to update a remote client.
    // you must pass the last known height on the remote side so we can properly generate it.
    // it will update to the latest state of this chain.
    //
    // This is the logic that validates the returned struct:
    // ibc check: https://github.com/cosmos/cosmos-sdk/blob/v0.41.0/x/ibc/light-clients/07-tendermint/types/update.go#L87-L167
    // tendermint check: https://github.com/tendermint/tendermint/blob/v0.34.3/light/verifier.go#L19-L79
    // sign bytes: https://github.com/tendermint/tendermint/blob/v0.34.3/types/validator_set.go#L762-L821
    //   * https://github.com/tendermint/tendermint/blob/v0.34.3/types/validator_set.go#L807-L810
    //   * https://github.com/tendermint/tendermint/blob/v0.34.3/types/block.go#L780-L809
    //   * https://github.com/tendermint/tendermint/blob/bf9e36d02d2eb22f6fe8961d0d7d3d34307ba38e/types/canonical.go#L54-L65
    //
    // For the vote sign bytes, it checks (from the commit):
    //   Height, Round, BlockId, TimeStamp, ChainID
    buildHeader(lastHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const signedHeader = yield this.getSignedHeader();
            // "assert that trustedVals is NextValidators of last trusted header"
            // https://github.com/cosmos/cosmos-sdk/blob/v0.41.0/x/ibc/light-clients/07-tendermint/types/update.go#L74
            const validatorHeight = lastHeight + 1;
            /* eslint @typescript-eslint/no-non-null-assertion: "off" */
            const curHeight = signedHeader.header.height.toNumber();
            return tendermint_1.Header.fromPartial({
                signedHeader,
                validatorSet: yield this.getValidatorSet(curHeight),
                trustedHeight: this.revisionHeight(lastHeight),
                trustedValidators: yield this.getValidatorSet(validatorHeight),
            });
        });
    }
    // trustedHeight must be proven by the client on the destination chain
    // and include a proof for the connOpenInit (eg. must be 1 or more blocks after the
    // block connOpenInit Tx was in).
    //
    // pass a header height that was previously updated to on the remote chain using updateClient.
    // note: the queries will be for the block before this header, so the proofs match up (appHash is on H+1)
    getConnectionProof(clientId, connectionId, headerHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const proofHeight = this.ensureRevisionHeight(headerHeight);
            const queryHeight = utils_2.subtractBlock(proofHeight, 1);
            const { clientState, proof: proofClient,
            // proofHeight,
             } = yield this.query.ibc.proof.client.state(clientId, queryHeight);
            // This is the most recent state we have on this chain of the other
            const { latestHeight: consensusHeight } = yield this.query.ibc.client.stateTm(clientId);
            utils_1.assert(consensusHeight);
            // get the init proof
            const { proof: proofConnection } = yield this.query.ibc.proof.connection.connection(connectionId, queryHeight);
            // get the consensus proof
            const { proof: proofConsensus } = yield this.query.ibc.proof.client.consensusState(clientId, consensusHeight, queryHeight);
            return {
                clientId,
                clientState,
                connectionId,
                proofHeight,
                proofConnection,
                proofClient,
                proofConsensus,
                consensusHeight,
            };
        });
    }
    // trustedHeight must be proven by the client on the destination chain
    // and include a proof for the connOpenInit (eg. must be 1 or more blocks after the
    // block connOpenInit Tx was in).
    //
    // pass a header height that was previously updated to on the remote chain using updateClient.
    // note: the queries will be for the block before this header, so the proofs match up (appHash is on H+1)
    getChannelProof(id, headerHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const proofHeight = this.ensureRevisionHeight(headerHeight);
            const queryHeight = utils_2.subtractBlock(proofHeight, 1);
            const { proof } = yield this.query.ibc.proof.channel.channel(id.portId, id.channelId, queryHeight);
            return {
                id,
                proofHeight,
                proof,
            };
        });
    }
    getPacketProof(packet, headerHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const proofHeight = this.ensureRevisionHeight(headerHeight);
            const queryHeight = utils_2.subtractBlock(proofHeight, 1);
            const { proof } = yield this.query.ibc.proof.channel.packetCommitment(packet.sourcePort, packet.sourceChannel, packet.sequence, queryHeight);
            return proof;
        });
    }
    getAckProof({ originalPacket }, headerHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const proofHeight = this.ensureRevisionHeight(headerHeight);
            const queryHeight = utils_2.subtractBlock(proofHeight, 1);
            const res = yield this.query.ibc.proof.channel.packetAcknowledgement(originalPacket.destinationPort, originalPacket.destinationChannel, originalPacket.sequence.toNumber(), queryHeight);
            const { proof } = res;
            return proof;
        });
    }
    getTimeoutProof({ originalPacket }, headerHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const proofHeight = this.ensureRevisionHeight(headerHeight);
            const queryHeight = utils_2.subtractBlock(proofHeight, 1);
            const proof = yield this.query.ibc.proof.channel.receiptProof(originalPacket.destinationPort, originalPacket.destinationChannel, originalPacket.sequence.toNumber(), queryHeight);
            return proof;
        });
    }
    /*
    These are helpers to query, build data and submit a message
    Currently all prefixed with doXxx, but please look for better naming
    */
    // Updates existing client on this chain with data from src chain.
    // Returns the height that was updated to.
    doUpdateClient(clientId, src) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const { latestHeight } = yield this.query.ibc.client.stateTm(clientId);
            const header = yield src.buildHeader(utils_2.toIntHeight(latestHeight));
            yield this.updateTendermintClient(clientId, header);
            const height = (_d = (_c = (_b = (_a = header.signedHeader) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.height) === null || _c === void 0 ? void 0 : _c.toNumber()) !== null && _d !== void 0 ? _d : 0;
            return src.revisionHeight(height);
        });
    }
    /***** These are all direct wrappers around message constructors ********/
    sendTokens(recipientAddress, transferAmount, memo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Send tokens to ${recipientAddress}`);
            this.logger.debug('Send tokens:', {
                senderAddress: this.senderAddress,
                recipientAddress,
                transferAmount,
                memo,
            });
            const result = yield this.sign.sendTokens(this.senderAddress, recipientAddress, transferAmount, stargate_1.calculateFee(this.limits.bankSend, this.gasPrice), memo);
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    /* Send any number of messages, you are responsible for encoding them */
    sendMultiMsg(msgs, gasLimit) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Broadcast multiple msgs`);
            this.logger.debug(`Multiple msgs:`, {
                msgs,
                gasLimit,
            });
            const senderAddress = this.senderAddress;
            const fee = stargate_1.calculateFee(gasLimit, this.gasPrice);
            const result = yield this.sign.signAndBroadcast(senderAddress, msgs, fee);
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    createTendermintClient(clientState, consensusState) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Create Tendermint client`);
            const senderAddress = this.senderAddress;
            const createMsg = {
                typeUrl: '/ibc.core.client.v1.MsgCreateClient',
                value: tx_3.MsgCreateClient.fromPartial({
                    signer: senderAddress,
                    clientState: {
                        typeUrl: '/ibc.lightclients.tendermint.v1.ClientState',
                        value: tendermint_1.ClientState.encode(clientState).finish(),
                    },
                    consensusState: {
                        typeUrl: '/ibc.lightclients.tendermint.v1.ConsensusState',
                        value: tendermint_1.ConsensusState.encode(consensusState).finish(),
                    },
                }),
            };
            this.logger.debug('MsgCreateClient', createMsg);
            const result = yield this.sign.signAndBroadcast(senderAddress, [createMsg], stargate_1.calculateFee(this.limits.initClient, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            const clientId = stargate_1.logs.findAttribute(parsedLogs, 'create_client', 'client_id').value;
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
                clientId,
            };
        });
    }
    updateTendermintClient(clientId, header) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Update Tendermint client ${clientId}`);
            const senderAddress = this.senderAddress;
            const updateMsg = {
                typeUrl: '/ibc.core.client.v1.MsgUpdateClient',
                value: tx_3.MsgUpdateClient.fromPartial({
                    signer: senderAddress,
                    clientId,
                    header: {
                        typeUrl: '/ibc.lightclients.tendermint.v1.Header',
                        value: tendermint_1.Header.encode(header).finish(),
                    },
                }),
            };
            this.logger.debug(`MsgUpdateClient`, deepCloneAndMutate(updateMsg, (mutableMsg) => {
                var _a;
                if ((_a = mutableMsg.value.header) === null || _a === void 0 ? void 0 : _a.value) {
                    mutableMsg.value.header.value = toBase64AsAny(mutableMsg.value.header.value);
                }
            }));
            const result = yield this.sign.signAndBroadcast(senderAddress, [updateMsg], stargate_1.calculateFee(this.limits.updateClient, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    connOpenInit(clientId, remoteClientId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Connection open init: ${clientId} => ${remoteClientId}`);
            const senderAddress = this.senderAddress;
            const msg = {
                typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenInit',
                value: tx_4.MsgConnectionOpenInit.fromPartial({
                    clientId,
                    counterparty: {
                        clientId: remoteClientId,
                        prefix: defaultMerklePrefix,
                    },
                    version: defaultConnectionVersion,
                    delayPeriod: defaultDelayPeriod,
                    signer: senderAddress,
                }),
            };
            this.logger.debug(`MsgConnectionOpenInit`, msg);
            const result = yield this.sign.signAndBroadcast(senderAddress, [msg], stargate_1.calculateFee(this.limits.initConnection, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            const connectionId = stargate_1.logs.findAttribute(parsedLogs, 'connection_open_init', 'connection_id').value;
            this.logger.debug(`Connection open init successful: ${connectionId}`);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
                connectionId,
            };
        });
    }
    connOpenTry(myClientId, proof) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Connection open try: ${myClientId} => ${proof.clientId} (${proof.connectionId})`);
            const senderAddress = this.senderAddress;
            const { clientId, connectionId, clientState, proofHeight, proofConnection: proofInit, proofClient, proofConsensus, consensusHeight, } = proof;
            const msg = {
                typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenTry',
                value: tx_4.MsgConnectionOpenTry.fromPartial({
                    clientId: myClientId,
                    counterparty: {
                        clientId,
                        connectionId,
                        prefix: defaultMerklePrefix,
                    },
                    delayPeriod: defaultDelayPeriod,
                    counterpartyVersions: [defaultConnectionVersion],
                    signer: senderAddress,
                    clientState,
                    proofHeight,
                    proofInit,
                    proofClient,
                    proofConsensus,
                    consensusHeight,
                }),
            };
            this.logger.debug('MsgConnectionOpenTry', deepCloneAndMutate(msg, (mutableMsg) => {
                mutableMsg.value.proofClient = toBase64AsAny(mutableMsg.value.proofClient);
                mutableMsg.value.proofConsensus = toBase64AsAny(mutableMsg.value.proofConsensus);
                mutableMsg.value.proofInit = toBase64AsAny(mutableMsg.value.proofInit);
            }));
            const result = yield this.sign.signAndBroadcast(senderAddress, [msg], stargate_1.calculateFee(this.limits.connectionHandshake, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            const myConnectionId = stargate_1.logs.findAttribute(parsedLogs, 'connection_open_try', 'connection_id').value;
            this.logger.debug(`Connection open try successful: ${myConnectionId} => ${connectionId}`);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
                connectionId: myConnectionId,
            };
        });
    }
    connOpenAck(myConnectionId, proof) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Connection open ack: ${myConnectionId} => ${proof.connectionId}`);
            const senderAddress = this.senderAddress;
            const { connectionId, clientState, proofHeight, proofConnection: proofTry, proofClient, proofConsensus, consensusHeight, } = proof;
            const msg = {
                typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenAck',
                value: tx_4.MsgConnectionOpenAck.fromPartial({
                    connectionId: myConnectionId,
                    counterpartyConnectionId: connectionId,
                    version: defaultConnectionVersion,
                    signer: senderAddress,
                    clientState,
                    proofHeight,
                    proofTry,
                    proofClient,
                    proofConsensus,
                    consensusHeight,
                }),
            };
            this.logger.debug('MsgConnectionOpenAck', deepCloneAndMutate(msg, (mutableMsg) => {
                mutableMsg.value.proofConsensus = toBase64AsAny(mutableMsg.value.proofConsensus);
                mutableMsg.value.proofTry = toBase64AsAny(mutableMsg.value.proofTry);
                mutableMsg.value.proofClient = toBase64AsAny(mutableMsg.value.proofClient);
            }));
            const result = yield this.sign.signAndBroadcast(senderAddress, [msg], stargate_1.calculateFee(this.limits.connectionHandshake, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    connOpenConfirm(myConnectionId, proof) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Connection open confirm: ${myConnectionId}`);
            const senderAddress = this.senderAddress;
            const { proofHeight, proofConnection: proofAck } = proof;
            const msg = {
                typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenConfirm',
                value: tx_4.MsgConnectionOpenConfirm.fromPartial({
                    connectionId: myConnectionId,
                    signer: senderAddress,
                    proofHeight,
                    proofAck,
                }),
            };
            this.logger.debug('MsgConnectionOpenConfirm', deepCloneAndMutate(msg, (mutableMsg) => {
                mutableMsg.value.proofAck = toBase64AsAny(mutableMsg.value.proofAck);
            }));
            const result = yield this.sign.signAndBroadcast(senderAddress, [msg], stargate_1.calculateFee(this.limits.connectionHandshake, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    channelOpenInit(portId, remotePortId, ordering, connectionId, version) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Channel open init: ${portId} => ${remotePortId} (${connectionId})`);
            const senderAddress = this.senderAddress;
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgChannelOpenInit',
                value: tx_2.MsgChannelOpenInit.fromPartial({
                    portId,
                    channel: {
                        state: channel_1.State.STATE_INIT,
                        ordering,
                        counterparty: {
                            portId: remotePortId,
                        },
                        connectionHops: [connectionId],
                        version,
                    },
                    signer: senderAddress,
                }),
            };
            this.logger.debug('MsgChannelOpenInit', msg);
            const result = yield this.sign.signAndBroadcast(senderAddress, [msg], stargate_1.calculateFee(this.limits.initChannel, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            const channelId = stargate_1.logs.findAttribute(parsedLogs, 'channel_open_init', 'channel_id').value;
            this.logger.debug(`Channel open init successful: ${channelId}`);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
                channelId,
            };
        });
    }
    channelOpenTry(portId, remote, ordering, connectionId, version, counterpartyVersion, proof) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Channel open try: ${portId} => ${remote.portId} (${remote.channelId})`);
            const senderAddress = this.senderAddress;
            const { proofHeight, proof: proofInit } = proof;
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgChannelOpenTry',
                value: tx_2.MsgChannelOpenTry.fromPartial({
                    portId,
                    counterpartyVersion,
                    channel: {
                        state: channel_1.State.STATE_TRYOPEN,
                        ordering,
                        counterparty: remote,
                        connectionHops: [connectionId],
                        version,
                    },
                    proofInit,
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            this.logger.debug('MsgChannelOpenTry', deepCloneAndMutate(msg, (mutableMsg) => {
                mutableMsg.value.proofInit = toBase64AsAny(mutableMsg.value.proofInit);
            }));
            const result = yield this.sign.signAndBroadcast(senderAddress, [msg], stargate_1.calculateFee(this.limits.channelHandshake, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            const channelId = stargate_1.logs.findAttribute(parsedLogs, 'channel_open_try', 'channel_id').value;
            this.logger.debug(`Channel open try successful: ${channelId} => ${remote.channelId})`);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
                channelId,
            };
        });
    }
    channelOpenAck(portId, channelId, counterpartyChannelId, counterpartyVersion, proof) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Channel open ack for port ${portId}: ${channelId} => ${counterpartyChannelId}`);
            const senderAddress = this.senderAddress;
            const { proofHeight, proof: proofTry } = proof;
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgChannelOpenAck',
                value: tx_2.MsgChannelOpenAck.fromPartial({
                    portId,
                    channelId,
                    counterpartyChannelId,
                    counterpartyVersion,
                    proofTry,
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            this.logger.debug('MsgChannelOpenAck', deepCloneAndMutate(msg, (mutableMsg) => {
                mutableMsg.value.proofTry = toBase64AsAny(mutableMsg.value.proofTry);
            }));
            const result = yield this.sign.signAndBroadcast(senderAddress, [msg], stargate_1.calculateFee(this.limits.channelHandshake, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    channelOpenConfirm(portId, channelId, proof) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Chanel open confirm for port ${portId}: ${channelId} => ${proof.id.channelId}`);
            const senderAddress = this.senderAddress;
            const { proofHeight, proof: proofAck } = proof;
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgChannelOpenConfirm',
                value: tx_2.MsgChannelOpenConfirm.fromPartial({
                    portId,
                    channelId,
                    proofAck,
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            this.logger.debug('MsgChannelOpenConfirm', deepCloneAndMutate(msg, (mutableMsg) => {
                mutableMsg.value.proofAck = toBase64AsAny(mutableMsg.value.proofAck);
            }));
            const result = yield this.sign.signAndBroadcast(senderAddress, [msg], stargate_1.calculateFee(this.limits.channelHandshake, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    receivePacket(packet, proofCommitment, proofHeight) {
        return this.receivePackets([packet], [proofCommitment], proofHeight);
    }
    receivePackets(packets, proofCommitments, proofHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Receive ${packets.length} packets..`);
            if (packets.length !== proofCommitments.length) {
                throw new Error(`Have ${packets.length} packets, but ${proofCommitments.length} proofs`);
            }
            if (packets.length === 0) {
                throw new Error('Must submit at least 1 packet');
            }
            const senderAddress = this.senderAddress;
            const msgs = [];
            for (const i in packets) {
                const packet = packets[i];
                this.logger.verbose(`Sending packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, utils_2.presentPacketData(packet.data));
                const msg = {
                    typeUrl: '/ibc.core.channel.v1.MsgRecvPacket',
                    value: tx_2.MsgRecvPacket.fromPartial({
                        packet,
                        proofCommitment: proofCommitments[i],
                        proofHeight,
                        signer: senderAddress,
                    }),
                };
                msgs.push(msg);
            }
            this.logger.debug('MsgRecvPacket(s)', {
                msgs: msgs.map((msg) => deepCloneAndMutate(msg, (mutableMsg) => {
                    var _a;
                    mutableMsg.value.proofCommitment = toBase64AsAny(mutableMsg.value.proofCommitment);
                    if ((_a = mutableMsg.value.packet) === null || _a === void 0 ? void 0 : _a.data) {
                        mutableMsg.value.packet.data = toBase64AsAny(mutableMsg.value.packet.data);
                    }
                })),
            });
            const result = yield this.sign.signAndBroadcast(senderAddress, msgs, stargate_1.calculateFee(this.limits.receivePacket * msgs.length, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    acknowledgePacket(ack, proofAcked, proofHeight) {
        return this.acknowledgePackets([ack], [proofAcked], proofHeight);
    }
    acknowledgePackets(acks, proofAckeds, proofHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Acknowledge ${acks.length} packets...`);
            if (acks.length !== proofAckeds.length) {
                throw new Error(`Have ${acks.length} acks, but ${proofAckeds.length} proofs`);
            }
            if (acks.length === 0) {
                throw new Error('Must submit at least 1 ack');
            }
            const senderAddress = this.senderAddress;
            const msgs = [];
            for (const i in acks) {
                const packet = acks[i].originalPacket;
                const acknowledgement = acks[i].acknowledgement;
                this.logger.verbose(`Ack packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, {
                    packet: utils_2.presentPacketData(packet.data),
                    ack: utils_2.presentPacketData(acknowledgement),
                });
                const msg = {
                    typeUrl: '/ibc.core.channel.v1.MsgAcknowledgement',
                    value: tx_2.MsgAcknowledgement.fromPartial({
                        packet,
                        acknowledgement,
                        proofAcked: proofAckeds[i],
                        proofHeight,
                        signer: senderAddress,
                    }),
                };
                msgs.push(msg);
            }
            this.logger.debug('MsgAcknowledgement(s)', {
                msgs: msgs.map((msg) => deepCloneAndMutate(msg, (mutableMsg) => {
                    var _a;
                    mutableMsg.value.acknowledgement = toBase64AsAny(mutableMsg.value.acknowledgement);
                    mutableMsg.value.proofAcked = toBase64AsAny(mutableMsg.value.proofAcked);
                    if ((_a = mutableMsg.value.packet) === null || _a === void 0 ? void 0 : _a.data) {
                        mutableMsg.value.packet.data = toBase64AsAny(mutableMsg.value.packet.data);
                    }
                })),
            });
            const result = yield this.sign.signAndBroadcast(senderAddress, msgs, stargate_1.calculateFee(this.limits.ackPacket * msgs.length, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    timeoutPacket(packet, proofUnreceived, nextSequenceRecv, proofHeight) {
        return this.timeoutPackets([packet], [proofUnreceived], [nextSequenceRecv], proofHeight);
    }
    timeoutPackets(packets, proofsUnreceived, nextSequenceRecv, proofHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            if (packets.length !== proofsUnreceived.length) {
                throw new Error('Packets and proofs must be same length');
            }
            if (packets.length !== nextSequenceRecv.length) {
                throw new Error('Packets and sequences must be same length');
            }
            this.logger.verbose(`Timeout ${packets.length} packets...`);
            const senderAddress = this.senderAddress;
            const msgs = [];
            for (const i in packets) {
                const packet = packets[i];
                this.logger.verbose(`Timeout packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, utils_2.presentPacketData(packet.data));
                const msg = {
                    typeUrl: '/ibc.core.channel.v1.MsgTimeout',
                    value: tx_2.MsgTimeout.fromPartial({
                        packet,
                        proofUnreceived: proofsUnreceived[i],
                        nextSequenceRecv: nextSequenceRecv[i],
                        proofHeight,
                        signer: senderAddress,
                    }),
                };
                msgs.push(msg);
            }
            this.logger.debug('MsgTimeout', {
                msgs: msgs.map((msg) => deepCloneAndMutate(msg, (mutableMsg) => {
                    var _a;
                    if ((_a = mutableMsg.value.packet) === null || _a === void 0 ? void 0 : _a.data) {
                        mutableMsg.value.packet.data = toBase64AsAny(mutableMsg.value.packet.data);
                    }
                    mutableMsg.value.proofUnreceived = toBase64AsAny(mutableMsg.value.proofUnreceived);
                })),
            });
            const result = yield this.sign.signAndBroadcast(senderAddress, msgs, stargate_1.calculateFee(this.limits.timeoutPacket * msgs.length, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
    transferTokens(sourcePort, sourceChannel, token, receiver, timeoutHeight, 
    /** timeout in seconds (SigningStargateClient converts to nanoseconds) */
    timeoutTime) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Transfer tokens to ${receiver}`);
            const result = yield this.sign.sendIbcTokens(this.senderAddress, receiver, token, sourcePort, sourceChannel, timeoutHeight, timeoutTime, stargate_1.calculateFee(this.limits.transfer, this.gasPrice));
            if (stargate_1.isBroadcastTxFailure(result)) {
                throw new Error(utils_2.createBroadcastTxErrorMessage(result));
            }
            const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);
            return {
                logs: parsedLogs,
                transactionHash: result.transactionHash,
                height: result.height,
            };
        });
    }
}
exports.IbcClient = IbcClient;
// this will query for the unbonding period.
// if the trusting period is not set, it will use 2/3 of the unbonding period
function buildCreateClientArgs(src, trustPeriodSec) {
    return __awaiter(this, void 0, void 0, function* () {
        const header = yield src.latestHeader();
        const consensusState = utils_2.buildConsensusState(header);
        const unbondingPeriodSec = yield src.getUnbondingPeriod();
        if (trustPeriodSec === undefined || trustPeriodSec === null) {
            trustPeriodSec = Math.floor((unbondingPeriodSec * 2) / 3);
        }
        const clientState = utils_2.buildClientState(src.chainId, unbondingPeriodSec, trustPeriodSec, src.revisionHeight(header.height));
        return { consensusState, clientState };
    });
}
exports.buildCreateClientArgs = buildCreateClientArgs;
function prepareConnectionHandshake(src, dest, clientIdSrc, clientIdDest, connIdSrc) {
    return __awaiter(this, void 0, void 0, function* () {
        // ensure the last transaction was committed to the header (one block after it was included)
        yield src.waitOneBlock();
        // update client on dest
        const headerHeight = yield dest.doUpdateClient(clientIdDest, src);
        // get a proof (for the proven height)
        const proof = yield src.getConnectionProof(clientIdSrc, connIdSrc, headerHeight);
        return proof;
    });
}
exports.prepareConnectionHandshake = prepareConnectionHandshake;
function prepareChannelHandshake(src, dest, clientIdDest, portId, channelId) {
    return __awaiter(this, void 0, void 0, function* () {
        // ensure the last transaction was committed to the header (one block after it was included)
        yield src.waitOneBlock();
        // update client on dest
        const headerHeight = yield dest.doUpdateClient(clientIdDest, src);
        // get a proof (for the proven height)
        const proof = yield src.getChannelProof({ portId, channelId }, headerHeight);
        return proof;
    });
}
exports.prepareChannelHandshake = prepareChannelHandshake;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWJjY2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xpYi9pYmNjbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0NBQXFEO0FBQ3JELHlEQUE4RTtBQUM5RSwrQ0FnQjBCO0FBQzFCLDJEQUlnQztBQUNoQyx5Q0FBa0U7QUFDbEUsaUVBQXlDO0FBQ3pDLGdEQUF3QjtBQUd4QixpRUFBdUU7QUFDdkUsa0VBQTRFO0FBQzVFLHdEQVF5QztBQUN6QywrREFBNEQ7QUFDNUQsdURBR3dDO0FBRXhDLDJEQUs0QztBQUM1QyxtRkFJNEQ7QUFDNUQsMkRBS3lDO0FBQ3pDLG1FQUFtRTtBQUVuRSxxQ0FBOEM7QUFDOUMsdUNBQWdFO0FBQ2hFLG1DQVdpQjtBQUVqQixTQUFTLGtCQUFrQixDQUN6QixNQUFTLEVBQ1QsUUFBdUM7SUFFdkMsTUFBTSxnQkFBZ0IsR0FBRyxtQkFBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzNDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRTNCLE9BQU8sZ0JBQWdCLENBQUM7QUFDMUIsQ0FBQztBQUVELFNBQVMsYUFBYSxDQUFDLEdBQUcsS0FBa0M7SUFDMUQsT0FBTyxtQkFBUSxDQUFDLEdBQUcsS0FBSyxDQUFRLENBQUMsQ0FBQyx5REFBeUQ7QUFDN0YsQ0FBQztBQUVELG9EQUFvRDtBQUNwRCxtRkFBbUY7QUFDbkYsbUNBQW1DO0FBQ25DLDBDQUEwQztBQUMxQyx1REFBdUQ7QUFDdkQseUNBQXlDO0FBQ3pDLDhDQUE4QztBQUU5QywrQ0FBK0M7QUFDL0MsTUFBTSxtQkFBbUIsR0FBRztJQUMxQixTQUFTLEVBQUUsa0JBQU8sQ0FBQyxLQUFLLENBQUM7Q0FDMUIsQ0FBQztBQUNGLE1BQU0sd0JBQXdCLEdBQVk7SUFDeEMsVUFBVSxFQUFFLEdBQUc7SUFDZixRQUFRLEVBQUUsQ0FBQyxlQUFlLEVBQUUsaUJBQWlCLENBQUM7Q0FDL0MsQ0FBQztB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