"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Link = exports.otherSide = void 0;
const utils_1 = require("@cosmjs/utils");
const channel_1 = require("../codec/ibc/core/channel/v1/channel");
const endpoint_1 = require("./endpoint");
const ibcclient_1 = require("./ibcclient");
const logger_1 = require("./logger");
const utils_2 = require("./utils");
function otherSide(side) {
    if (side === 'A') {
        return 'B';
    }
    else {
        return 'A';
    }
}
exports.otherSide = otherSide;
/**
 * Link represents a Connection between a pair of blockchains (Nodes).
 * An initialized Link requires a both sides to have a Client for the remote side
 * as well as an established Connection using those Clients. Channels can be added
 * and removed to a Link. There are constructors to find/create the basic requirements
 * if you don't know the client/connection IDs a priori.
 */
class Link {
    // you can use this if you already have the info out of bounds
    // FIXME: check the validity of that data?
    constructor(endA, endB, logger) {
        this.endA = endA;
        this.endB = endB;
        this.logger = logger !== null && logger !== void 0 ? logger : new logger_1.NoopLogger();
        this.chainA = endA.client.chainId;
        this.chainB = endB.client.chainId;
    }
    chain(side) {
        if (side === 'A') {
            return this.chainA;
        }
        else {
            return this.chainB;
        }
    }
    otherChain(side) {
        if (side === 'A') {
            return this.chainB;
        }
        else {
            return this.chainA;
        }
    }
    /**
     * findConnection attempts to reuse an existing Client/Connection.
     * If none exists, then it returns an error.
     *
     * @param nodeA
     * @param nodeB
     */
    static createWithExistingConnections(nodeA, nodeB, connA, connB, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            const [chainA, chainB] = [nodeA.chainId, nodeB.chainId];
            const [{ connection: connectionA }, { connection: connectionB }] = yield Promise.all([
                nodeA.query.ibc.connection.connection(connA),
                nodeB.query.ibc.connection.connection(connB),
            ]);
            if (!connectionA) {
                throw new Error(`[${chainA}] Connection not found for ID ${connA}`);
            }
            if (!connectionB) {
                throw new Error(`[${chainB}] Connection not found for ID ${connB}`);
            }
            if (!connectionA.counterparty) {
                throw new Error(`[${chainA}] Counterparty not found for connection with ID ${connA}`);
            }
            if (!connectionB.counterparty) {
                throw new Error(`[${chainB}] Counterparty not found for connection with ID ${connB}`);
            }
            // ensure the connection is open
            if (connectionA.state != channel_1.State.STATE_OPEN) {
                throw new Error(`Connection on ${chainA} must be in state open, it has state ${connectionA.state}`);
            }
            if (connectionB.state != channel_1.State.STATE_OPEN) {
                throw new Error(`Connection on ${chainB} must be in state open, it has state ${connectionB.state}`);
            }
            const [clientIdA, clientIdB] = [connectionA.clientId, connectionB.clientId];
            if (clientIdA !== connectionB.counterparty.clientId) {
                throw new Error(`Client ID ${connectionA.clientId} for connection with ID ${connA} does not match counterparty client ID ${connectionB.counterparty.clientId} for connection with ID ${connB}`);
            }
            if (clientIdB !== connectionA.counterparty.clientId) {
                throw new Error(`Client ID ${connectionB.clientId} for connection with ID ${connB} does not match counterparty client ID ${connectionA.counterparty.clientId} for connection with ID ${connA}`);
            }
            const [clientStateA, clientStateB] = yield Promise.all([
                nodeA.query.ibc.client.stateTm(clientIdA),
                nodeB.query.ibc.client.stateTm(clientIdB),
            ]);
            if (nodeA.chainId !== clientStateB.chainId) {
                throw new Error(`Chain ID ${nodeA.chainId} for connection with ID ${connA} does not match remote chain ID ${clientStateA.chainId}`);
            }
            if (nodeB.chainId !== clientStateA.chainId) {
                throw new Error(`Chain ID ${nodeB.chainId} for connection with ID ${connB} does not match remote chain ID ${clientStateB.chainId}`);
            }
            const endA = new endpoint_1.Endpoint(nodeA, clientIdA, connA);
            const endB = new endpoint_1.Endpoint(nodeB, clientIdB, connB);
            const link = new Link(endA, endB, logger);
            yield Promise.all([
                link.assertHeadersMatchConsensusState('A', clientIdA, clientStateA.latestHeight),
                link.assertHeadersMatchConsensusState('B', clientIdB, clientStateB.latestHeight),
            ]);
            return link;
        });
    }
    /**
     * we do this assert inside createWithExistingConnections, but it could be a useful check
     * for submitting double-sign evidence later
     *
     * @param proofSide the side holding the consensus proof, we check the header from the other side
     * @param height the height of the consensus state and header we wish to compare
     */
    assertHeadersMatchConsensusState(proofSide, clientId, height) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { src, dest } = this.getEnds(proofSide);
            // Check headers match consensus state (at least validators)
            const [consensusState, header] = yield Promise.all([
                src.client.query.ibc.client.consensusStateTm(clientId, height),
                dest.client.header(utils_2.toIntHeight(height)),
            ]);
            // ensure consensus and headers match for next validator hashes
            if (!utils_1.arrayContentEquals(consensusState.nextValidatorsHash, header.nextValidatorsHash)) {
                throw new Error(`NextValidatorHash doesn't match ConsensusState.`);
            }
            // ensure the committed apphash matches the actual node we have
            const hash = (_a = consensusState.root) === null || _a === void 0 ? void 0 : _a.hash;
            if (!hash) {
                throw new Error(`ConsensusState.root.hash missing.`);
            }
            if (!utils_1.arrayContentEquals(hash, header.appHash)) {
                throw new Error(`AppHash doesn't match ConsensusState.`);
            }
        });
    }
    /**
     * createConnection will always create a new pair of clients and a Connection between the
     * two sides
     *
     * @param nodeA
     * @param nodeB
     */
    static createWithNewConnections(nodeA, nodeB, logger, 
    // number of seconds the client (on B pointing to A) is valid without update
    trustPeriodA, 
    // number of seconds the client (on A pointing to B) is valid without update
    trustPeriodB) {
        return __awaiter(this, void 0, void 0, function* () {
            const [clientIdA, clientIdB] = yield createClients(nodeA, nodeB, trustPeriodA, trustPeriodB);
            // wait a block to ensure we have proper proofs for creating a connection (this has failed on CI before)
            yield Promise.all([nodeA.waitOneBlock(), nodeB.waitOneBlock()]);
            // connectionInit on nodeA
            const { connectionId: connIdA } = yield nodeA.connOpenInit(clientIdA, clientIdB);
            // connectionTry on nodeB
            const proof = yield ibcclient_1.prepareConnectionHandshake(nodeA, nodeB, clientIdA, clientIdB, connIdA);
            const { connectionId: connIdB } = yield nodeB.connOpenTry(clientIdB, proof);
            // connectionAck on nodeA
            const proofAck = yield ibcclient_1.prepareConnectionHandshake(nodeB, nodeA, clientIdB, clientIdA, connIdB);
            yield nodeA.connOpenAck(connIdA, proofAck);
            // connectionConfirm on dest
            const proofConfirm = yield ibcclient_1.prepareConnectionHandshake(nodeA, nodeB, clientIdA, clientIdB, connIdA);
            yield nodeB.connOpenConfirm(connIdB, proofConfirm);
            const endA = new endpoint_1.Endpoint(nodeA, clientIdA, connIdA);
            const endB = new endpoint_1.Endpoint(nodeB, clientIdB, connIdB);
            return new Link(endA, endB, logger);
        });
    }
    /**
     * Writes the latest header from the sender chain to the other endpoint
     *
     * @param sender Which side we get the header/commit from
     * @returns header height (from sender) that is now known on dest
     *
     * Relayer binary should call this from a heartbeat which checks if needed and updates.
     * Just needs trusting period on both side
     */
    updateClient(sender) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Update Client on ${this.otherChain(sender)}`);
            const { src, dest } = this.getEnds(sender);
            const height = yield dest.client.doUpdateClient(dest.clientID, src.client);
            return height;
        });
    }
    /**
     * Checks if the last proven header on the destination is older than maxAge,
     * and if so, update the client. Returns the new client height if updated,
     * or null if no update needed
     *
     * @param sender
     * @param maxAge
     */
    updateClientIfStale(sender, maxAge) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Checking if ${this.otherChain(sender)} has recent header of ${this.chain(sender)}`);
            const { src, dest } = this.getEnds(sender);
            const knownHeader = yield dest.client.query.ibc.client.consensusStateTm(dest.clientID);
            const currentHeader = yield src.client.latestHeader();
            // quit now if we don't need to update
            const knownSeconds = (_b = (_a = knownHeader.timestamp) === null || _a === void 0 ? void 0 : _a.seconds) === null || _b === void 0 ? void 0 : _b.toNumber();
            if (knownSeconds) {
                const curSeconds = utils_2.timestampFromDateNanos(currentHeader.time).seconds.toNumber();
                if (curSeconds - knownSeconds < maxAge) {
                    return null;
                }
            }
            // otherwise, do the update
            return this.updateClient(sender);
        });
    }
    /**
     * Ensures the dest has a proof of at least minHeight from source.
     * Will not execute any tx if not needed.
     * Will wait a block if needed until the header is available.
     *
     * Returns the latest header height now available on dest
     */
    updateClientToHeight(source, minHeight) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Check whether client on ${this.otherChain(source)} >= height ${minHeight}`);
            const { src, dest } = this.getEnds(source);
            const client = yield dest.client.query.ibc.client.stateTm(dest.clientID);
            // TODO: revisit where revision number comes from - this must be the number from the source chain
            const knownHeight = (_c = (_b = (_a = client.latestHeight) === null || _a === void 0 ? void 0 : _a.revisionHeight) === null || _b === void 0 ? void 0 : _b.toNumber()) !== null && _c !== void 0 ? _c : 0;
            if (knownHeight >= minHeight && client.latestHeight !== undefined) {
                return client.latestHeight;
            }
            const curHeight = (yield src.client.latestHeader()).height;
            if (curHeight < minHeight) {
                yield src.client.waitOneBlock();
            }
            return this.updateClient(source);
        });
    }
    createChannel(sender, srcPort, destPort, ordering, version) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Create channel with sender ${this.chain(sender)}: ${srcPort} => ${destPort}`);
            const { src, dest } = this.getEnds(sender);
            // init on src
            const { channelId: channelIdSrc } = yield src.client.channelOpenInit(srcPort, destPort, ordering, src.connectionID, version);
            // try on dest
            const proof = yield ibcclient_1.prepareChannelHandshake(src.client, dest.client, dest.clientID, srcPort, channelIdSrc);
            const { channelId: channelIdDest } = yield dest.client.channelOpenTry(destPort, { portId: srcPort, channelId: channelIdSrc }, ordering, dest.connectionID, version, version, proof);
            // ack on src
            const proofAck = yield ibcclient_1.prepareChannelHandshake(dest.client, src.client, src.clientID, destPort, channelIdDest);
            yield src.client.channelOpenAck(srcPort, channelIdSrc, channelIdDest, version, proofAck);
            // confirm on dest
            const proofConfirm = yield ibcclient_1.prepareChannelHandshake(src.client, dest.client, dest.clientID, srcPort, channelIdSrc);
            yield dest.client.channelOpenConfirm(destPort, channelIdDest, proofConfirm);
            return {
                src: {
                    portId: srcPort,
                    channelId: channelIdSrc,
                },
                dest: {
                    portId: destPort,
                    channelId: channelIdDest,
                },
            };
        });
    }
    /**
     * This will check both sides for pending packets and relay them.
     * It will then relay all acks (previous and generated by the just-submitted packets).
     * If pending packets have timed out, it will submit a timeout instead of attempting to relay them.
     *
     * Returns the most recent heights it relay, which can be used as a start for the next round
     */
    checkAndRelayPacketsAndAcks(relayFrom, timedoutThresholdBlocks = 0, timedoutThresholdSeconds = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            // FIXME: is there a cleaner way to get the height we query at?
            const [packetHeightA, packetHeightB, packetsA, packetsB] = yield Promise.all([
                this.endA.client.currentHeight(),
                this.endB.client.currentHeight(),
                this.getPendingPackets('A', { minHeight: relayFrom.packetHeightA }),
                this.getPendingPackets('B', { minHeight: relayFrom.packetHeightB }),
            ]);
            const cutoffHeightA = yield this.endB.client.timeoutHeight(timedoutThresholdBlocks);
            const cutoffTimeA = utils_2.secondsFromDateNanos(yield this.endB.client.currentTime()) +
                timedoutThresholdSeconds;
            const { toSubmit: submitA, toTimeout: timeoutA } = utils_2.splitPendingPackets(cutoffHeightA, cutoffTimeA, packetsA);
            const cutoffHeightB = yield this.endA.client.timeoutHeight(timedoutThresholdBlocks);
            const cutoffTimeB = utils_2.secondsFromDateNanos(yield this.endA.client.currentTime()) +
                timedoutThresholdSeconds;
            const { toSubmit: submitB, toTimeout: timeoutB } = utils_2.splitPendingPackets(cutoffHeightB, cutoffTimeB, packetsB);
            // FIXME: use the returned acks first? Then query for others?
            yield Promise.all([
                this.relayPackets('A', submitA),
                this.relayPackets('B', submitB),
            ]);
            // let's wait a bit to ensure our newly committed acks are indexed
            yield Promise.all([
                this.endA.client.waitOneBlock(),
                this.endB.client.waitOneBlock(),
            ]);
            const [ackHeightA, ackHeightB, acksA, acksB] = yield Promise.all([
                this.endA.client.currentHeight(),
                this.endB.client.currentHeight(),
                this.getPendingAcks('A', { minHeight: relayFrom.ackHeightA }),
                this.getPendingAcks('B', { minHeight: relayFrom.ackHeightB }),
            ]);
            yield Promise.all([this.relayAcks('A', acksA), this.relayAcks('B', acksB)]);
            yield Promise.all([
                this.timeoutPackets('A', timeoutA),
                this.timeoutPackets('B', timeoutB),
            ]);
            const nextRelay = {
                packetHeightA,
                packetHeightB,
                ackHeightA,
                ackHeightB,
            };
            this.logger.verbose('next heights to relay', nextRelay);
            return nextRelay;
        });
    }
    getPendingPackets(source, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Get pending packets on ${this.chain(source)}`);
            const { src, dest } = this.getEnds(source);
            const allPackets = yield src.querySentPackets(opts);
            const toFilter = allPackets.map(({ packet }) => packet);
            const query = (port, channel, sequences) => __awaiter(this, void 0, void 0, function* () {
                const res = yield dest.client.query.ibc.channel.unreceivedPackets(port, channel, sequences);
                return res.sequences.map((seq) => seq.toNumber());
            });
            // This gets the subset of packets that were already processed on the receiving chain
            const unreceived = yield this.filterUnreceived(toFilter, query, packetId);
            const unreceivedPackets = allPackets.filter(({ packet }) => unreceived[packetId(packet)].has(packet.sequence.toNumber()));
            // However, some of these may have already been submitted as timeouts on the source chain. Check and filter
            const valid = yield Promise.all(unreceivedPackets.map((packet) => __awaiter(this, void 0, void 0, function* () {
                const { sourcePort, sourceChannel, sequence } = packet.packet;
                try {
                    // this throws an error if no commitment there
                    yield src.client.query.ibc.channel.packetCommitment(sourcePort, sourceChannel, sequence);
                    return packet;
                }
                catch (_a) {
                    return undefined;
                }
            })));
            return valid.filter((x) => x !== undefined);
        });
    }
    getPendingAcks(source, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Get pending acks on ${this.chain(source)}`);
            const { src, dest } = this.getEnds(source);
            const allAcks = yield src.queryWrittenAcks(opts);
            const toFilter = allAcks.map(({ originalPacket }) => originalPacket);
            const query = (port, channel, sequences) => __awaiter(this, void 0, void 0, function* () {
                const res = yield dest.client.query.ibc.channel.unreceivedAcks(port, channel, sequences);
                return res.sequences.map((seq) => seq.toNumber());
            });
            const unreceived = yield this.filterUnreceived(toFilter, query, ackId);
            return allAcks.filter(({ originalPacket: packet }) => unreceived[ackId(packet)].has(packet.sequence.toNumber()));
        });
    }
    filterUnreceived(packets, unreceivedQuery, idFunc) {
        return __awaiter(this, void 0, void 0, function* () {
            if (packets.length === 0) {
                return {};
            }
            const packetsPerDestination = packets.reduce((sorted, packet) => {
                var _a;
                const key = idFunc(packet);
                return Object.assign(Object.assign({}, sorted), { [key]: [...((_a = sorted[key]) !== null && _a !== void 0 ? _a : []), packet.sequence.toNumber()] });
            }, {});
            const unreceivedResponses = yield Promise.all(Object.entries(packetsPerDestination).map(([destination, sequences]) => __awaiter(this, void 0, void 0, function* () {
                const [port, channel] = destination.split(idDelim);
                const notfound = yield unreceivedQuery(port, channel, sequences);
                return { key: destination, sequences: notfound };
            })));
            const unreceived = unreceivedResponses.reduce((nested, { key, sequences }) => {
                return Object.assign(Object.assign({}, nested), { [key]: new Set(sequences) });
            }, {});
            return unreceived;
        });
    }
    // Returns the last height that this side knows of the other blockchain
    lastKnownHeader(side) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.verbose(`Get last known header on ${this.chain(side)}`);
            const { src } = this.getEnds(side);
            const client = yield src.client.query.ibc.client.stateTm(src.clientID);
            return (_c = (_b = (_a = client.latestHeight) === null || _a === void 0 ? void 0 : _a.revisionHeight) === null || _b === void 0 ? void 0 : _b.toNumber()) !== null && _c !== void 0 ? _c : 0;
        });
    }
    // this will update the client if needed and relay all provided packets from src -> dest
    // if packets are all older than the last consensusHeight, then we don't update the client.
    //
    // Returns all the acks that are associated with the just submitted packets
    relayPackets(source, packets) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Relay ${packets.length} packets from ${this.chain(source)} => ${this.otherChain(source)}`);
            if (packets.length === 0) {
                return [];
            }
            const { src, dest } = this.getEnds(source);
            // check if we need to update client at all
            const neededHeight = Math.max(...packets.map((x) => x.height)) + 1;
            const headerHeight = yield this.updateClientToHeight(source, neededHeight);
            const submit = packets.map(({ packet }) => packet);
            const proofs = yield Promise.all(submit.map((packet) => src.client.getPacketProof(packet, headerHeight)));
            const { logs, height } = yield dest.client.receivePackets(submit, proofs, headerHeight);
            const acks = utils_2.parseAcksFromLogs(logs);
            return acks.map((ack) => (Object.assign({ height }, ack)));
        });
    }
    // this will update the client if needed and relay all provided acks from src -> dest
    // (yes, dest is where the packet was sent, but the ack was written on src).
    // if acks are all older than the last consensusHeight, then we don't update the client.
    //
    // Returns the block height the acks were included in, or null if no acks sent
    relayAcks(source, acks) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Relay ${acks.length} acks from ${this.chain(source)} => ${this.otherChain(source)}`);
            if (acks.length === 0) {
                return null;
            }
            const { src, dest } = this.getEnds(source);
            // check if we need to update client at all
            const neededHeight = Math.max(...acks.map((x) => x.height)) + 1;
            const headerHeight = yield this.updateClientToHeight(source, neededHeight);
            const proofs = yield Promise.all(acks.map((ack) => src.client.getAckProof(ack, headerHeight)));
            const { height } = yield dest.client.acknowledgePackets(acks, proofs, headerHeight);
            return height;
        });
    }
    // Source: the side that originally sent the packet
    // We need to relay a proof from dest -> source
    timeoutPackets(source, packets) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Timeout ${packets.length} packets sent from ${this.chain(source)}`);
            if (packets.length === 0) {
                return null;
            }
            const { src, dest } = this.getEnds(source);
            const destSide = otherSide(source);
            // We need a header that is after the timeout, not after the packet was committed
            // This can get complex with timeout timestamps. Let's just update to latest
            yield dest.client.waitOneBlock();
            const headerHeight = yield this.updateClient(destSide);
            const rawPackets = packets.map(({ packet }) => packet);
            const proofAndSeqs = yield Promise.all(rawPackets.map((packet) => __awaiter(this, void 0, void 0, function* () {
                const fakeAck = {
                    originalPacket: packet,
                    acknowledgement: new Uint8Array(),
                };
                const { nextSequenceReceive: sequence } = yield dest.client.query.ibc.channel.nextSequenceReceive(packet.destinationPort, packet.destinationChannel);
                const proof = yield dest.client.getTimeoutProof(fakeAck, headerHeight);
                return { proof, sequence };
            })));
            const proofs = proofAndSeqs.map(({ proof }) => proof);
            const seqs = proofAndSeqs.map(({ sequence }) => sequence);
            const { height } = yield src.client.timeoutPackets(rawPackets, proofs, seqs, headerHeight);
            return height;
        });
    }
    getEnds(src) {
        if (src === 'A') {
            return {
                src: this.endA,
                dest: this.endB,
            };
        }
        else {
            return {
                src: this.endB,
                dest: this.endA,
            };
        }
    }
}
exports.Link = Link;
const idDelim = ':';
const packetId = (packet) => `${packet.destinationPort}${idDelim}${packet.destinationChannel}`;
const ackId = (packet) => `${packet.sourcePort}${idDelim}${packet.sourceChannel}`;
function createClients(nodeA, nodeB, 
// number of seconds the client (on B pointing to A) is valid without update
trustPeriodA, 
// number of seconds the client (on A pointing to B) is valid without update
trustPeriodB) {
    return __awaiter(this, void 0, void 0, function* () {
        // client on B pointing to A
        const args = yield ibcclient_1.buildCreateClientArgs(nodeA, trustPeriodA);
        const { clientId: clientIdB } = yield nodeB.createTendermintClient(args.clientState, args.consensusState);
        // client on A pointing to B
        const args2 = yield ibcclient_1.buildCreateClientArgs(nodeB, trustPeriodB);
        const { clientId: clientIdA } = yield nodeA.createTendermintClient(args2.clientState, args2.consensusState);
        return [clientIdA, clientIdB];
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGluay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbGluay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx5Q0FBbUQ7QUFFbkQsa0VBQTRFO0FBRzVFLHlDQUtvQjtBQUNwQiwyQ0FNcUI7QUFDckIscUNBQThDO0FBQzlDLG1DQU1pQjtBQVFqQixTQUFnQixTQUFTLENBQUMsSUFBVTtJQUNsQyxJQUFJLElBQUksS0FBSyxHQUFHLEVBQUU7UUFDaEIsT0FBTyxHQUFHLENBQUM7S0FDWjtTQUFNO1FBQ0wsT0FBTyxHQUFHLENBQUM7S0FDWjtBQUNILENBQUM7QUFORCw4QkFNQztBQVdEOzs7Ozs7R0FNRztBQUNILE1BQWEsSUFBSTtJQWdPZiw4REFBOEQ7SUFDOUQsMENBQTBDO0lBQzFDLFlBQW1CLElBQWMsRUFBRSxJQUFjLEVBQUUsTUFBZTtRQUNoRSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sYUFBTixNQUFNLGNBQU4sTUFBTSxHQUFJLElBQUksbUJBQVUsRUFBRSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUNwQyxDQUFDO0lBaE9PLEtBQUssQ0FBQyxJQUFVO1FBQ3RCLElBQUksSUFBSSxLQUFLLEdBQUcsRUFBRTtZQUNoQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7U0FDcEI7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztTQUNwQjtJQUNILENBQUM7SUFFTyxVQUFVLENBQUMsSUFBVTtRQUMzQixJQUFJLElBQUksS0FBSyxHQUFHLEVBQUU7WUFDaEIsT0FBTyxJQUFJ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