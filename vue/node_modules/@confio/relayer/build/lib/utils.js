"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.presentPacketData = exports.splitPendingPackets = exports.timeGreater = exports.heightGreater = exports.parseAck = exports.parseAcksFromLogs = exports.parsePacket = exports.parseHeightAttribute = exports.parsePacketsFromLogs = exports.parsePacketsFromBlockResult = exports.buildClientState = exports.buildConsensusState = exports.secondsFromDateNanos = exports.timestampFromDateNanos = exports.mapRpcPubKeyToProto = exports.may = exports.parseRevisionNumber = exports.subtractBlock = exports.ensureIntHeight = exports.toIntHeight = exports.createBroadcastTxErrorMessage = void 0;
const encoding_1 = require("@cosmjs/encoding");
const stargate_1 = require("@cosmjs/stargate");
const { parseEvent } = stargate_1.logs;
const long_1 = __importDefault(require("long"));
const proofs_1 = require("../codec/confio/proofs");
const timestamp_1 = require("../codec/google/protobuf/timestamp");
const channel_1 = require("../codec/ibc/core/channel/v1/channel");
const tendermint_1 = require("../codec/ibc/lightclients/tendermint/v1/tendermint");
function createBroadcastTxErrorMessage(result) {
    return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;
}
exports.createBroadcastTxErrorMessage = createBroadcastTxErrorMessage;
function toIntHeight(height) {
    var _a, _b;
    return (_b = (_a = height === null || height === void 0 ? void 0 : height.revisionHeight) === null || _a === void 0 ? void 0 : _a.toNumber()) !== null && _b !== void 0 ? _b : 0;
}
exports.toIntHeight = toIntHeight;
function ensureIntHeight(height) {
    if (typeof height === 'number') {
        return height;
    }
    return toIntHeight(height);
}
exports.ensureIntHeight = ensureIntHeight;
function subtractBlock(height, count = 1) {
    return {
        revisionNumber: height.revisionNumber,
        revisionHeight: height.revisionHeight.subtract(count),
    };
}
exports.subtractBlock = subtractBlock;
const regexRevNum = new RegExp('-([1-9][0-9]*)$');
function parseRevisionNumber(chainId) {
    const match = chainId.match(regexRevNum);
    if (match && match.length >= 2) {
        return long_1.default.fromString(match[1]);
    }
    return new long_1.default(0);
}
exports.parseRevisionNumber = parseRevisionNumber;
// may will run the transform if value is defined, otherwise returns undefined
function may(transform, value) {
    return value === undefined || value === null ? undefined : transform(value);
}
exports.may = may;
function mapRpcPubKeyToProto(pubkey) {
    if (pubkey === undefined) {
        return undefined;
    }
    if (pubkey.algorithm == 'ed25519') {
        return {
            ed25519: pubkey.data,
            secp256k1: undefined,
        };
    }
    else if (pubkey.algorithm == 'secp256k1') {
        return {
            ed25519: undefined,
            secp256k1: pubkey.data,
        };
    }
    else {
        throw new Error(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        `Unknown validator pubkey type: ${pubkey.algorithm}`);
    }
}
exports.mapRpcPubKeyToProto = mapRpcPubKeyToProto;
function timestampFromDateNanos(date) {
    var _a;
    const nanos = (date.getTime() % 1000) * 1000000 + ((_a = date.nanoseconds) !== null && _a !== void 0 ? _a : 0);
    return timestamp_1.Timestamp.fromPartial({
        seconds: new long_1.default(date.getTime() / 1000),
        nanos,
    });
}
exports.timestampFromDateNanos = timestampFromDateNanos;
function secondsFromDateNanos(date) {
    return Math.floor(date.getTime() / 1000);
}
exports.secondsFromDateNanos = secondsFromDateNanos;
function buildConsensusState(header) {
    return tendermint_1.ConsensusState.fromPartial({
        timestamp: timestampFromDateNanos(header.time),
        root: {
            hash: header.appHash,
        },
        nextValidatorsHash: header.nextValidatorsHash,
    });
}
exports.buildConsensusState = buildConsensusState;
// Note: we hardcode a number of assumptions, like trust level, clock drift, and assume revisionNumber is 1
function buildClientState(chainId, unbondingPeriodSec, trustPeriodSec, height) {
    // Copied here until https://github.com/confio/ics23/issues/36 is resolved
    // https://github.com/confio/ics23/blob/master/js/src/proofs.ts#L11-L26
    const iavlSpec = {
        leafSpec: {
            prefix: Uint8Array.from([0]),
            hash: proofs_1.HashOp.SHA256,
            prehashValue: proofs_1.HashOp.SHA256,
            prehashKey: proofs_1.HashOp.NO_HASH,
            length: proofs_1.LengthOp.VAR_PROTO,
        },
        innerSpec: {
            childOrder: [0, 1],
            minPrefixLength: 4,
            maxPrefixLength: 12,
            childSize: 33,
            hash: proofs_1.HashOp.SHA256,
        },
    };
    const tendermintSpec = {
        leafSpec: {
            prefix: Uint8Array.from([0]),
            hash: proofs_1.HashOp.SHA256,
            prehashValue: proofs_1.HashOp.SHA256,
            prehashKey: proofs_1.HashOp.NO_HASH,
            length: proofs_1.LengthOp.VAR_PROTO,
        },
        innerSpec: {
            childOrder: [0, 1],
            minPrefixLength: 1,
            maxPrefixLength: 1,
            childSize: 32,
            hash: proofs_1.HashOp.SHA256,
        },
    };
    return tendermint_1.ClientState.fromPartial({
        chainId,
        trustLevel: {
            numerator: long_1.default.fromInt(1),
            denominator: long_1.default.fromInt(3),
        },
        unbondingPeriod: {
            seconds: new long_1.default(unbondingPeriodSec),
        },
        trustingPeriod: {
            seconds: new long_1.default(trustPeriodSec),
        },
        maxClockDrift: {
            seconds: new long_1.default(20),
        },
        latestHeight: height,
        proofSpecs: [iavlSpec, tendermintSpec],
        upgradePath: ['upgrade', 'upgradedIBCState'],
        allowUpdateAfterExpiry: false,
        allowUpdateAfterMisbehaviour: false,
    });
}
exports.buildClientState = buildClientState;
function decodeBase64(value) {
    return Buffer.from(value).toString('binary');
}
function parsePacketsFromBlockResult(result) {
    const allEvents = result.beginBlockEvents
        .concat(...result.endBlockEvents)
        .filter(({ type }) => type === 'send_packet')
        .map(({ type, attributes }) => ({
        type,
        attributes: attributes.map(({ key, value }) => ({
            key: decodeBase64(key),
            value: decodeBase64(value),
        })),
    }));
    const flatEvents = [].concat(allEvents.map(parseEvent));
    return flatEvents.map(parsePacket);
}
exports.parsePacketsFromBlockResult = parsePacketsFromBlockResult;
function parsePacketsFromLogs(logs) {
    // grab all send_packet events from the logs
    const allEvents = logs.map((log) => log.events.filter(({ type }) => type === 'send_packet'));
    const flatEvents = [].concat(...allEvents);
    return flatEvents.map(parsePacket);
}
exports.parsePacketsFromLogs = parsePacketsFromLogs;
function parseHeightAttribute(attribute) {
    var _a;
    const [timeoutRevisionNumber, timeoutRevisionHeight] = (_a = attribute === null || attribute === void 0 ? void 0 : attribute.split('-')) !== null && _a !== void 0 ? _a : [];
    if (!timeoutRevisionHeight || !timeoutRevisionNumber) {
        return undefined;
    }
    const revisionNumber = long_1.default.fromString(timeoutRevisionNumber);
    const revisionHeight = long_1.default.fromString(timeoutRevisionHeight);
    // note: 0 revisionNumber is allowed. If there is bad data, '' or '0-0', we will get 0 for the height
    if (revisionHeight.isZero()) {
        return undefined;
    }
    return { revisionHeight, revisionNumber };
}
exports.parseHeightAttribute = parseHeightAttribute;
function parsePacket({ type, attributes }) {
    if (type !== 'send_packet') {
        throw new Error(`Cannot parse event of type ${type}`);
    }
    const attributesObj = attributes.reduce((acc, { key, value }) => (Object.assign(Object.assign({}, acc), { [key]: value })), {});
    return channel_1.Packet.fromPartial({
        sequence: may(long_1.default.fromString, attributesObj.packet_sequence),
        /** identifies the port on the sending chain. */
        sourcePort: attributesObj.packet_src_port,
        /** identifies the channel end on the sending chain. */
        sourceChannel: attributesObj.packet_src_channel,
        /** identifies the port on the receiving chain. */
        destinationPort: attributesObj.packet_dst_port,
        /** identifies the channel end on the receiving chain. */
        destinationChannel: attributesObj.packet_dst_channel,
        /** actual opaque bytes transferred directly to the application module */
        data: attributesObj.packet_data
            ? encoding_1.toUtf8(attributesObj.packet_data)
            : undefined,
        /** block height after which the packet times out */
        timeoutHeight: parseHeightAttribute(attributesObj.packet_timeout_height),
        /** block timestamp (in nanoseconds) after which the packet times out */
        timeoutTimestamp: may(long_1.default.fromString, attributesObj.packet_timeout_timestamp),
    });
}
exports.parsePacket = parsePacket;
function parseAcksFromLogs(logs) {
    // grab all send_packet events from the logs
    const allEvents = logs.map((log) => log.events.filter(({ type }) => type === 'write_acknowledgement'));
    const flatEvents = [].concat(...allEvents);
    return flatEvents.map(parseAck);
}
exports.parseAcksFromLogs = parseAcksFromLogs;
function parseAck({ type, attributes }) {
    var _a, _b;
    if (type !== 'write_acknowledgement') {
        throw new Error(`Cannot parse event of type ${type}`);
    }
    const attributesObj = attributes.reduce((acc, { key, value }) => (Object.assign(Object.assign({}, acc), { [key]: value })), {});
    const originalPacket = channel_1.Packet.fromPartial({
        sequence: may(long_1.default.fromString, attributesObj.packet_sequence),
        /** identifies the port on the sending chain. */
        sourcePort: attributesObj.packet_src_port,
        /** identifies the channel end on the sending chain. */
        sourceChannel: attributesObj.packet_src_channel,
        /** identifies the port on the receiving chain. */
        destinationPort: attributesObj.packet_dst_port,
        /** identifies the channel end on the receiving chain. */
        destinationChannel: attributesObj.packet_dst_channel,
        /** actual opaque bytes transferred directly to the application module */
        data: encoding_1.toUtf8((_a = attributesObj.packet_data) !== null && _a !== void 0 ? _a : ''),
        /** block height after which the packet times out */
        timeoutHeight: parseHeightAttribute(attributesObj.packet_timeout_height),
        /** block timestamp (in nanoseconds) after which the packet times out */
        timeoutTimestamp: may(long_1.default.fromString, attributesObj.packet_timeout_timestamp),
    });
    const acknowledgement = encoding_1.toUtf8((_b = attributesObj.packet_ack) !== null && _b !== void 0 ? _b : '');
    return {
        acknowledgement,
        originalPacket,
    };
}
exports.parseAck = parseAck;
// return true if a > b, or a undefined
function heightGreater(a, b) {
    if (a === undefined) {
        return true;
    }
    // comparing longs made some weird issues (maybe signed/unsigned)?
    // convert to numbers to compare safely
    const [numA, heightA, numB, heightB] = [
        a.revisionNumber.toNumber(),
        a.revisionHeight.toNumber(),
        b.revisionNumber.toNumber(),
        b.revisionHeight.toNumber(),
    ];
    const valid = numA > numB || (numA == numB && heightA > heightB);
    return valid;
}
exports.heightGreater = heightGreater;
// return true if a > b, or a 0
// note a is nanoseconds, while b is seconds
function timeGreater(a, b) {
    if (a === undefined || a.isZero()) {
        return true;
    }
    const valid = a.toNumber() > b * 1000000000;
    return valid;
}
exports.timeGreater = timeGreater;
// take height and time from receiving chain to see which packets have timed out
// return [toSubmit, toTimeout].
// you can advance height, time a block or two into the future if you wish a margin of error
function splitPendingPackets(currentHeight, currentTime, // in seconds
packets) {
    return packets.reduce((acc, packet) => {
        const validPacket = heightGreater(packet.packet.timeoutHeight, currentHeight) &&
            timeGreater(packet.packet.timeoutTimestamp, currentTime);
        return validPacket
            ? Object.assign(Object.assign({}, acc), { toSubmit: [...acc.toSubmit, packet] }) : Object.assign(Object.assign({}, acc), { toTimeout: [...acc.toTimeout, packet] });
    }, {
        toSubmit: [],
        toTimeout: [],
    });
}
exports.splitPendingPackets = splitPendingPackets;
function presentPacketData(data) {
    try {
        return JSON.parse(encoding_1.fromUtf8(data));
    }
    catch (_a) {
        return { hex: encoding_1.toHex(data) };
    }
}
exports.presentPacketData = presentPacketData;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLCtDQUEyRDtBQUMzRCwrQ0FBNEQ7QUFDNUQsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLGVBQUksQ0FBQztBQU81QixnREFBd0I7QUFFeEIsbURBQTBEO0FBQzFELGtFQUErRDtBQUMvRCxrRUFBOEQ7QUFFOUQsbUZBRzREO0FBVTVELFNBQWdCLDZCQUE2QixDQUMzQyxNQUEwQjtJQUUxQixPQUFPLDhCQUE4QixNQUFNLENBQUMsZUFBZSxjQUFjLE1BQU0sQ0FBQyxNQUFNLFdBQVcsTUFBTSxDQUFDLElBQUksY0FBYyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDNUksQ0FBQztBQUpELHNFQUlDO0FBRUQsU0FBZ0IsV0FBVyxDQUFDLE1BQWU7O0lBQ3pDLE9BQU8sTUFBQSxNQUFBLE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxjQUFjLDBDQUFFLFFBQVEsRUFBRSxtQ0FBSSxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUZELGtDQUVDO0FBRUQsU0FBZ0IsZUFBZSxDQUFDLE1BQXVCO0lBQ3JELElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1FBQzlCLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFDRCxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBTEQsMENBS0M7QUFFRCxTQUFnQixhQUFhLENBQUMsTUFBYyxFQUFFLEtBQUssR0FBRyxDQUFDO0lBQ3JELE9BQU87UUFDTCxjQUFjLEVBQUUsTUFBTSxDQUFDLGNBQWM7UUFDckMsY0FBYyxFQUFFLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztLQUN0RCxDQUFDO0FBQ0osQ0FBQztBQUxELHNDQUtDO0FBRUQsTUFBTSxXQUFXLEdBQUcsSUFBSSxNQUFNLENBQUMsaUJBQWlC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