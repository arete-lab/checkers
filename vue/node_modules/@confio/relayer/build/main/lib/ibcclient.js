"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareChannelHandshake = exports.prepareConnectionHandshake = exports.buildCreateClientArgs = exports.IbcClient = void 0;
const encoding_1 = require("@cosmjs/encoding");
const launchpad_1 = require("@cosmjs/launchpad");
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const tendermint_rpc_1 = require("@cosmjs/tendermint-rpc");
const utils_1 = require("@cosmjs/utils");
const long_1 = __importDefault(require("long"));
const tx_1 = require("../codec/ibc/applications/transfer/v1/tx");
const channel_1 = require("../codec/ibc/core/channel/v1/channel");
const tx_2 = require("../codec/ibc/core/channel/v1/tx");
const client_1 = require("../codec/ibc/core/client/v1/client");
const tx_3 = require("../codec/ibc/core/client/v1/tx");
const tx_4 = require("../codec/ibc/core/connection/v1/tx");
const tendermint_1 = require("../codec/ibc/lightclients/tendermint/v1/tendermint");
const types_1 = require("../codec/tendermint/types/types");
const validator_1 = require("../codec/tendermint/types/validator");
const logger_1 = require("./logger");
const ibc_1 = require("./queries/ibc");
const utils_2 = require("./utils");
/**** These are needed to bootstrap the endpoints */
/* Some of them are hardcoded various places, which should we make configurable? */
// const DefaultTrustLevel = '1/3';
// const MaxClockDrift = 10; // 10 seconds
// const upgradePath = ['upgrade', 'upgradedIBCState'];
// const allowUpgradeAfterExpiry = false;
// const allowUpgradeAfterMisbehavior = false;
// these are from the cosmos sdk implementation
const defaultMerklePrefix = {
    keyPrefix: encoding_1.toAscii('ibc'),
};
const defaultConnectionVersion = {
    identifier: '1',
    features: ['ORDER_ORDERED', 'ORDER_UNORDERED'],
};
// this is a sane default, but we can revisit it
const defaultDelayPeriod = new long_1.default(0);
function ibcRegistry() {
    return new proto_signing_1.Registry([
        ...stargate_1.defaultRegistryTypes,
        ['/ibc.core.client.v1.MsgCreateClient', tx_3.MsgCreateClient],
        ['/ibc.core.client.v1.MsgUpdateClient', tx_3.MsgUpdateClient],
        ['/ibc.core.connection.v1.MsgConnectionOpenInit', tx_4.MsgConnectionOpenInit],
        ['/ibc.core.connection.v1.MsgConnectionOpenTry', tx_4.MsgConnectionOpenTry],
        ['/ibc.core.connection.v1.MsgConnectionOpenAck', tx_4.MsgConnectionOpenAck],
        [
            '/ibc.core.connection.v1.MsgConnectionOpenConfirm',
            tx_4.MsgConnectionOpenConfirm,
        ],
        ['/ibc.core.channel.v1.MsgChannelOpenInit', tx_2.MsgChannelOpenInit],
        ['/ibc.core.channel.v1.MsgChannelOpenTry', tx_2.MsgChannelOpenTry],
        ['/ibc.core.channel.v1.MsgChannelOpenAck', tx_2.MsgChannelOpenAck],
        ['/ibc.core.channel.v1.MsgChannelOpenConfirm', tx_2.MsgChannelOpenConfirm],
        ['/ibc.core.channel.v1.MsgRecvPacket', tx_2.MsgRecvPacket],
        ['/ibc.core.channel.v1.MsgAcknowledgement', tx_2.MsgAcknowledgement],
        ['/ibc.core.channel.v1.MsgTimeout', tx_2.MsgTimeout],
        ['/ibc.applications.transfer.v1.MsgTransfer', tx_1.MsgTransfer],
    ]);
}
const defaultGasPrice = launchpad_1.GasPrice.fromString('0.025ucosm');
const defaultGasLimits = {
    initClient: 150000,
    updateClient: 600000,
    initConnection: 150000,
    connectionHandshake: 300000,
    initChannel: 150000,
    channelHandshake: 300000,
    receivePacket: 300000,
    ackPacket: 300000,
    timeoutPacket: 300000,
    transfer: 180000,
};
class IbcClient {
    constructor(signingClient, tmClient, senderAddress, chainId, options) {
        this.sign = signingClient;
        this.tm = tmClient;
        this.query = stargate_1.QueryClient.withExtensions(tmClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, ibc_1.setupIbcExtension, stargate_1.setupStakingExtension);
        this.senderAddress = senderAddress;
        this.chainId = chainId;
        this.revisionNumber = utils_2.parseRevisionNumber(chainId);
        const { gasPrice = defaultGasPrice, gasLimits = {}, logger } = options;
        this.fees = launchpad_1.buildFeeTable(gasPrice, defaultGasLimits, gasLimits);
        this.logger = logger !== null && logger !== void 0 ? logger : new logger_1.NoopLogger();
    }
    static async connectWithSigner(endpoint, signer, senderAddress, options = {}) {
        // override any registry setup, use the other options
        const mergedOptions = Object.assign(Object.assign({}, options), { registry: ibcRegistry() });
        const signingClient = await stargate_1.SigningStargateClient.connectWithSigner(endpoint, signer, mergedOptions);
        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);
        const chainId = await signingClient.getChainId();
        return new IbcClient(signingClient, tmClient, senderAddress, chainId, options);
    }
    revisionHeight(height) {
        return client_1.Height.fromPartial({
            revisionHeight: new long_1.default(height),
            revisionNumber: this.revisionNumber,
        });
    }
    ensureRevisionHeight(height) {
        if (typeof height === 'number') {
            return client_1.Height.fromPartial({
                revisionHeight: long_1.default.fromNumber(height),
                revisionNumber: this.revisionNumber,
            });
        }
        if (height.revisionNumber.toNumber() !== this.revisionNumber.toNumber()) {
            throw new Error(`Using incorrect revisionNumber ${height.revisionNumber} on chain with ${this.revisionNumber}`);
        }
        return height;
    }
    async timeoutHeight(blocksInFuture) {
        const header = await this.latestHeader();
        return this.revisionHeight(header.height + blocksInFuture);
    }
    getChainId() {
        this.logger.verbose('Get chain ID');
        return this.sign.getChainId();
    }
    async header(height) {
        this.logger.verbose(`Get header for height ${height}`);
        // TODO: expose header method on tmClient and use that
        const resp = await this.tm.blockchain(height, height);
        return resp.blockMetas[0].header;
    }
    async latestHeader() {
        // TODO: expose header method on tmClient and use that
        const block = await this.tm.block();
        return block.block.header;
    }
    async currentTime() {
        // const status = await this.tm.status();
        // return status.syncInfo.latestBlockTime;
        return (await this.latestHeader()).time;
    }
    async currentHeight() {
        const status = await this.tm.status();
        return status.syncInfo.latestBlockHeight;
    }
    async currentRevision() {
        const block = await this.currentHeight();
        return this.revisionHeight(block);
    }
    async waitOneBlock() {
        // ensure this works
        const start = await this.currentHeight();
        let end;
        do {
            await utils_1.sleep(500);
            end = await this.currentHeight();
        } while (end === start);
        // TODO: this works but only for websocket connections, is there some code that falls back to polling in cosmjs?
        // await firstEvent(this.tm.subscribeNewBlockHeader());
    }
    // we may have to wait a bit before a tx returns and making queries on the event log
    async waitForIndexer() {
        await utils_1.sleep(50);
    }
    getCommit(height) {
        this.logger.verbose(height === undefined
            ? 'Get latest commit'
            : `Get commit for height ${height}`);
        return this.tm.commit(height);
    }
    /** Returns the unbonding period in seconds */
    async getUnbondingPeriod() {
        var _a, _b;
        const { params } = await this.query.staking.unverified.params();
        const seconds = (_b = (_a = params === null || params === void 0 ? void 0 : params.unbondingTime) === null || _a === void 0 ? void 0 : _a.seconds) === null || _b === void 0 ? void 0 : _b.toNumber();
        if (!seconds) {
            throw new Error('No unbonding period found');
        }
        this.logger.verbose('Queried unbonding period', { seconds });
        return seconds;
    }
    async getSignedHeader(height) {
        const { header: rpcHeader, commit: rpcCommit } = await this.getCommit(height);
        const header = types_1.Header.fromPartial(Object.assign(Object.assign({}, rpcHeader), { version: {
                block: new long_1.default(rpcHeader.version.block),
            }, height: new long_1.default(rpcHeader.height), time: utils_2.timestampFromDateNanos(rpcHeader.time), lastBlockId: {
                hash: rpcHeader.lastBlockId.hash,
                partSetHeader: rpcHeader.lastBlockId.parts,
            } }));
        const signatures = rpcCommit.signatures.map((sig) => (Object.assign(Object.assign({}, sig), { timestamp: sig.timestamp && utils_2.timestampFromDateNanos(sig.timestamp), blockIdFlag: types_1.blockIDFlagFromJSON(sig.blockIdFlag) })));
        const commit = types_1.Commit.fromPartial({
            height: new long_1.default(rpcCommit.height),
            round: rpcCommit.round,
            blockId: {
                hash: rpcCommit.blockId.hash,
                partSetHeader: rpcCommit.blockId.parts,
            },
            signatures,
        });
        // For the vote sign bytes, it checks (from the commit):
        //   Height, Round, BlockId, TimeStamp, ChainID
        return { header, commit };
    }
    async getValidatorSet(height) {
        this.logger.verbose(`Get validator set for height ${height}`);
        // we need to query the header to find out who the proposer was, and pull them out
        const { proposerAddress } = await this.header(height);
        const validators = await this.tm.validatorsAll(height);
        const mappedValidators = validators.validators.map((val) => ({
            address: val.address,
            pubKey: utils_2.mapRpcPubKeyToProto(val.pubkey),
            votingPower: new long_1.default(val.votingPower),
            proposerPriority: val.proposerPriority
                ? new long_1.default(val.proposerPriority)
                : undefined,
        }));
        const totalPower = validators.validators.reduce((x, v) => x + v.votingPower, 0);
        const proposer = mappedValidators.find((val) => utils_1.arrayContentEquals(val.address, proposerAddress));
        return validator_1.ValidatorSet.fromPartial({
            validators: mappedValidators,
            totalVotingPower: new long_1.default(totalPower),
            proposer,
        });
    }
    // this builds a header to update a remote client.
    // you must pass the last known height on the remote side so we can properly generate it.
    // it will update to the latest state of this chain.
    //
    // This is the logic that validates the returned struct:
    // ibc check: https://github.com/cosmos/cosmos-sdk/blob/v0.41.0/x/ibc/light-clients/07-tendermint/types/update.go#L87-L167
    // tendermint check: https://github.com/tendermint/tendermint/blob/v0.34.3/light/verifier.go#L19-L79
    // sign bytes: https://github.com/tendermint/tendermint/blob/v0.34.3/types/validator_set.go#L762-L821
    //   * https://github.com/tendermint/tendermint/blob/v0.34.3/types/validator_set.go#L807-L810
    //   * https://github.com/tendermint/tendermint/blob/v0.34.3/types/block.go#L780-L809
    //   * https://github.com/tendermint/tendermint/blob/bf9e36d02d2eb22f6fe8961d0d7d3d34307ba38e/types/canonical.go#L54-L65
    //
    // For the vote sign bytes, it checks (from the commit):
    //   Height, Round, BlockId, TimeStamp, ChainID
    async buildHeader(lastHeight) {
        const signedHeader = await this.getSignedHeader();
        // "assert that trustedVals is NextValidators of last trusted header"
        // https://github.com/cosmos/cosmos-sdk/blob/v0.41.0/x/ibc/light-clients/07-tendermint/types/update.go#L74
        const validatorHeight = lastHeight + 1;
        /* eslint @typescript-eslint/no-non-null-assertion: "off" */
        const curHeight = signedHeader.header.height.toNumber();
        return tendermint_1.Header.fromPartial({
            signedHeader,
            validatorSet: await this.getValidatorSet(curHeight),
            trustedHeight: this.revisionHeight(lastHeight),
            trustedValidators: await this.getValidatorSet(validatorHeight),
        });
    }
    // trustedHeight must be proven by the client on the destination chain
    // and include a proof for the connOpenInit (eg. must be 1 or more blocks after the
    // block connOpenInit Tx was in).
    //
    // pass a header height that was previously updated to on the remote chain using updateClient.
    // note: the queries will be for the block before this header, so the proofs match up (appHash is on H+1)
    async getConnectionProof(clientId, connectionId, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = utils_2.subtractBlock(proofHeight, 1);
        const { clientState, proof: proofClient, } = await this.query.ibc.proof.client.state(clientId, queryHeight);
        // This is the most recent state we have on this chain of the other
        const { latestHeight: consensusHeight, } = await this.query.ibc.client.stateTm(clientId);
        utils_1.assert(consensusHeight);
        // get the init proof
        const { proof: proofConnection, } = await this.query.ibc.proof.connection.connection(connectionId, queryHeight);
        // get the consensus proof
        const { proof: proofConsensus, } = await this.query.ibc.proof.client.consensusState(clientId, consensusHeight, queryHeight);
        return {
            clientId,
            clientState,
            connectionId,
            proofHeight,
            proofConnection,
            proofClient,
            proofConsensus,
            consensusHeight,
        };
    }
    // trustedHeight must be proven by the client on the destination chain
    // and include a proof for the connOpenInit (eg. must be 1 or more blocks after the
    // block connOpenInit Tx was in).
    //
    // pass a header height that was previously updated to on the remote chain using updateClient.
    // note: the queries will be for the block before this header, so the proofs match up (appHash is on H+1)
    async getChannelProof(id, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = utils_2.subtractBlock(proofHeight, 1);
        const { proof } = await this.query.ibc.proof.channel.channel(id.portId, id.channelId, queryHeight);
        return {
            id,
            proofHeight,
            proof,
        };
    }
    async getPacketProof(packet, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = utils_2.subtractBlock(proofHeight, 1);
        const { proof } = await this.query.ibc.proof.channel.packetCommitment(packet.sourcePort, packet.sourceChannel, packet.sequence, queryHeight);
        return proof;
    }
    async getAckProof({ originalPacket }, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = utils_2.subtractBlock(proofHeight, 1);
        const res = await this.query.ibc.proof.channel.packetAcknowledgement(originalPacket.destinationPort, originalPacket.destinationChannel, originalPacket.sequence.toNumber(), queryHeight);
        const { proof } = res;
        return proof;
    }
    async getTimeoutProof({ originalPacket }, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = utils_2.subtractBlock(proofHeight, 1);
        const proof = await this.query.ibc.proof.channel.receiptProof(originalPacket.destinationPort, originalPacket.destinationChannel, originalPacket.sequence.toNumber(), queryHeight);
        return proof;
    }
    /*
    These are helpers to query, build data and submit a message
    Currently all prefixed with doXxx, but please look for better naming
    */
    // Updates existing client on this chain with data from src chain.
    // Returns the height that was updated to.
    async doUpdateClient(clientId, src) {
        var _a, _b, _c, _d;
        const { latestHeight } = await this.query.ibc.client.stateTm(clientId);
        const header = await src.buildHeader(utils_2.toIntHeight(latestHeight));
        await this.updateTendermintClient(clientId, header);
        const height = (_d = (_c = (_b = (_a = header.signedHeader) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.height) === null || _c === void 0 ? void 0 : _c.toNumber()) !== null && _d !== void 0 ? _d : 0;
        return src.revisionHeight(height);
    }
    /***** These are all direct wrappers around message constructors ********/
    async sendTokens(recipientAddress, transferAmount, memo) {
        this.logger.verbose(`Send tokens to ${recipientAddress}`);
        this.logger.debug('Send tokens:', {
            senderAddress: this.senderAddress,
            recipientAddress,
            transferAmount,
            memo,
        });
        const result = await this.sign.sendTokens(this.senderAddress, recipientAddress, transferAmount, memo);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    /* Send any number of messages, you are responsible for encoding them */
    async sendMultiMsg(msgs, fees) {
        this.logger.verbose(`Broadcast multiple msgs`);
        this.logger.debug(`Multiple msgs:`, {
            msgs,
            fees,
        });
        const senderAddress = this.senderAddress;
        const result = await this.sign.signAndBroadcast(senderAddress, msgs, fees);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async createTendermintClient(clientState, consensusState) {
        this.logger.verbose(`Create Tendermint client`);
        const senderAddress = this.senderAddress;
        const createMsg = {
            typeUrl: '/ibc.core.client.v1.MsgCreateClient',
            value: tx_3.MsgCreateClient.fromPartial({
                signer: senderAddress,
                clientState: {
                    typeUrl: '/ibc.lightclients.tendermint.v1.ClientState',
                    value: tendermint_1.ClientState.encode(clientState).finish(),
                },
                consensusState: {
                    typeUrl: '/ibc.lightclients.tendermint.v1.ConsensusState',
                    value: tendermint_1.ConsensusState.encode(consensusState).finish(),
                },
            }),
        };
        this.logger.debug('MsgCreateClient', createMsg);
        const result = await this.sign.signAndBroadcast(senderAddress, [createMsg], this.fees.initClient);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        const clientId = launchpad_1.logs.findAttribute(parsedLogs, 'create_client', 'client_id').value;
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            clientId,
        };
    }
    async updateTendermintClient(clientId, header) {
        this.logger.verbose(`Update Tendermint client ${clientId}`);
        const senderAddress = this.senderAddress;
        const updateMsg = {
            typeUrl: '/ibc.core.client.v1.MsgUpdateClient',
            value: tx_3.MsgUpdateClient.fromPartial({
                signer: senderAddress,
                clientId,
                header: {
                    typeUrl: '/ibc.lightclients.tendermint.v1.Header',
                    value: tendermint_1.Header.encode(header).finish(),
                },
            }),
        };
        this.logger.debug(`MsgUpdateClient`, updateMsg);
        const result = await this.sign.signAndBroadcast(senderAddress, [updateMsg], this.fees.updateClient);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async connOpenInit(clientId, remoteClientId) {
        this.logger.info(`Connection open init: ${clientId} => ${remoteClientId}`);
        const senderAddress = this.senderAddress;
        const msg = {
            typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenInit',
            value: tx_4.MsgConnectionOpenInit.fromPartial({
                clientId,
                counterparty: {
                    clientId: remoteClientId,
                    prefix: defaultMerklePrefix,
                },
                version: defaultConnectionVersion,
                delayPeriod: defaultDelayPeriod,
                signer: senderAddress,
            }),
        };
        this.logger.debug(`MsgConnectionOpenInit`, msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.initConnection);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        const connectionId = launchpad_1.logs.findAttribute(parsedLogs, 'connection_open_init', 'connection_id').value;
        this.logger.debug(`Connection open init successful: ${connectionId}`);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            connectionId,
        };
    }
    async connOpenTry(myClientId, proof) {
        this.logger.info(`Connection open try: ${myClientId} => ${proof.clientId} (${proof.connectionId})`);
        const senderAddress = this.senderAddress;
        const { clientId, connectionId, clientState, proofHeight, proofConnection: proofInit, proofClient, proofConsensus, consensusHeight, } = proof;
        const msg = {
            typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenTry',
            value: tx_4.MsgConnectionOpenTry.fromPartial({
                clientId: myClientId,
                counterparty: {
                    clientId: clientId,
                    connectionId: connectionId,
                    prefix: defaultMerklePrefix,
                },
                delayPeriod: defaultDelayPeriod,
                counterpartyVersions: [defaultConnectionVersion],
                signer: senderAddress,
                clientState,
                proofHeight,
                proofInit,
                proofClient,
                proofConsensus,
                consensusHeight,
            }),
        };
        this.logger.debug('MsgConnectionOpenTry', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.connectionHandshake);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        const myConnectionId = launchpad_1.logs.findAttribute(parsedLogs, 'connection_open_try', 'connection_id').value;
        this.logger.debug(`Connection open try successful: ${myConnectionId} => ${connectionId}`);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            connectionId: myConnectionId,
        };
    }
    async connOpenAck(myConnectionId, proof) {
        this.logger.info(`Connection open ack: ${myConnectionId} => ${proof.connectionId}`);
        const senderAddress = this.senderAddress;
        const { connectionId, clientState, proofHeight, proofConnection: proofTry, proofClient, proofConsensus, consensusHeight, } = proof;
        const msg = {
            typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenAck',
            value: tx_4.MsgConnectionOpenAck.fromPartial({
                connectionId: myConnectionId,
                counterpartyConnectionId: connectionId,
                version: defaultConnectionVersion,
                signer: senderAddress,
                clientState,
                proofHeight,
                proofTry,
                proofClient,
                proofConsensus,
                consensusHeight,
            }),
        };
        this.logger.debug('MsgConnectionOpenAck', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.connectionHandshake);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async connOpenConfirm(myConnectionId, proof) {
        this.logger.info(`Connection open confirm: ${myConnectionId}`);
        const senderAddress = this.senderAddress;
        const { proofHeight, proofConnection: proofAck } = proof;
        const msg = {
            typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenConfirm',
            value: tx_4.MsgConnectionOpenConfirm.fromPartial({
                connectionId: myConnectionId,
                signer: senderAddress,
                proofHeight,
                proofAck,
            }),
        };
        this.logger.debug('MsgConnectionOpenConfirm', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.connectionHandshake);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async channelOpenInit(portId, remotePortId, ordering, connectionId, version) {
        this.logger.verbose(`Channel open init: ${portId} => ${remotePortId} (${connectionId})`);
        const senderAddress = this.senderAddress;
        const msg = {
            typeUrl: '/ibc.core.channel.v1.MsgChannelOpenInit',
            value: tx_2.MsgChannelOpenInit.fromPartial({
                portId,
                channel: {
                    state: channel_1.State.STATE_INIT,
                    ordering,
                    counterparty: {
                        portId: remotePortId,
                    },
                    connectionHops: [connectionId],
                    version,
                },
                signer: senderAddress,
            }),
        };
        this.logger.debug('MsgChannelOpenInit', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.initChannel);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        const channelId = launchpad_1.logs.findAttribute(parsedLogs, 'channel_open_init', 'channel_id').value;
        this.logger.debug(`Channel open init successful: ${channelId}`);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            channelId,
        };
    }
    async channelOpenTry(portId, remote, ordering, connectionId, version, counterpartyVersion, proof) {
        this.logger.verbose(`Channel open try: ${portId} => ${remote.portId} (${remote.channelId})`);
        const senderAddress = this.senderAddress;
        const { proofHeight, proof: proofInit } = proof;
        const msg = {
            typeUrl: '/ibc.core.channel.v1.MsgChannelOpenTry',
            value: tx_2.MsgChannelOpenTry.fromPartial({
                portId,
                counterpartyVersion,
                channel: {
                    state: channel_1.State.STATE_TRYOPEN,
                    ordering,
                    counterparty: remote,
                    connectionHops: [connectionId],
                    version,
                },
                proofInit,
                proofHeight,
                signer: senderAddress,
            }),
        };
        this.logger.debug('MsgChannelOpenTry', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.channelHandshake);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        const channelId = launchpad_1.logs.findAttribute(parsedLogs, 'channel_open_try', 'channel_id').value;
        this.logger.debug(`Channel open try successful: ${channelId} => ${remote.channelId})`);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            channelId,
        };
    }
    async channelOpenAck(portId, channelId, counterpartyChannelId, counterpartyVersion, proof) {
        this.logger.verbose(`Channel open ack for port ${portId}: ${channelId} => ${counterpartyChannelId}`);
        const senderAddress = this.senderAddress;
        const { proofHeight, proof: proofTry } = proof;
        const msg = {
            typeUrl: '/ibc.core.channel.v1.MsgChannelOpenAck',
            value: tx_2.MsgChannelOpenAck.fromPartial({
                portId,
                channelId,
                counterpartyChannelId,
                counterpartyVersion,
                proofTry,
                proofHeight,
                signer: senderAddress,
            }),
        };
        this.logger.debug('MsgChannelOpenAck', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.channelHandshake);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async channelOpenConfirm(portId, channelId, proof) {
        this.logger.verbose(`Chanel open confirm for port ${portId}: ${channelId} => ${proof.id.channelId}`);
        const senderAddress = this.senderAddress;
        const { proofHeight, proof: proofAck } = proof;
        const msg = {
            typeUrl: '/ibc.core.channel.v1.MsgChannelOpenConfirm',
            value: tx_2.MsgChannelOpenConfirm.fromPartial({
                portId,
                channelId,
                proofAck,
                proofHeight,
                signer: senderAddress,
            }),
        };
        this.logger.debug('MsgChannelOpenConfirm', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.channelHandshake);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    receivePacket(packet, proofCommitment, proofHeight) {
        return this.receivePackets([packet], [proofCommitment], proofHeight);
    }
    async receivePackets(packets, proofCommitments, proofHeight) {
        this.logger.verbose(`Receive ${packets.length} packets..`);
        if (packets.length !== proofCommitments.length) {
            throw new Error(`Have ${packets.length} packets, but ${proofCommitments.length} proofs`);
        }
        if (packets.length === 0) {
            throw new Error('Must submit at least 1 packet');
        }
        const senderAddress = this.senderAddress;
        const msgs = [];
        for (const i in packets) {
            const packet = packets[i];
            this.logger.verbose(`Sending packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, utils_2.presentPacketData(packet.data));
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgRecvPacket',
                value: tx_2.MsgRecvPacket.fromPartial({
                    packet,
                    proofCommitment: proofCommitments[i],
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            msgs.push(msg);
        }
        this.logger.debug('MsgRecvPacket(s)', { msgs });
        const result = await this.sign.signAndBroadcast(senderAddress, msgs, utils_2.multiplyFees(this.fees.receivePacket, msgs.length));
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    acknowledgePacket(ack, proofAcked, proofHeight) {
        return this.acknowledgePackets([ack], [proofAcked], proofHeight);
    }
    async acknowledgePackets(acks, proofAckeds, proofHeight) {
        this.logger.verbose(`Acknowledge ${acks.length} packets...`);
        if (acks.length !== proofAckeds.length) {
            throw new Error(`Have ${acks.length} acks, but ${proofAckeds.length} proofs`);
        }
        if (acks.length === 0) {
            throw new Error('Must submit at least 1 ack');
        }
        const senderAddress = this.senderAddress;
        const msgs = [];
        for (const i in acks) {
            const packet = acks[i].originalPacket;
            const acknowledgement = acks[i].acknowledgement;
            this.logger.verbose(`Ack packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, {
                packet: utils_2.presentPacketData(packet.data),
                ack: utils_2.presentPacketData(acknowledgement),
            });
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgAcknowledgement',
                value: tx_2.MsgAcknowledgement.fromPartial({
                    packet,
                    acknowledgement,
                    proofAcked: proofAckeds[i],
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            msgs.push(msg);
        }
        this.logger.debug('MsgAcknowledgement(s)', { msgs });
        const result = await this.sign.signAndBroadcast(senderAddress, msgs, utils_2.multiplyFees(this.fees.ackPacket, msgs.length));
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    timeoutPacket(packet, proofUnreceived, nextSequenceRecv, proofHeight) {
        return this.timeoutPackets([packet], [proofUnreceived], [nextSequenceRecv], proofHeight);
    }
    async timeoutPackets(packets, proofsUnreceived, nextSequenceRecv, proofHeight) {
        if (packets.length !== proofsUnreceived.length) {
            throw new Error('Packets and proofs must be same length');
        }
        if (packets.length !== nextSequenceRecv.length) {
            throw new Error('Packets and sequences must be same length');
        }
        this.logger.verbose(`Timeout ${packets.length} packets...`);
        const senderAddress = this.senderAddress;
        const msgs = [];
        for (const i in packets) {
            const packet = packets[i];
            this.logger.verbose(`Timeout packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, utils_2.presentPacketData(packet.data));
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgTimeout',
                value: tx_2.MsgTimeout.fromPartial({
                    packet,
                    proofUnreceived: proofsUnreceived[i],
                    nextSequenceRecv: nextSequenceRecv[i],
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            msgs.push(msg);
        }
        this.logger.debug('MsgTimeout', { msgs });
        const result = await this.sign.signAndBroadcast(senderAddress, msgs, utils_2.multiplyFees(this.fees.timeoutPacket, msgs.length));
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async transferTokens(sourcePort, sourceChannel, token, receiver, timeoutHeight, 
    // timeout in seconds (we make nanoseconds below)
    timeoutTime) {
        this.logger.verbose(`Transfer tokens to ${receiver}`);
        const senderAddress = this.senderAddress;
        const timeoutTimestamp = timeoutTime
            ? long_1.default.fromNumber(timeoutTime * 1000000000)
            : undefined;
        const msg = {
            typeUrl: '/ibc.applications.transfer.v1.MsgTransfer',
            value: tx_1.MsgTransfer.fromPartial({
                sourcePort,
                sourceChannel,
                sender: senderAddress,
                token,
                receiver,
                timeoutHeight,
                timeoutTimestamp,
            }),
        };
        this.logger.debug('MsgTransfer', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.transfer);
        if (stargate_1.isBroadcastTxFailure(result)) {
            throw new Error(utils_2.createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = stargate_1.parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
}
exports.IbcClient = IbcClient;
// this will query for the unbonding period.
// if the trusting period is not set, it will use 2/3 of the unbonding period
async function buildCreateClientArgs(src, trustPeriodSec) {
    const header = await src.latestHeader();
    const consensusState = utils_2.buildConsensusState(header);
    const unbondingPeriodSec = await src.getUnbondingPeriod();
    if (trustPeriodSec === undefined) {
        trustPeriodSec = Math.floor((unbondingPeriodSec * 2) / 3);
    }
    const clientState = utils_2.buildClientState(src.chainId, unbondingPeriodSec, trustPeriodSec, src.revisionHeight(header.height));
    return { consensusState, clientState };
}
exports.buildCreateClientArgs = buildCreateClientArgs;
async function prepareConnectionHandshake(src, dest, clientIdSrc, clientIdDest, connIdSrc) {
    // ensure the last transaction was committed to the header (one block after it was included)
    await src.waitOneBlock();
    // update client on dest
    const headerHeight = await dest.doUpdateClient(clientIdDest, src);
    // get a proof (for the proven height)
    const proof = await src.getConnectionProof(clientIdSrc, connIdSrc, headerHeight);
    return proof;
}
exports.prepareConnectionHandshake = prepareConnectionHandshake;
async function prepareChannelHandshake(src, dest, clientIdDest, portId, channelId) {
    // ensure the last transaction was committed to the header (one block after it was included)
    await src.waitOneBlock();
    // update client on dest
    const headerHeight = await dest.doUpdateClient(clientIdDest, src);
    // get a proof (for the proven height)
    const proof = await src.getChannelProof({ portId, channelId }, headerHeight);
    return proof;
}
exports.prepareChannelHandshake = prepareChannelHandshake;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWJjY2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9pYmNjbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsK0NBQTJDO0FBQzNDLGlEQVEyQjtBQUMzQix5REFBOEU7QUFDOUUsK0NBYTBCO0FBQzFCLDJEQUtnQztBQUNoQyx5Q0FBa0U7QUFDbEUsZ0RBQXdCO0FBR3hCLGlFQUF1RTtBQUN2RSxrRUFBNEU7QUFDNUUsd0RBUXlDO0FBQ3pDLCtEQUE0RDtBQUM1RCx1REFHd0M7QUFFeEMsMkRBSzRDO0FBQzVDLG1GQUk0RDtBQUM1RCwyREFLeUM7QUFDekMsbUVBQW1FO0FBRW5FLHFDQUE4QztBQUM5Qyx1Q0FBZ0U7QUFDaEUsbUNBWWlCO0FBRWpCLG9EQUFvRDtBQUNwRCxtRkFBbUY7QUFDbkYsbUNBQW1DO0FBQ25DLDBDQUEwQztBQUMxQyx1REFBdUQ7QUFDdkQseUNBQXlDO0FBQ3pDLDhDQUE4QztBQUU5QywrQ0FBK0M7QUFDL0MsTUFBTSxtQkFBbUIsR0FBRztJQUMxQixTQUFTLEVBQUUsa0JBQU8sQ0FBQyxLQUFLLENBQUM7Q0FDMUIsQ0FBQztBQUNGLE1BQU0sd0JBQXdCLEdBQVk7SUFDeEMsVUFBVSxFQUFFLEdBQUc7SUFDZixRQUFRLEVBQUUsQ0FBQyxlQUFlLEVBQUUsaUJBQWlCLENBQUM7Q0FDL0MsQ0FBQztBQUNGLGdEQUFnRDtBQUNoRCxNQUFNLGtCQUFrQixHQUFHLElBQUksY0FBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRXZDLFNBQVMsV0FBVztJQUNsQixPQUFPLElBQUksd0JBQVEsQ0FBQztRQUNsQixHQUFHLCtCQUFvQjtRQUN2QixDQUFDLHFDQUFxQyxFQUFFLG9CQUFlLENBQUM7UUFDeEQsQ0FBQyxxQ0FBcUMsRUFBRSxvQkFBZSxDQUFDO1FBQ3hELENBQUMsK0NBQStDLEVBQUUsMEJBQXFCLENBQUM7UUFDeEUsQ0FBQyw4Q0FBOEMsRUFBRSx5QkFBb0Is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