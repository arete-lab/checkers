import { toAscii } from '@cosmjs/encoding';
import { buildFeeTable, GasPrice, logs, } from '@cosmjs/launchpad';
import { Registry } from '@cosmjs/proto-signing';
import { defaultRegistryTypes, isBroadcastTxFailure, parseRawLog, QueryClient, setupAuthExtension, setupBankExtension, setupStakingExtension, SigningStargateClient, } from '@cosmjs/stargate';
import { Tendermint34Client, } from '@cosmjs/tendermint-rpc';
import { arrayContentEquals, assert, sleep } from '@cosmjs/utils';
import Long from 'long';
import { MsgTransfer } from '../codec/ibc/applications/transfer/v1/tx';
import { State } from '../codec/ibc/core/channel/v1/channel';
import { MsgAcknowledgement, MsgChannelOpenAck, MsgChannelOpenConfirm, MsgChannelOpenInit, MsgChannelOpenTry, MsgRecvPacket, MsgTimeout, } from '../codec/ibc/core/channel/v1/tx';
import { Height } from '../codec/ibc/core/client/v1/client';
import { MsgCreateClient, MsgUpdateClient, } from '../codec/ibc/core/client/v1/tx';
import { MsgConnectionOpenAck, MsgConnectionOpenConfirm, MsgConnectionOpenInit, MsgConnectionOpenTry, } from '../codec/ibc/core/connection/v1/tx';
import { ClientState as TendermintClientState, ConsensusState as TendermintConsensusState, Header as TendermintHeader, } from '../codec/ibc/lightclients/tendermint/v1/tendermint';
import { blockIDFlagFromJSON, Commit, Header, } from '../codec/tendermint/types/types';
import { ValidatorSet } from '../codec/tendermint/types/validator';
import { NoopLogger } from './logger';
import { setupIbcExtension } from './queries/ibc';
import { buildClientState, buildConsensusState, createBroadcastTxErrorMessage, mapRpcPubKeyToProto, multiplyFees, parseRevisionNumber, presentPacketData, subtractBlock, timestampFromDateNanos, toIntHeight, } from './utils';
/**** These are needed to bootstrap the endpoints */
/* Some of them are hardcoded various places, which should we make configurable? */
// const DefaultTrustLevel = '1/3';
// const MaxClockDrift = 10; // 10 seconds
// const upgradePath = ['upgrade', 'upgradedIBCState'];
// const allowUpgradeAfterExpiry = false;
// const allowUpgradeAfterMisbehavior = false;
// these are from the cosmos sdk implementation
const defaultMerklePrefix = {
    keyPrefix: toAscii('ibc'),
};
const defaultConnectionVersion = {
    identifier: '1',
    features: ['ORDER_ORDERED', 'ORDER_UNORDERED'],
};
// this is a sane default, but we can revisit it
const defaultDelayPeriod = new Long(0);
function ibcRegistry() {
    return new Registry([
        ...defaultRegistryTypes,
        ['/ibc.core.client.v1.MsgCreateClient', MsgCreateClient],
        ['/ibc.core.client.v1.MsgUpdateClient', MsgUpdateClient],
        ['/ibc.core.connection.v1.MsgConnectionOpenInit', MsgConnectionOpenInit],
        ['/ibc.core.connection.v1.MsgConnectionOpenTry', MsgConnectionOpenTry],
        ['/ibc.core.connection.v1.MsgConnectionOpenAck', MsgConnectionOpenAck],
        [
            '/ibc.core.connection.v1.MsgConnectionOpenConfirm',
            MsgConnectionOpenConfirm,
        ],
        ['/ibc.core.channel.v1.MsgChannelOpenInit', MsgChannelOpenInit],
        ['/ibc.core.channel.v1.MsgChannelOpenTry', MsgChannelOpenTry],
        ['/ibc.core.channel.v1.MsgChannelOpenAck', MsgChannelOpenAck],
        ['/ibc.core.channel.v1.MsgChannelOpenConfirm', MsgChannelOpenConfirm],
        ['/ibc.core.channel.v1.MsgRecvPacket', MsgRecvPacket],
        ['/ibc.core.channel.v1.MsgAcknowledgement', MsgAcknowledgement],
        ['/ibc.core.channel.v1.MsgTimeout', MsgTimeout],
        ['/ibc.applications.transfer.v1.MsgTransfer', MsgTransfer],
    ]);
}
const defaultGasPrice = GasPrice.fromString('0.025ucosm');
const defaultGasLimits = {
    initClient: 150000,
    updateClient: 600000,
    initConnection: 150000,
    connectionHandshake: 300000,
    initChannel: 150000,
    channelHandshake: 300000,
    receivePacket: 300000,
    ackPacket: 300000,
    timeoutPacket: 300000,
    transfer: 180000,
};
export class IbcClient {
    constructor(signingClient, tmClient, senderAddress, chainId, options) {
        this.sign = signingClient;
        this.tm = tmClient;
        this.query = QueryClient.withExtensions(tmClient, setupAuthExtension, setupBankExtension, setupIbcExtension, setupStakingExtension);
        this.senderAddress = senderAddress;
        this.chainId = chainId;
        this.revisionNumber = parseRevisionNumber(chainId);
        const { gasPrice = defaultGasPrice, gasLimits = {}, logger } = options;
        this.fees = buildFeeTable(gasPrice, defaultGasLimits, gasLimits);
        this.logger = logger ?? new NoopLogger();
    }
    static async connectWithSigner(endpoint, signer, senderAddress, options = {}) {
        // override any registry setup, use the other options
        const mergedOptions = {
            ...options,
            registry: ibcRegistry(),
        };
        const signingClient = await SigningStargateClient.connectWithSigner(endpoint, signer, mergedOptions);
        const tmClient = await Tendermint34Client.connect(endpoint);
        const chainId = await signingClient.getChainId();
        return new IbcClient(signingClient, tmClient, senderAddress, chainId, options);
    }
    revisionHeight(height) {
        return Height.fromPartial({
            revisionHeight: new Long(height),
            revisionNumber: this.revisionNumber,
        });
    }
    ensureRevisionHeight(height) {
        if (typeof height === 'number') {
            return Height.fromPartial({
                revisionHeight: Long.fromNumber(height),
                revisionNumber: this.revisionNumber,
            });
        }
        if (height.revisionNumber.toNumber() !== this.revisionNumber.toNumber()) {
            throw new Error(`Using incorrect revisionNumber ${height.revisionNumber} on chain with ${this.revisionNumber}`);
        }
        return height;
    }
    async timeoutHeight(blocksInFuture) {
        const header = await this.latestHeader();
        return this.revisionHeight(header.height + blocksInFuture);
    }
    getChainId() {
        this.logger.verbose('Get chain ID');
        return this.sign.getChainId();
    }
    async header(height) {
        this.logger.verbose(`Get header for height ${height}`);
        // TODO: expose header method on tmClient and use that
        const resp = await this.tm.blockchain(height, height);
        return resp.blockMetas[0].header;
    }
    async latestHeader() {
        // TODO: expose header method on tmClient and use that
        const block = await this.tm.block();
        return block.block.header;
    }
    async currentTime() {
        // const status = await this.tm.status();
        // return status.syncInfo.latestBlockTime;
        return (await this.latestHeader()).time;
    }
    async currentHeight() {
        const status = await this.tm.status();
        return status.syncInfo.latestBlockHeight;
    }
    async currentRevision() {
        const block = await this.currentHeight();
        return this.revisionHeight(block);
    }
    async waitOneBlock() {
        // ensure this works
        const start = await this.currentHeight();
        let end;
        do {
            await sleep(500);
            end = await this.currentHeight();
        } while (end === start);
        // TODO: this works but only for websocket connections, is there some code that falls back to polling in cosmjs?
        // await firstEvent(this.tm.subscribeNewBlockHeader());
    }
    // we may have to wait a bit before a tx returns and making queries on the event log
    async waitForIndexer() {
        await sleep(50);
    }
    getCommit(height) {
        this.logger.verbose(height === undefined
            ? 'Get latest commit'
            : `Get commit for height ${height}`);
        return this.tm.commit(height);
    }
    /** Returns the unbonding period in seconds */
    async getUnbondingPeriod() {
        const { params } = await this.query.staking.unverified.params();
        const seconds = params?.unbondingTime?.seconds?.toNumber();
        if (!seconds) {
            throw new Error('No unbonding period found');
        }
        this.logger.verbose('Queried unbonding period', { seconds });
        return seconds;
    }
    async getSignedHeader(height) {
        const { header: rpcHeader, commit: rpcCommit } = await this.getCommit(height);
        const header = Header.fromPartial({
            ...rpcHeader,
            version: {
                block: new Long(rpcHeader.version.block),
            },
            height: new Long(rpcHeader.height),
            time: timestampFromDateNanos(rpcHeader.time),
            lastBlockId: {
                hash: rpcHeader.lastBlockId.hash,
                partSetHeader: rpcHeader.lastBlockId.parts,
            },
        });
        const signatures = rpcCommit.signatures.map((sig) => ({
            ...sig,
            timestamp: sig.timestamp && timestampFromDateNanos(sig.timestamp),
            blockIdFlag: blockIDFlagFromJSON(sig.blockIdFlag),
        }));
        const commit = Commit.fromPartial({
            height: new Long(rpcCommit.height),
            round: rpcCommit.round,
            blockId: {
                hash: rpcCommit.blockId.hash,
                partSetHeader: rpcCommit.blockId.parts,
            },
            signatures,
        });
        // For the vote sign bytes, it checks (from the commit):
        //   Height, Round, BlockId, TimeStamp, ChainID
        return { header, commit };
    }
    async getValidatorSet(height) {
        this.logger.verbose(`Get validator set for height ${height}`);
        // we need to query the header to find out who the proposer was, and pull them out
        const { proposerAddress } = await this.header(height);
        const validators = await this.tm.validatorsAll(height);
        const mappedValidators = validators.validators.map((val) => ({
            address: val.address,
            pubKey: mapRpcPubKeyToProto(val.pubkey),
            votingPower: new Long(val.votingPower),
            proposerPriority: val.proposerPriority
                ? new Long(val.proposerPriority)
                : undefined,
        }));
        const totalPower = validators.validators.reduce((x, v) => x + v.votingPower, 0);
        const proposer = mappedValidators.find((val) => arrayContentEquals(val.address, proposerAddress));
        return ValidatorSet.fromPartial({
            validators: mappedValidators,
            totalVotingPower: new Long(totalPower),
            proposer,
        });
    }
    // this builds a header to update a remote client.
    // you must pass the last known height on the remote side so we can properly generate it.
    // it will update to the latest state of this chain.
    //
    // This is the logic that validates the returned struct:
    // ibc check: https://github.com/cosmos/cosmos-sdk/blob/v0.41.0/x/ibc/light-clients/07-tendermint/types/update.go#L87-L167
    // tendermint check: https://github.com/tendermint/tendermint/blob/v0.34.3/light/verifier.go#L19-L79
    // sign bytes: https://github.com/tendermint/tendermint/blob/v0.34.3/types/validator_set.go#L762-L821
    //   * https://github.com/tendermint/tendermint/blob/v0.34.3/types/validator_set.go#L807-L810
    //   * https://github.com/tendermint/tendermint/blob/v0.34.3/types/block.go#L780-L809
    //   * https://github.com/tendermint/tendermint/blob/bf9e36d02d2eb22f6fe8961d0d7d3d34307ba38e/types/canonical.go#L54-L65
    //
    // For the vote sign bytes, it checks (from the commit):
    //   Height, Round, BlockId, TimeStamp, ChainID
    async buildHeader(lastHeight) {
        const signedHeader = await this.getSignedHeader();
        // "assert that trustedVals is NextValidators of last trusted header"
        // https://github.com/cosmos/cosmos-sdk/blob/v0.41.0/x/ibc/light-clients/07-tendermint/types/update.go#L74
        const validatorHeight = lastHeight + 1;
        /* eslint @typescript-eslint/no-non-null-assertion: "off" */
        const curHeight = signedHeader.header.height.toNumber();
        return TendermintHeader.fromPartial({
            signedHeader,
            validatorSet: await this.getValidatorSet(curHeight),
            trustedHeight: this.revisionHeight(lastHeight),
            trustedValidators: await this.getValidatorSet(validatorHeight),
        });
    }
    // trustedHeight must be proven by the client on the destination chain
    // and include a proof for the connOpenInit (eg. must be 1 or more blocks after the
    // block connOpenInit Tx was in).
    //
    // pass a header height that was previously updated to on the remote chain using updateClient.
    // note: the queries will be for the block before this header, so the proofs match up (appHash is on H+1)
    async getConnectionProof(clientId, connectionId, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = subtractBlock(proofHeight, 1);
        const { clientState, proof: proofClient, } = await this.query.ibc.proof.client.state(clientId, queryHeight);
        // This is the most recent state we have on this chain of the other
        const { latestHeight: consensusHeight, } = await this.query.ibc.client.stateTm(clientId);
        assert(consensusHeight);
        // get the init proof
        const { proof: proofConnection, } = await this.query.ibc.proof.connection.connection(connectionId, queryHeight);
        // get the consensus proof
        const { proof: proofConsensus, } = await this.query.ibc.proof.client.consensusState(clientId, consensusHeight, queryHeight);
        return {
            clientId,
            clientState,
            connectionId,
            proofHeight,
            proofConnection,
            proofClient,
            proofConsensus,
            consensusHeight,
        };
    }
    // trustedHeight must be proven by the client on the destination chain
    // and include a proof for the connOpenInit (eg. must be 1 or more blocks after the
    // block connOpenInit Tx was in).
    //
    // pass a header height that was previously updated to on the remote chain using updateClient.
    // note: the queries will be for the block before this header, so the proofs match up (appHash is on H+1)
    async getChannelProof(id, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = subtractBlock(proofHeight, 1);
        const { proof } = await this.query.ibc.proof.channel.channel(id.portId, id.channelId, queryHeight);
        return {
            id,
            proofHeight,
            proof,
        };
    }
    async getPacketProof(packet, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = subtractBlock(proofHeight, 1);
        const { proof } = await this.query.ibc.proof.channel.packetCommitment(packet.sourcePort, packet.sourceChannel, packet.sequence, queryHeight);
        return proof;
    }
    async getAckProof({ originalPacket }, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = subtractBlock(proofHeight, 1);
        const res = await this.query.ibc.proof.channel.packetAcknowledgement(originalPacket.destinationPort, originalPacket.destinationChannel, originalPacket.sequence.toNumber(), queryHeight);
        const { proof } = res;
        return proof;
    }
    async getTimeoutProof({ originalPacket }, headerHeight) {
        const proofHeight = this.ensureRevisionHeight(headerHeight);
        const queryHeight = subtractBlock(proofHeight, 1);
        const proof = await this.query.ibc.proof.channel.receiptProof(originalPacket.destinationPort, originalPacket.destinationChannel, originalPacket.sequence.toNumber(), queryHeight);
        return proof;
    }
    /*
    These are helpers to query, build data and submit a message
    Currently all prefixed with doXxx, but please look for better naming
    */
    // Updates existing client on this chain with data from src chain.
    // Returns the height that was updated to.
    async doUpdateClient(clientId, src) {
        const { latestHeight } = await this.query.ibc.client.stateTm(clientId);
        const header = await src.buildHeader(toIntHeight(latestHeight));
        await this.updateTendermintClient(clientId, header);
        const height = header.signedHeader?.header?.height?.toNumber() ?? 0;
        return src.revisionHeight(height);
    }
    /***** These are all direct wrappers around message constructors ********/
    async sendTokens(recipientAddress, transferAmount, memo) {
        this.logger.verbose(`Send tokens to ${recipientAddress}`);
        this.logger.debug('Send tokens:', {
            senderAddress: this.senderAddress,
            recipientAddress,
            transferAmount,
            memo,
        });
        const result = await this.sign.sendTokens(this.senderAddress, recipientAddress, transferAmount, memo);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    /* Send any number of messages, you are responsible for encoding them */
    async sendMultiMsg(msgs, fees) {
        this.logger.verbose(`Broadcast multiple msgs`);
        this.logger.debug(`Multiple msgs:`, {
            msgs,
            fees,
        });
        const senderAddress = this.senderAddress;
        const result = await this.sign.signAndBroadcast(senderAddress, msgs, fees);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async createTendermintClient(clientState, consensusState) {
        this.logger.verbose(`Create Tendermint client`);
        const senderAddress = this.senderAddress;
        const createMsg = {
            typeUrl: '/ibc.core.client.v1.MsgCreateClient',
            value: MsgCreateClient.fromPartial({
                signer: senderAddress,
                clientState: {
                    typeUrl: '/ibc.lightclients.tendermint.v1.ClientState',
                    value: TendermintClientState.encode(clientState).finish(),
                },
                consensusState: {
                    typeUrl: '/ibc.lightclients.tendermint.v1.ConsensusState',
                    value: TendermintConsensusState.encode(consensusState).finish(),
                },
            }),
        };
        this.logger.debug('MsgCreateClient', createMsg);
        const result = await this.sign.signAndBroadcast(senderAddress, [createMsg], this.fees.initClient);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        const clientId = logs.findAttribute(parsedLogs, 'create_client', 'client_id').value;
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            clientId,
        };
    }
    async updateTendermintClient(clientId, header) {
        this.logger.verbose(`Update Tendermint client ${clientId}`);
        const senderAddress = this.senderAddress;
        const updateMsg = {
            typeUrl: '/ibc.core.client.v1.MsgUpdateClient',
            value: MsgUpdateClient.fromPartial({
                signer: senderAddress,
                clientId,
                header: {
                    typeUrl: '/ibc.lightclients.tendermint.v1.Header',
                    value: TendermintHeader.encode(header).finish(),
                },
            }),
        };
        this.logger.debug(`MsgUpdateClient`, updateMsg);
        const result = await this.sign.signAndBroadcast(senderAddress, [updateMsg], this.fees.updateClient);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async connOpenInit(clientId, remoteClientId) {
        this.logger.info(`Connection open init: ${clientId} => ${remoteClientId}`);
        const senderAddress = this.senderAddress;
        const msg = {
            typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenInit',
            value: MsgConnectionOpenInit.fromPartial({
                clientId,
                counterparty: {
                    clientId: remoteClientId,
                    prefix: defaultMerklePrefix,
                },
                version: defaultConnectionVersion,
                delayPeriod: defaultDelayPeriod,
                signer: senderAddress,
            }),
        };
        this.logger.debug(`MsgConnectionOpenInit`, msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.initConnection);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        const connectionId = logs.findAttribute(parsedLogs, 'connection_open_init', 'connection_id').value;
        this.logger.debug(`Connection open init successful: ${connectionId}`);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            connectionId,
        };
    }
    async connOpenTry(myClientId, proof) {
        this.logger.info(`Connection open try: ${myClientId} => ${proof.clientId} (${proof.connectionId})`);
        const senderAddress = this.senderAddress;
        const { clientId, connectionId, clientState, proofHeight, proofConnection: proofInit, proofClient, proofConsensus, consensusHeight, } = proof;
        const msg = {
            typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenTry',
            value: MsgConnectionOpenTry.fromPartial({
                clientId: myClientId,
                counterparty: {
                    clientId: clientId,
                    connectionId: connectionId,
                    prefix: defaultMerklePrefix,
                },
                delayPeriod: defaultDelayPeriod,
                counterpartyVersions: [defaultConnectionVersion],
                signer: senderAddress,
                clientState,
                proofHeight,
                proofInit,
                proofClient,
                proofConsensus,
                consensusHeight,
            }),
        };
        this.logger.debug('MsgConnectionOpenTry', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.connectionHandshake);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        const myConnectionId = logs.findAttribute(parsedLogs, 'connection_open_try', 'connection_id').value;
        this.logger.debug(`Connection open try successful: ${myConnectionId} => ${connectionId}`);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            connectionId: myConnectionId,
        };
    }
    async connOpenAck(myConnectionId, proof) {
        this.logger.info(`Connection open ack: ${myConnectionId} => ${proof.connectionId}`);
        const senderAddress = this.senderAddress;
        const { connectionId, clientState, proofHeight, proofConnection: proofTry, proofClient, proofConsensus, consensusHeight, } = proof;
        const msg = {
            typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenAck',
            value: MsgConnectionOpenAck.fromPartial({
                connectionId: myConnectionId,
                counterpartyConnectionId: connectionId,
                version: defaultConnectionVersion,
                signer: senderAddress,
                clientState,
                proofHeight,
                proofTry,
                proofClient,
                proofConsensus,
                consensusHeight,
            }),
        };
        this.logger.debug('MsgConnectionOpenAck', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.connectionHandshake);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async connOpenConfirm(myConnectionId, proof) {
        this.logger.info(`Connection open confirm: ${myConnectionId}`);
        const senderAddress = this.senderAddress;
        const { proofHeight, proofConnection: proofAck } = proof;
        const msg = {
            typeUrl: '/ibc.core.connection.v1.MsgConnectionOpenConfirm',
            value: MsgConnectionOpenConfirm.fromPartial({
                connectionId: myConnectionId,
                signer: senderAddress,
                proofHeight,
                proofAck,
            }),
        };
        this.logger.debug('MsgConnectionOpenConfirm', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.connectionHandshake);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async channelOpenInit(portId, remotePortId, ordering, connectionId, version) {
        this.logger.verbose(`Channel open init: ${portId} => ${remotePortId} (${connectionId})`);
        const senderAddress = this.senderAddress;
        const msg = {
            typeUrl: '/ibc.core.channel.v1.MsgChannelOpenInit',
            value: MsgChannelOpenInit.fromPartial({
                portId,
                channel: {
                    state: State.STATE_INIT,
                    ordering,
                    counterparty: {
                        portId: remotePortId,
                    },
                    connectionHops: [connectionId],
                    version,
                },
                signer: senderAddress,
            }),
        };
        this.logger.debug('MsgChannelOpenInit', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.initChannel);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        const channelId = logs.findAttribute(parsedLogs, 'channel_open_init', 'channel_id').value;
        this.logger.debug(`Channel open init successful: ${channelId}`);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            channelId,
        };
    }
    async channelOpenTry(portId, remote, ordering, connectionId, version, counterpartyVersion, proof) {
        this.logger.verbose(`Channel open try: ${portId} => ${remote.portId} (${remote.channelId})`);
        const senderAddress = this.senderAddress;
        const { proofHeight, proof: proofInit } = proof;
        const msg = {
            typeUrl: '/ibc.core.channel.v1.MsgChannelOpenTry',
            value: MsgChannelOpenTry.fromPartial({
                portId,
                counterpartyVersion,
                channel: {
                    state: State.STATE_TRYOPEN,
                    ordering,
                    counterparty: remote,
                    connectionHops: [connectionId],
                    version,
                },
                proofInit,
                proofHeight,
                signer: senderAddress,
            }),
        };
        this.logger.debug('MsgChannelOpenTry', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.channelHandshake);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        const channelId = logs.findAttribute(parsedLogs, 'channel_open_try', 'channel_id').value;
        this.logger.debug(`Channel open try successful: ${channelId} => ${remote.channelId})`);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
            channelId,
        };
    }
    async channelOpenAck(portId, channelId, counterpartyChannelId, counterpartyVersion, proof) {
        this.logger.verbose(`Channel open ack for port ${portId}: ${channelId} => ${counterpartyChannelId}`);
        const senderAddress = this.senderAddress;
        const { proofHeight, proof: proofTry } = proof;
        const msg = {
            typeUrl: '/ibc.core.channel.v1.MsgChannelOpenAck',
            value: MsgChannelOpenAck.fromPartial({
                portId,
                channelId,
                counterpartyChannelId,
                counterpartyVersion,
                proofTry,
                proofHeight,
                signer: senderAddress,
            }),
        };
        this.logger.debug('MsgChannelOpenAck', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.channelHandshake);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async channelOpenConfirm(portId, channelId, proof) {
        this.logger.verbose(`Chanel open confirm for port ${portId}: ${channelId} => ${proof.id.channelId}`);
        const senderAddress = this.senderAddress;
        const { proofHeight, proof: proofAck } = proof;
        const msg = {
            typeUrl: '/ibc.core.channel.v1.MsgChannelOpenConfirm',
            value: MsgChannelOpenConfirm.fromPartial({
                portId,
                channelId,
                proofAck,
                proofHeight,
                signer: senderAddress,
            }),
        };
        this.logger.debug('MsgChannelOpenConfirm', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.channelHandshake);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    receivePacket(packet, proofCommitment, proofHeight) {
        return this.receivePackets([packet], [proofCommitment], proofHeight);
    }
    async receivePackets(packets, proofCommitments, proofHeight) {
        this.logger.verbose(`Receive ${packets.length} packets..`);
        if (packets.length !== proofCommitments.length) {
            throw new Error(`Have ${packets.length} packets, but ${proofCommitments.length} proofs`);
        }
        if (packets.length === 0) {
            throw new Error('Must submit at least 1 packet');
        }
        const senderAddress = this.senderAddress;
        const msgs = [];
        for (const i in packets) {
            const packet = packets[i];
            this.logger.verbose(`Sending packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, presentPacketData(packet.data));
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgRecvPacket',
                value: MsgRecvPacket.fromPartial({
                    packet,
                    proofCommitment: proofCommitments[i],
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            msgs.push(msg);
        }
        this.logger.debug('MsgRecvPacket(s)', { msgs });
        const result = await this.sign.signAndBroadcast(senderAddress, msgs, multiplyFees(this.fees.receivePacket, msgs.length));
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    acknowledgePacket(ack, proofAcked, proofHeight) {
        return this.acknowledgePackets([ack], [proofAcked], proofHeight);
    }
    async acknowledgePackets(acks, proofAckeds, proofHeight) {
        this.logger.verbose(`Acknowledge ${acks.length} packets...`);
        if (acks.length !== proofAckeds.length) {
            throw new Error(`Have ${acks.length} acks, but ${proofAckeds.length} proofs`);
        }
        if (acks.length === 0) {
            throw new Error('Must submit at least 1 ack');
        }
        const senderAddress = this.senderAddress;
        const msgs = [];
        for (const i in acks) {
            const packet = acks[i].originalPacket;
            const acknowledgement = acks[i].acknowledgement;
            this.logger.verbose(`Ack packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, {
                packet: presentPacketData(packet.data),
                ack: presentPacketData(acknowledgement),
            });
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgAcknowledgement',
                value: MsgAcknowledgement.fromPartial({
                    packet,
                    acknowledgement,
                    proofAcked: proofAckeds[i],
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            msgs.push(msg);
        }
        this.logger.debug('MsgAcknowledgement(s)', { msgs });
        const result = await this.sign.signAndBroadcast(senderAddress, msgs, multiplyFees(this.fees.ackPacket, msgs.length));
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    timeoutPacket(packet, proofUnreceived, nextSequenceRecv, proofHeight) {
        return this.timeoutPackets([packet], [proofUnreceived], [nextSequenceRecv], proofHeight);
    }
    async timeoutPackets(packets, proofsUnreceived, nextSequenceRecv, proofHeight) {
        if (packets.length !== proofsUnreceived.length) {
            throw new Error('Packets and proofs must be same length');
        }
        if (packets.length !== nextSequenceRecv.length) {
            throw new Error('Packets and sequences must be same length');
        }
        this.logger.verbose(`Timeout ${packets.length} packets...`);
        const senderAddress = this.senderAddress;
        const msgs = [];
        for (const i in packets) {
            const packet = packets[i];
            this.logger.verbose(`Timeout packet #${packet.sequence.toNumber()} from ${this.chainId}:${packet.sourceChannel}`, presentPacketData(packet.data));
            const msg = {
                typeUrl: '/ibc.core.channel.v1.MsgTimeout',
                value: MsgTimeout.fromPartial({
                    packet,
                    proofUnreceived: proofsUnreceived[i],
                    nextSequenceRecv: nextSequenceRecv[i],
                    proofHeight,
                    signer: senderAddress,
                }),
            };
            msgs.push(msg);
        }
        this.logger.debug('MsgTimeout', { msgs });
        const result = await this.sign.signAndBroadcast(senderAddress, msgs, multiplyFees(this.fees.timeoutPacket, msgs.length));
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
    async transferTokens(sourcePort, sourceChannel, token, receiver, timeoutHeight, 
    // timeout in seconds (we make nanoseconds below)
    timeoutTime) {
        this.logger.verbose(`Transfer tokens to ${receiver}`);
        const senderAddress = this.senderAddress;
        const timeoutTimestamp = timeoutTime
            ? Long.fromNumber(timeoutTime * 1000000000)
            : undefined;
        const msg = {
            typeUrl: '/ibc.applications.transfer.v1.MsgTransfer',
            value: MsgTransfer.fromPartial({
                sourcePort,
                sourceChannel,
                sender: senderAddress,
                token,
                receiver,
                timeoutHeight,
                timeoutTimestamp,
            }),
        };
        this.logger.debug('MsgTransfer', msg);
        const result = await this.sign.signAndBroadcast(senderAddress, [msg], this.fees.transfer);
        if (isBroadcastTxFailure(result)) {
            throw new Error(createBroadcastTxErrorMessage(result));
        }
        const parsedLogs = parseRawLog(result.rawLog);
        return {
            logs: parsedLogs,
            transactionHash: result.transactionHash,
            height: result.height,
        };
    }
}
// this will query for the unbonding period.
// if the trusting period is not set, it will use 2/3 of the unbonding period
export async function buildCreateClientArgs(src, trustPeriodSec) {
    const header = await src.latestHeader();
    const consensusState = buildConsensusState(header);
    const unbondingPeriodSec = await src.getUnbondingPeriod();
    if (trustPeriodSec === undefined) {
        trustPeriodSec = Math.floor((unbondingPeriodSec * 2) / 3);
    }
    const clientState = buildClientState(src.chainId, unbondingPeriodSec, trustPeriodSec, src.revisionHeight(header.height));
    return { consensusState, clientState };
}
export async function prepareConnectionHandshake(src, dest, clientIdSrc, clientIdDest, connIdSrc) {
    // ensure the last transaction was committed to the header (one block after it was included)
    await src.waitOneBlock();
    // update client on dest
    const headerHeight = await dest.doUpdateClient(clientIdDest, src);
    // get a proof (for the proven height)
    const proof = await src.getConnectionProof(clientIdSrc, connIdSrc, headerHeight);
    return proof;
}
export async function prepareChannelHandshake(src, dest, clientIdDest, portId, channelId) {
    // ensure the last transaction was committed to the header (one block after it was included)
    await src.waitOneBlock();
    // update client on dest
    const headerHeight = await dest.doUpdateClient(clientIdDest, src);
    // get a proof (for the proven height)
    const proof = await src.getChannelProof({ portId, channelId }, headerHeight);
    return proof;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWJjY2xpZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9pYmNjbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzNDLE9BQU8sRUFDTCxhQUFhLEVBSWIsUUFBUSxFQUNSLElBQUksR0FFTCxNQUFNLG1CQUFtQixDQUFDO0FBQzNCLE9BQU8sRUFBK0IsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUUsT0FBTyxFQUdMLG9CQUFvQixFQUNwQixvQkFBb0IsRUFDcEIsV0FBVyxFQUNYLFdBQVcsRUFDWCxrQkFBa0IsRUFDbEIsa0JBQWtCLEVBQ2xCLHFCQUFxQixFQUNyQixxQkFBcUIsR0FHdEIsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBSUwsa0JBQWtCLEdBQ25CLE1BQU0sd0JBQXdCLENBQUM7QUFDaEMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEUsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBR3hCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUN2RSxPQUFPLEVBQWlCLEtBQUssRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQzVFLE9BQU8sRUFDTCxrQkFBa0IsRUFDbEIsaUJBQWlCLEVBQ2pCLHFCQUFxQixFQUNyQixrQkFBa0IsRUFDbEIsaUJBQWlCLEVBQ2pCLGFBQWEsRUFDYixVQUFVLEdBQ1gsTUFBTSxpQ0FBaUMsQ0FBQztBQUN6QyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDNUQsT0FBTyxFQUNMLGVBQWUsRUFDZixlQUFlLEdBQ2hCLE1BQU0sZ0NBQWdDLENBQUM7QUFFeEMsT0FBTyxFQUNMLG9CQUFvQixFQUNwQix3QkFBd0IsRUFDeEIscUJBQXFCLEVBQ3JCLG9CQUFv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