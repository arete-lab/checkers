import { arrayContentEquals } from '@cosmjs/utils';
import { State } from '../codec/ibc/core/channel/v1/channel';
import { Endpoint, } from './endpoint';
import { buildCreateClientArgs, prepareChannelHandshake, prepareConnectionHandshake, } from './ibcclient';
import { NoopLogger } from './logger';
import { parseAcksFromLogs, secondsFromDateNanos, splitPendingPackets, timestampFromDateNanos, toIntHeight, } from './utils';
export function otherSide(side) {
    if (side === 'A') {
        return 'B';
    }
    else {
        return 'A';
    }
}
/**
 * Link represents a Connection between a pair of blockchains (Nodes).
 * An initialized Link requires a both sides to have a Client for the remote side
 * as well as an established Connection using those Clients. Channels can be added
 * and removed to a Link. There are constructors to find/create the basic requirements
 * if you don't know the client/connection IDs a priori.
 */
export class Link {
    // you can use this if you already have the info out of bounds
    // FIXME: check the validity of that data?
    constructor(endA, endB, logger) {
        this.endA = endA;
        this.endB = endB;
        this.logger = logger ?? new NoopLogger();
        this.chainA = endA.client.chainId;
        this.chainB = endB.client.chainId;
    }
    chain(side) {
        if (side === 'A') {
            return this.chainA;
        }
        else {
            return this.chainB;
        }
    }
    otherChain(side) {
        if (side === 'A') {
            return this.chainB;
        }
        else {
            return this.chainA;
        }
    }
    /**
     * findConnection attempts to reuse an existing Client/Connection.
     * If none exists, then it returns an error.
     *
     * @param nodeA
     * @param nodeB
     */
    static async createWithExistingConnections(nodeA, nodeB, connA, connB, logger) {
        const [chainA, chainB] = [nodeA.chainId, nodeB.chainId];
        const [{ connection: connectionA }, { connection: connectionB },] = await Promise.all([
            nodeA.query.ibc.connection.connection(connA),
            nodeB.query.ibc.connection.connection(connB),
        ]);
        if (!connectionA) {
            throw new Error(`[${chainA}] Connection not found for ID ${connA}`);
        }
        if (!connectionB) {
            throw new Error(`[${chainB}] Connection not found for ID ${connB}`);
        }
        if (!connectionA.counterparty) {
            throw new Error(`[${chainA}] Counterparty not found for connection with ID ${connA}`);
        }
        if (!connectionB.counterparty) {
            throw new Error(`[${chainB}] Counterparty not found for connection with ID ${connB}`);
        }
        // ensure the connection is open
        if (connectionA.state != State.STATE_OPEN) {
            throw new Error(`Connection on ${chainA} must be in state open, it has state ${connectionA.state}`);
        }
        if (connectionB.state != State.STATE_OPEN) {
            throw new Error(`Connection on ${chainB} must be in state open, it has state ${connectionB.state}`);
        }
        const [clientIdA, clientIdB] = [connectionA.clientId, connectionB.clientId];
        if (clientIdA !== connectionB.counterparty.clientId) {
            throw new Error(`Client ID ${connectionA.clientId} for connection with ID ${connA} does not match counterparty client ID ${connectionB.counterparty.clientId} for connection with ID ${connB}`);
        }
        if (clientIdB !== connectionA.counterparty.clientId) {
            throw new Error(`Client ID ${connectionB.clientId} for connection with ID ${connB} does not match counterparty client ID ${connectionA.counterparty.clientId} for connection with ID ${connA}`);
        }
        const [clientStateA, clientStateB] = await Promise.all([
            nodeA.query.ibc.client.stateTm(clientIdA),
            nodeB.query.ibc.client.stateTm(clientIdB),
        ]);
        if (nodeA.chainId !== clientStateB.chainId) {
            throw new Error(`Chain ID ${nodeA.chainId} for connection with ID ${connA} does not match remote chain ID ${clientStateA.chainId}`);
        }
        if (nodeB.chainId !== clientStateA.chainId) {
            throw new Error(`Chain ID ${nodeB.chainId} for connection with ID ${connB} does not match remote chain ID ${clientStateB.chainId}`);
        }
        const endA = new Endpoint(nodeA, clientIdA, connA);
        const endB = new Endpoint(nodeB, clientIdB, connB);
        const link = new Link(endA, endB, logger);
        await Promise.all([
            link.assertHeadersMatchConsensusState('A', clientIdA, clientStateA.latestHeight),
            link.assertHeadersMatchConsensusState('B', clientIdB, clientStateB.latestHeight),
        ]);
        return link;
    }
    /**
     * we do this assert inside createWithExistingConnections, but it could be a useful check
     * for submitting double-sign evidence later
     *
     * @param proofSide the side holding the consensus proof, we check the header from the other side
     * @param height the height of the consensus state and header we wish to compare
     */
    async assertHeadersMatchConsensusState(proofSide, clientId, height) {
        const { src, dest } = this.getEnds(proofSide);
        // Check headers match consensus state (at least validators)
        const [consensusState, header] = await Promise.all([
            src.client.query.ibc.client.consensusStateTm(clientId, height),
            dest.client.header(toIntHeight(height)),
        ]);
        // ensure consensus and headers match for next validator hashes
        if (!arrayContentEquals(consensusState.nextValidatorsHash, header.nextValidatorsHash)) {
            throw new Error(`NextValidatorHash doesn't match ConsensusState.`);
        }
        // ensure the committed apphash matches the actual node we have
        const hash = consensusState.root?.hash;
        if (!hash) {
            throw new Error(`ConsensusState.root.hash missing.`);
        }
        if (!arrayContentEquals(hash, header.appHash)) {
            throw new Error(`AppHash doesn't match ConsensusState.`);
        }
    }
    /**
     * createConnection will always create a new pair of clients and a Connection between the
     * two sides
     *
     * @param nodeA
     * @param nodeB
     */
    static async createWithNewConnections(nodeA, nodeB, logger, 
    // number of seconds the client (on B pointing to A) is valid without update
    trustPeriodA, 
    // number of seconds the client (on A pointing to B) is valid without update
    trustPeriodB) {
        const [clientIdA, clientIdB] = await createClients(nodeA, nodeB, trustPeriodA, trustPeriodB);
        // wait a block to ensure we have proper proofs for creating a connection (this has failed on CI before)
        await Promise.all([nodeA.waitOneBlock(), nodeB.waitOneBlock()]);
        // connectionInit on nodeA
        const { connectionId: connIdA } = await nodeA.connOpenInit(clientIdA, clientIdB);
        // connectionTry on nodeB
        const proof = await prepareConnectionHandshake(nodeA, nodeB, clientIdA, clientIdB, connIdA);
        const { connectionId: connIdB } = await nodeB.connOpenTry(clientIdB, proof);
        // connectionAck on nodeA
        const proofAck = await prepareConnectionHandshake(nodeB, nodeA, clientIdB, clientIdA, connIdB);
        await nodeA.connOpenAck(connIdA, proofAck);
        // connectionConfirm on dest
        const proofConfirm = await prepareConnectionHandshake(nodeA, nodeB, clientIdA, clientIdB, connIdA);
        await nodeB.connOpenConfirm(connIdB, proofConfirm);
        const endA = new Endpoint(nodeA, clientIdA, connIdA);
        const endB = new Endpoint(nodeB, clientIdB, connIdB);
        return new Link(endA, endB, logger);
    }
    /**
     * Writes the latest header from the sender chain to the other endpoint
     *
     * @param sender Which side we get the header/commit from
     * @returns header height (from sender) that is now known on dest
     *
     * Relayer binary should call this from a heartbeat which checks if needed and updates.
     * Just needs trusting period on both side
     */
    async updateClient(sender) {
        this.logger.info(`Update Client on ${this.otherChain(sender)}`);
        const { src, dest } = this.getEnds(sender);
        const height = await dest.client.doUpdateClient(dest.clientID, src.client);
        return height;
    }
    /**
     * Checks if the last proven header on the destination is older than maxAge,
     * and if so, update the client. Returns the new client height if updated,
     * or null if no update needed
     *
     * @param sender
     * @param maxAge
     */
    async updateClientIfStale(sender, maxAge) {
        this.logger.verbose(`Checking if ${this.otherChain(sender)} has recent header of ${this.chain(sender)}`);
        const { src, dest } = this.getEnds(sender);
        const knownHeader = await dest.client.query.ibc.client.consensusStateTm(dest.clientID);
        const currentHeader = await src.client.latestHeader();
        // quit now if we don't need to update
        const knownSeconds = knownHeader.timestamp?.seconds?.toNumber();
        if (knownSeconds) {
            const curSeconds = timestampFromDateNanos(currentHeader.time).seconds.toNumber();
            if (curSeconds - knownSeconds < maxAge) {
                return null;
            }
        }
        // otherwise, do the update
        return this.updateClient(sender);
    }
    /**
     * Ensures the dest has a proof of at least minHeight from source.
     * Will not execute any tx if not needed.
     * Will wait a block if needed until the header is available.
     *
     * Returns the latest header height now available on dest
     */
    async updateClientToHeight(source, minHeight) {
        this.logger.info(`Check whether client on ${this.otherChain(source)} >= height ${minHeight}`);
        const { src, dest } = this.getEnds(source);
        const client = await dest.client.query.ibc.client.stateTm(dest.clientID);
        // TODO: revisit where revision number comes from - this must be the number from the source chain
        const knownHeight = client.latestHeight?.revisionHeight?.toNumber() ?? 0;
        if (knownHeight >= minHeight && client.latestHeight !== undefined) {
            return client.latestHeight;
        }
        const curHeight = (await src.client.latestHeader()).height;
        if (curHeight < minHeight) {
            await src.client.waitOneBlock();
        }
        return this.updateClient(source);
    }
    async createChannel(sender, srcPort, destPort, ordering, version) {
        this.logger.info(`Create channel with sender ${this.chain(sender)}: ${srcPort} => ${destPort}`);
        const { src, dest } = this.getEnds(sender);
        // init on src
        const { channelId: channelIdSrc } = await src.client.channelOpenInit(srcPort, destPort, ordering, src.connectionID, version);
        // try on dest
        const proof = await prepareChannelHandshake(src.client, dest.client, dest.clientID, srcPort, channelIdSrc);
        const { channelId: channelIdDest } = await dest.client.channelOpenTry(destPort, { portId: srcPort, channelId: channelIdSrc }, ordering, dest.connectionID, version, version, proof);
        // ack on src
        const proofAck = await prepareChannelHandshake(dest.client, src.client, src.clientID, destPort, channelIdDest);
        await src.client.channelOpenAck(srcPort, channelIdSrc, channelIdDest, version, proofAck);
        // confirm on dest
        const proofConfirm = await prepareChannelHandshake(src.client, dest.client, dest.clientID, srcPort, channelIdSrc);
        await dest.client.channelOpenConfirm(destPort, channelIdDest, proofConfirm);
        return {
            src: {
                portId: srcPort,
                channelId: channelIdSrc,
            },
            dest: {
                portId: destPort,
                channelId: channelIdDest,
            },
        };
    }
    /**
     * This will check both sides for pending packets and relay them.
     * It will then relay all acks (previous and generated by the just-submitted packets).
     * If pending packets have timed out, it will submit a timeout instead of attempting to relay them.
     *
     * Returns the most recent heights it relay, which can be used as a start for the next round
     */
    async checkAndRelayPacketsAndAcks(relayFrom, timedoutThresholdBlocks = 0, timedoutThresholdSeconds = 0) {
        // FIXME: is there a cleaner way to get the height we query at?
        const [packetHeightA, packetHeightB, packetsA, packetsB,] = await Promise.all([
            this.endA.client.currentHeight(),
            this.endB.client.currentHeight(),
            this.getPendingPackets('A', { minHeight: relayFrom.packetHeightA }),
            this.getPendingPackets('B', { minHeight: relayFrom.packetHeightB }),
        ]);
        const cutoffHeightA = await this.endB.client.timeoutHeight(timedoutThresholdBlocks);
        const cutoffTimeA = secondsFromDateNanos(await this.endB.client.currentTime()) +
            timedoutThresholdSeconds;
        const { toSubmit: submitA, toTimeout: timeoutA } = splitPendingPackets(cutoffHeightA, cutoffTimeA, packetsA);
        const cutoffHeightB = await this.endA.client.timeoutHeight(timedoutThresholdBlocks);
        const cutoffTimeB = secondsFromDateNanos(await this.endA.client.currentTime()) +
            timedoutThresholdSeconds;
        const { toSubmit: submitB, toTimeout: timeoutB } = splitPendingPackets(cutoffHeightB, cutoffTimeB, packetsB);
        // FIXME: use the returned acks first? Then query for others?
        await Promise.all([
            this.relayPackets('A', submitA),
            this.relayPackets('B', submitB),
        ]);
        // let's wait a bit to ensure our newly committed acks are indexed
        await Promise.all([
            this.endA.client.waitOneBlock(),
            this.endB.client.waitOneBlock(),
        ]);
        const [ackHeightA, ackHeightB, acksA, acksB] = await Promise.all([
            this.endA.client.currentHeight(),
            this.endB.client.currentHeight(),
            this.getPendingAcks('A', { minHeight: relayFrom.ackHeightA }),
            this.getPendingAcks('B', { minHeight: relayFrom.ackHeightB }),
        ]);
        await Promise.all([this.relayAcks('A', acksA), this.relayAcks('B', acksB)]);
        await Promise.all([
            this.timeoutPackets('A', timeoutA),
            this.timeoutPackets('B', timeoutB),
        ]);
        const nextRelay = {
            packetHeightA,
            packetHeightB,
            ackHeightA,
            ackHeightB,
        };
        this.logger.verbose('next heights to relay', nextRelay);
        return nextRelay;
    }
    async getPendingPackets(source, opts = {}) {
        this.logger.verbose(`Get pending packets on ${this.chain(source)}`);
        const { src, dest } = this.getEnds(source);
        const allPackets = await src.querySentPackets(opts);
        const toFilter = allPackets.map(({ packet }) => packet);
        const query = async (port, channel, sequences) => {
            const res = await dest.client.query.ibc.channel.unreceivedPackets(port, channel, sequences);
            return res.sequences.map((seq) => seq.toNumber());
        };
        // This gets the subset of packets that were already processed on the receiving chain
        const unreceived = await this.filterUnreceived(toFilter, query, packetId);
        const unreceivedPackets = allPackets.filter(({ packet }) => unreceived[packetId(packet)].has(packet.sequence.toNumber()));
        // However, some of these may have already been submitted as timeouts on the source chain. Check and filter
        const valid = await Promise.all(unreceivedPackets.map(async (packet) => {
            const { sourcePort, sourceChannel, sequence } = packet.packet;
            try {
                // this throws an error if no commitment there
                await src.client.query.ibc.channel.packetCommitment(sourcePort, sourceChannel, sequence);
                return packet;
            }
            catch {
                return undefined;
            }
        }));
        return valid.filter((x) => x !== undefined);
    }
    async getPendingAcks(source, opts = {}) {
        this.logger.verbose(`Get pending acks on ${this.chain(source)}`);
        const { src, dest } = this.getEnds(source);
        const allAcks = await src.queryWrittenAcks(opts);
        const toFilter = allAcks.map(({ originalPacket }) => originalPacket);
        const query = async (port, channel, sequences) => {
            const res = await dest.client.query.ibc.channel.unreceivedAcks(port, channel, sequences);
            return res.sequences.map((seq) => seq.toNumber());
        };
        const unreceived = await this.filterUnreceived(toFilter, query, ackId);
        return allAcks.filter(({ originalPacket: packet }) => unreceived[ackId(packet)].has(packet.sequence.toNumber()));
    }
    async filterUnreceived(packets, unreceivedQuery, idFunc) {
        if (packets.length === 0) {
            return {};
        }
        const packetsPerDestination = packets.reduce((sorted, packet) => {
            const key = idFunc(packet);
            return {
                ...sorted,
                [key]: [...(sorted[key] ?? []), packet.sequence.toNumber()],
            };
        }, {});
        const unreceivedResponses = await Promise.all(Object.entries(packetsPerDestination).map(async ([destination, sequences]) => {
            const [port, channel] = destination.split(idDelim);
            const notfound = await unreceivedQuery(port, channel, sequences);
            return { key: destination, sequences: notfound };
        }));
        const unreceived = unreceivedResponses.reduce((nested, { key, sequences }) => {
            return {
                ...nested,
                [key]: new Set(sequences),
            };
        }, {});
        return unreceived;
    }
    // Returns the last height that this side knows of the other blockchain
    async lastKnownHeader(side) {
        this.logger.verbose(`Get last known header on ${this.chain(side)}`);
        const { src } = this.getEnds(side);
        const client = await src.client.query.ibc.client.stateTm(src.clientID);
        return client.latestHeight?.revisionHeight?.toNumber() ?? 0;
    }
    // this will update the client if needed and relay all provided packets from src -> dest
    // if packets are all older than the last consensusHeight, then we don't update the client.
    //
    // Returns all the acks that are associated with the just submitted packets
    async relayPackets(source, packets) {
        this.logger.info(`Relay ${packets.length} packets from ${this.chain(source)} => ${this.otherChain(source)}`);
        if (packets.length === 0) {
            return [];
        }
        const { src, dest } = this.getEnds(source);
        // check if we need to update client at all
        const neededHeight = Math.max(...packets.map((x) => x.height)) + 1;
        const headerHeight = await this.updateClientToHeight(source, neededHeight);
        const submit = packets.map(({ packet }) => packet);
        const proofs = await Promise.all(submit.map((packet) => src.client.getPacketProof(packet, headerHeight)));
        const { logs, height } = await dest.client.receivePackets(submit, proofs, headerHeight);
        const acks = parseAcksFromLogs(logs);
        return acks.map((ack) => ({ height, ...ack }));
    }
    // this will update the client if needed and relay all provided acks from src -> dest
    // (yes, dest is where the packet was sent, but the ack was written on src).
    // if acks are all older than the last consensusHeight, then we don't update the client.
    //
    // Returns the block height the acks were included in, or null if no acks sent
    async relayAcks(source, acks) {
        this.logger.info(`Relay ${acks.length} acks from ${this.chain(source)} => ${this.otherChain(source)}`);
        if (acks.length === 0) {
            return null;
        }
        const { src, dest } = this.getEnds(source);
        // check if we need to update client at all
        const neededHeight = Math.max(...acks.map((x) => x.height)) + 1;
        const headerHeight = await this.updateClientToHeight(source, neededHeight);
        const proofs = await Promise.all(acks.map((ack) => src.client.getAckProof(ack, headerHeight)));
        const { height } = await dest.client.acknowledgePackets(acks, proofs, headerHeight);
        return height;
    }
    // Source: the side that originally sent the packet
    // We need to relay a proof from dest -> source
    async timeoutPackets(source, packets) {
        this.logger.info(`Timeout ${packets.length} packets sent from ${this.chain(source)}`);
        if (packets.length === 0) {
            return null;
        }
        const { src, dest } = this.getEnds(source);
        const destSide = otherSide(source);
        // We need a header that is after the timeout, not after the packet was committed
        // This can get complex with timeout timestamps. Let's just update to latest
        await dest.client.waitOneBlock();
        const headerHeight = await this.updateClient(destSide);
        const rawPackets = packets.map(({ packet }) => packet);
        const proofAndSeqs = await Promise.all(rawPackets.map(async (packet) => {
            const fakeAck = {
                originalPacket: packet,
                acknowledgement: new Uint8Array(),
            };
            const { nextSequenceReceive: sequence, } = await dest.client.query.ibc.channel.nextSequenceReceive(packet.destinationPort, packet.destinationChannel);
            const proof = await dest.client.getTimeoutProof(fakeAck, headerHeight);
            return { proof, sequence };
        }));
        const proofs = proofAndSeqs.map(({ proof }) => proof);
        const seqs = proofAndSeqs.map(({ sequence }) => sequence);
        const { height } = await src.client.timeoutPackets(rawPackets, proofs, seqs, headerHeight);
        return height;
    }
    getEnds(src) {
        if (src === 'A') {
            return {
                src: this.endA,
                dest: this.endB,
            };
        }
        else {
            return {
                src: this.endB,
                dest: this.endA,
            };
        }
    }
}
const idDelim = ':';
const packetId = (packet) => `${packet.destinationPort}${idDelim}${packet.destinationChannel}`;
const ackId = (packet) => `${packet.sourcePort}${idDelim}${packet.sourceChannel}`;
async function createClients(nodeA, nodeB, 
// number of seconds the client (on B pointing to A) is valid without update
trustPeriodA, 
// number of seconds the client (on A pointing to B) is valid without update
trustPeriodB) {
    // client on B pointing to A
    const args = await buildCreateClientArgs(nodeA, trustPeriodA);
    const { clientId: clientIdB } = await nodeB.createTendermintClient(args.clientState, args.consensusState);
    // client on A pointing to B
    const args2 = await buildCreateClientArgs(nodeB, trustPeriodB);
    const { clientId: clientIdA } = await nodeA.createTendermintClient(args2.clientState, args2.consensusState);
    return [clientIdA, clientIdB];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGluay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvbGluay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkQsT0FBTyxFQUFpQixLQUFLLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUc1RSxPQUFPLEVBRUwsUUFBUSxHQUdULE1BQU0sWUFBWSxDQUFDO0FBQ3BCLE9BQU8sRUFDTCxxQkFBcUIsRUFHckIsdUJBQXVCLEVBQ3ZCLDBCQUEwQixHQUMzQixNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQVUsVUFBVSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQzlDLE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsb0JBQW9CLEVBQ3BCLG1CQUFtQixFQUNuQixzQkFBc0IsRUFDdEIsV0FBVyxHQUNaLE1BQU0sU0FBUyxDQUFDO0FBUWpCLE1BQU0sVUFBVSxTQUFTLENBQUMsSUFBVTtJQUNsQyxJQUFJLElBQUksS0FBSyxHQUFHLEVBQUU7UUFDaEIsT0FBTyxHQUFHLENBQUM7S0FDWjtTQUFNO1FBQ0wsT0FBTyxHQUFHLENBQUM7S0FDWjtBQUNILENBQUM7QUFXRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLE9BQU8sSUFBSTtJQWtPZiw4REFBOEQ7SUFDOUQsMENBQTBDO0lBQzFDLFlBQW1CLElBQWMsRUFBRSxJQUFjLEVBQUUsTUFBZTtRQUNoRSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sSUFBSSxJQUFJLFVBQVUsRUFBRSxDQUFDO1FBQ3pDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8s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