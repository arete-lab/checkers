import { fromUtf8, toHex, toUtf8 } from '@cosmjs/encoding';
import Long from 'long';
import { HashOp, LengthOp } from '../codec/confio/proofs';
import { Timestamp } from '../codec/google/protobuf/timestamp';
import { Packet } from '../codec/ibc/core/channel/v1/channel';
import { ClientState as TendermintClientState, ConsensusState as TendermintConsensusState, } from '../codec/ibc/lightclients/tendermint/v1/tendermint';
export function createBroadcastTxErrorMessage(result) {
    return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;
}
export function toIntHeight(height) {
    return height?.revisionHeight?.toNumber() ?? 0;
}
export function ensureIntHeight(height) {
    if (typeof height === 'number') {
        return height;
    }
    return toIntHeight(height);
}
export function subtractBlock(height, count = 1) {
    return {
        revisionNumber: height.revisionNumber,
        revisionHeight: height.revisionHeight.subtract(count),
    };
}
const regexRevNum = new RegExp('-([1-9][0-9]*)$');
export function parseRevisionNumber(chainId) {
    const match = chainId.match(regexRevNum);
    if (match && match.length >= 2) {
        return Long.fromString(match[1]);
    }
    return new Long(0);
}
// may will run the transform if value is defined, otherwise returns undefined
export function may(transform, value) {
    return value === undefined || value === null ? undefined : transform(value);
}
export function mapRpcPubKeyToProto(pubkey) {
    if (pubkey === undefined) {
        return undefined;
    }
    if (pubkey.algorithm == 'ed25519') {
        return {
            ed25519: pubkey.data,
            secp256k1: undefined,
        };
    }
    else if (pubkey.algorithm == 'secp256k1') {
        return {
            ed25519: undefined,
            secp256k1: pubkey.data,
        };
    }
    else {
        throw new Error(`Unknown validator pubkey type: ${pubkey.algorithm}`);
    }
}
export function timestampFromDateNanos(date) {
    const nanos = (date.getTime() % 1000) * 1000000 + (date.nanoseconds ?? 0);
    return Timestamp.fromPartial({
        seconds: new Long(date.getTime() / 1000),
        nanos,
    });
}
export function secondsFromDateNanos(date) {
    return Math.floor(date.getTime() / 1000);
}
export function buildConsensusState(header) {
    return TendermintConsensusState.fromPartial({
        timestamp: timestampFromDateNanos(header.time),
        root: {
            hash: header.appHash,
        },
        nextValidatorsHash: header.nextValidatorsHash,
    });
}
// Note: we hardcode a number of assumptions, like trust level, clock drift, and assume revisionNumber is 1
export function buildClientState(chainId, unbondingPeriodSec, trustPeriodSec, height) {
    // Copied here until https://github.com/confio/ics23/issues/36 is resolved
    // https://github.com/confio/ics23/blob/master/js/src/proofs.ts#L11-L26
    const iavlSpec = {
        leafSpec: {
            prefix: Uint8Array.from([0]),
            hash: HashOp.SHA256,
            prehashValue: HashOp.SHA256,
            prehashKey: HashOp.NO_HASH,
            length: LengthOp.VAR_PROTO,
        },
        innerSpec: {
            childOrder: [0, 1],
            minPrefixLength: 4,
            maxPrefixLength: 12,
            childSize: 33,
            hash: HashOp.SHA256,
        },
    };
    const tendermintSpec = {
        leafSpec: {
            prefix: Uint8Array.from([0]),
            hash: HashOp.SHA256,
            prehashValue: HashOp.SHA256,
            prehashKey: HashOp.NO_HASH,
            length: LengthOp.VAR_PROTO,
        },
        innerSpec: {
            childOrder: [0, 1],
            minPrefixLength: 1,
            maxPrefixLength: 1,
            childSize: 32,
            hash: HashOp.SHA256,
        },
    };
    return TendermintClientState.fromPartial({
        chainId,
        trustLevel: {
            numerator: Long.fromInt(1),
            denominator: Long.fromInt(3),
        },
        unbondingPeriod: {
            seconds: new Long(unbondingPeriodSec),
        },
        trustingPeriod: {
            seconds: new Long(trustPeriodSec),
        },
        maxClockDrift: {
            seconds: new Long(20),
        },
        latestHeight: height,
        proofSpecs: [iavlSpec, tendermintSpec],
        upgradePath: ['upgrade', 'upgradedIBCState'],
        allowUpdateAfterExpiry: false,
        allowUpdateAfterMisbehaviour: false,
    });
}
export function parsePacketsFromLogs(logs) {
    // grab all send_packet events from the logs
    const allEvents = logs.map((log) => log.events.filter(({ type }) => type === 'send_packet'));
    const flatEvents = [].concat(...allEvents);
    return flatEvents.map(parsePacket);
}
export function parseHeightAttribute(attribute) {
    const [timeoutRevisionNumber, timeoutRevisionHeight] = attribute?.split('-') ?? [];
    if (!timeoutRevisionHeight || !timeoutRevisionNumber) {
        return undefined;
    }
    const revisionNumber = Long.fromString(timeoutRevisionNumber);
    const revisionHeight = Long.fromString(timeoutRevisionHeight);
    // note: 0 revisionNumber is allowed. If there is bad data, '' or '0-0', we will get 0 for the height
    if (revisionHeight.isZero()) {
        return undefined;
    }
    return { revisionHeight, revisionNumber };
}
export function parsePacket({ type, attributes }) {
    if (type !== 'send_packet') {
        throw new Error(`Cannot parse event of type ${type}`);
    }
    const attributesObj = attributes.reduce((acc, { key, value }) => ({
        ...acc,
        [key]: value,
    }), {});
    return Packet.fromPartial({
        sequence: may(Long.fromString, attributesObj.packet_sequence),
        /** identifies the port on the sending chain. */
        sourcePort: attributesObj.packet_src_port,
        /** identifies the channel end on the sending chain. */
        sourceChannel: attributesObj.packet_src_channel,
        /** identifies the port on the receiving chain. */
        destinationPort: attributesObj.packet_dst_port,
        /** identifies the channel end on the receiving chain. */
        destinationChannel: attributesObj.packet_dst_channel,
        /** actual opaque bytes transferred directly to the application module */
        data: attributesObj.packet_data
            ? toUtf8(attributesObj.packet_data)
            : undefined,
        /** block height after which the packet times out */
        timeoutHeight: parseHeightAttribute(attributesObj.packet_timeout_height),
        /** block timestamp (in nanoseconds) after which the packet times out */
        timeoutTimestamp: may(Long.fromString, attributesObj.packet_timeout_timestamp),
    });
}
export function parseAcksFromLogs(logs) {
    // grab all send_packet events from the logs
    const allEvents = logs.map((log) => log.events.filter(({ type }) => type === 'write_acknowledgement'));
    const flatEvents = [].concat(...allEvents);
    return flatEvents.map(parseAck);
}
export function parseAck({ type, attributes }) {
    if (type !== 'write_acknowledgement') {
        throw new Error(`Cannot parse event of type ${type}`);
    }
    const attributesObj = attributes.reduce((acc, { key, value }) => ({
        ...acc,
        [key]: value,
    }), {});
    const originalPacket = Packet.fromPartial({
        sequence: may(Long.fromString, attributesObj.packet_sequence),
        /** identifies the port on the sending chain. */
        sourcePort: attributesObj.packet_src_port,
        /** identifies the channel end on the sending chain. */
        sourceChannel: attributesObj.packet_src_channel,
        /** identifies the port on the receiving chain. */
        destinationPort: attributesObj.packet_dst_port,
        /** identifies the channel end on the receiving chain. */
        destinationChannel: attributesObj.packet_dst_channel,
        /** actual opaque bytes transferred directly to the application module */
        data: toUtf8(attributesObj.packet_data ?? ''),
        /** block height after which the packet times out */
        timeoutHeight: parseHeightAttribute(attributesObj.packet_timeout_height),
        /** block timestamp (in nanoseconds) after which the packet times out */
        timeoutTimestamp: may(Long.fromString, attributesObj.packet_timeout_timestamp),
    });
    const acknowledgement = toUtf8(attributesObj.packet_ack ?? '');
    return {
        acknowledgement,
        originalPacket,
    };
}
export function multiplyFees({ gas, amount }, mult) {
    const multGas = Number.parseInt(gas, 10) * mult;
    const multAmount = amount.map((c) => multiplyCoin(c, mult));
    const result = {
        gas: multGas.toString(),
        amount: multAmount,
    };
    return result;
}
export function multiplyCoin({ amount, denom }, mult) {
    const multAmount = Number.parseInt(amount, 10) * mult;
    return { amount: multAmount.toString(), denom };
}
// return true if a > b, or a undefined
export function heightGreater(a, b) {
    if (a === undefined) {
        return true;
    }
    // comparing longs made some weird issues (maybe signed/unsigned)?
    // convert to numbers to compare safely
    const [numA, heightA, numB, heightB] = [
        a.revisionNumber.toNumber(),
        a.revisionHeight.toNumber(),
        b.revisionNumber.toNumber(),
        b.revisionHeight.toNumber(),
    ];
    const valid = numA > numB || (numA == numB && heightA > heightB);
    return valid;
}
// return true if a > b, or a 0
// note a is nanoseconds, while b is seconds
export function timeGreater(a, b) {
    if (a === undefined || a.isZero()) {
        return true;
    }
    const valid = a.toNumber() > b * 1000000000;
    return valid;
}
// take height and time from receiving chain to see which packets have timed out
// return [toSubmit, toTimeout].
// you can advance height, time a block or two into the future if you wish a margin of error
export function splitPendingPackets(currentHeight, currentTime, // in seconds
packets) {
    return packets.reduce((acc, packet) => {
        const validPacket = heightGreater(packet.packet.timeoutHeight, currentHeight) &&
            timeGreater(packet.packet.timeoutTimestamp, currentTime);
        return validPacket
            ? {
                ...acc,
                toSubmit: [...acc.toSubmit, packet],
            }
            : {
                ...acc,
                toTimeout: [...acc.toTimeout, packet],
            };
    }, {
        toSubmit: [],
        toTimeout: [],
    });
}
export function presentPacketData(data) {
    try {
        return JSON.parse(fromUtf8(data));
    }
    catch {
        return { hex: toHex(data) };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBUTNELE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUV4QixPQUFPLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzFELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUMvRCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFFOUQsT0FBTyxFQUNMLFdBQVcsSUFBSSxxQkFBcUIsRUFDcEMsY0FBYyxJQUFJLHdCQUF3QixHQUMzQyxNQUFNLG9EQUFvRCxDQUFDO0FBVTVELE1BQU0sVUFBVSw2QkFBNkIsQ0FDM0MsTUFBMEI7SUFFMUIsT0FBTyw4QkFBOEIsTUFBTSxDQUFDLGVBQWUsY0FBYyxNQUFNLENBQUMsTUFBTSxXQUFXLE1BQU0sQ0FBQyxJQUFJLGNBQWMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQzVJLENBQUM7QUFFRCxNQUFNLFVBQVUsV0FBVyxDQUFDLE1BQWU7SUFDekMsT0FBTyxNQUFNLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNqRCxDQUFDO0FBRUQsTUFBTSxVQUFVLGVBQWUsQ0FBQyxNQUF1QjtJQUNyRCxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtRQUM5QixPQUFPLE1BQU0sQ0FBQztLQUNmO0lBQ0QsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDN0IsQ0FBQztBQUVELE1BQU0sVUFBVSxhQUFhLENBQUMsTUFBYyxFQUFFLEtBQUssR0FBRyxDQUFDO0lBQ3JELE9BQU87UUFDTCxjQUFjLEVBQUUsTUFBTSxDQUFDLGNBQWM7UUFD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