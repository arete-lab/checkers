"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
var __exportStar = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module) => {
  return __exportStar(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? {get: () => module.default, enumerable: true} : {value: module, enumerable: true})), module);
};

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs2 = require("fs");
  var path3 = require("path");
  function log(message) {
    console.log(`[dotenv][DEBUG] ${message}`);
  }
  var NEWLINE = "\n";
  var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
  var RE_NEWLINES = /\\n/g;
  var NEWLINES_MATCH = /\n|\r|\r\n/;
  function parse(src, options) {
    const debug = Boolean(options && options.debug);
    const obj = {};
    src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
      const keyValueArr = line.match(RE_INI_KEY_VAL);
      if (keyValueArr != null) {
        const key = keyValueArr[1];
        let val = keyValueArr[2] || "";
        const end = val.length - 1;
        const isDoubleQuoted = val[0] === '"' && val[end] === '"';
        const isSingleQuoted = val[0] === "'" && val[end] === "'";
        if (isSingleQuoted || isDoubleQuoted) {
          val = val.substring(1, end);
          if (isDoubleQuoted) {
            val = val.replace(RE_NEWLINES, NEWLINE);
          }
        } else {
          val = val.trim();
        }
        obj[key] = val;
      } else if (debug) {
        log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
      }
    });
    return obj;
  }
  function config(options) {
    let dotenvPath = path3.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let debug = false;
    if (options) {
      if (options.path != null) {
        dotenvPath = options.path;
      }
      if (options.encoding != null) {
        encoding = options.encoding;
      }
      if (options.debug != null) {
        debug = true;
      }
    }
    try {
      const parsed = parse(fs2.readFileSync(dotenvPath, {encoding}), {debug});
      Object.keys(parsed).forEach(function(key) {
        if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
          process.env[key] = parsed[key];
        } else if (debug) {
          log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
        }
      });
      return {parsed};
    } catch (e) {
      return {error: e};
    }
  }
  module.exports.config = config;
  module.exports.parse = parse;
});

// node_modules/dotenv-expand/lib/main.js
var require_main2 = __commonJS((exports, module) => {
  "use strict";
  var dotenvExpand2 = function(config) {
    var environment = config.ignoreProcessEnv ? {} : process.env;
    var interpolate = function(envValue) {
      var matches = envValue.match(/(.?\${?(?:[a-zA-Z0-9_]+)?}?)/g) || [];
      return matches.reduce(function(newEnv, match) {
        var parts = /(.?)\${?([a-zA-Z0-9_]+)?}?/g.exec(match);
        var prefix = parts[1];
        var value2, replacePart;
        if (prefix === "\\") {
          replacePart = parts[0];
          value2 = replacePart.replace("\\$", "$");
        } else {
          var key = parts[2];
          replacePart = parts[0].substring(prefix.length);
          value2 = environment.hasOwnProperty(key) ? environment[key] : config.parsed[key] || "";
          value2 = interpolate(value2);
        }
        return newEnv.replace(replacePart, value2);
      }, envValue);
    };
    for (var configKey in config.parsed) {
      var value = environment.hasOwnProperty(configKey) ? environment[configKey] : config.parsed[configKey];
      config.parsed[configKey] = interpolate(value);
    }
    for (var processKey in config.parsed) {
      environment[processKey] = config.parsed[processKey];
    }
    return config;
  };
  module.exports = dotenvExpand2;
});

// src/lib/env.ts
var import_dotenv = __toModule(require_main());
var import_dotenv_expand = __toModule(require_main2());
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);
function lookupFile(dir, formats, pathOnly = false) {
  for (const format of formats) {
    const fullPath = _path2.default.join(dir, format);
    if (_fs2.default.existsSync(fullPath) && _fs2.default.statSync(fullPath).isFile()) {
      return pathOnly ? fullPath : _fs2.default.readFileSync(fullPath, "utf-8");
    }
  }
  const parentDir = _path2.default.dirname(dir);
  if (parentDir !== dir) {
    return lookupFile(parentDir, formats, pathOnly);
  }
}
function loadEnv(loadOptions) {
  const {mode, envDir, prefix, ignoreProcessEnv} = loadOptions;
  if (mode === "local") {
    throw new Error(`"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`);
  }
  const env = {};
  const envFiles = [
    `.env.${mode}.local`,
    `.env.${mode}`,
    `.env.local`,
    `.env`
  ];
  for (const key in process.env) {
    if (key.startsWith(prefix) && env[key] === void 0) {
      env[key] = process.env[key];
    }
  }
  for (const file of envFiles) {
    const path3 = lookupFile(envDir, [file], true);
    if (path3) {
      const parsed = import_dotenv.default.parse(_fs2.default.readFileSync(path3), {
        debug: !!process.env.DEBUG || void 0
      });
      (0, import_dotenv_expand.default)({
        parsed,
        ignoreProcessEnv
      });
      for (const [key, value] of Object.entries(parsed)) {
        if (key.startsWith(prefix) && env[key] === void 0) {
          env[key] = value;
        } else if (key === "NODE_ENV") {
          process.env.VITE_USER_NODE_ENV = value;
        }
      }
    }
  }
  return env;
}
function loadDynamicInjectedEnv(prefix) {
  const env = {};
  Object.keys(process.env).map((envKey) => {
    if (String(envKey).includes(prefix)) {
      env[envKey] = process.env[envKey] || "";
    }
  });
  return env;
}

// package.json
var name = "vite-plugin-env-compatible";

// src/index.ts

function envCompatible(userOptions = {}) {
  const options = {
    mountedPath: "process.env",
    ...userOptions
  };
  return {
    name,
    enforce: "pre",
    config(config, {mode}) {
      const root = config.root || process.cwd();
      let envDir = config.envDir || "./";
      if (!_path2.default.isAbsolute(envDir || "")) {
        envDir = _path2.default.join(root, envDir);
      }
      const prefix = typeof options.prefix === "undefined" ? "VUE_APP_" : options.prefix;
      const env = loadEnv({
        mode,
        envDir,
        prefix,
        ignoreProcessEnv: _nullishCoalesce(options.ignoreProcessEnv, () => ( false))
      });
      const dynamicInjectedEnv = loadDynamicInjectedEnv(prefix);
      const myDefine = {};
      if (_optionalChain([options, 'access', _ => _.mountedPath, 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3("process.env")])) {
        myDefine["process.env.VITE"] = JSON.stringify(true);
      }
      Object.keys({...env, ...dynamicInjectedEnv}).map((key) => {
        const value = env[key];
        myDefine[`${options.mountedPath}.${key}`] = JSON.stringify(value);
      });
      config.define = {
        ...config.define || {},
        ...myDefine
      };
    }
  };
}


exports.default = envCompatible;
